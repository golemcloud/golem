// Copyright 2024-2025 Golem Cloud
//
// Licensed under the Golem Source License v1.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://license.golem.cloud/LICENSE
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

mod javascript;
mod ts_writer;

#[cfg(test)]
mod tests;

use crate::bridge_gen::typescript::javascript::escape_js_ident;
use crate::bridge_gen::typescript::ts_writer::{indent, TsFunctionWriter, TsWriter};
use crate::bridge_gen::BridgeGenerator;
use anyhow::anyhow;
use camino::{Utf8Path, Utf8PathBuf};
use golem_common::model::agent::{AgentMode, AgentType, DataSchema, ElementSchema};
use golem_wasm::analysis::AnalysedType;
use heck::{ToLowerCamelCase, ToSnakeCase, ToUpperCamelCase};
use serde_json::json;

struct TypeScriptBridgeGenerator {
    target_path: Utf8PathBuf,
    agent_type: AgentType,
}

impl TypeScriptBridgeGenerator {
    pub fn new(agent_type: AgentType, target_path: &Utf8Path) -> Self {
        Self {
            target_path: target_path.to_path_buf(),
            agent_type,
        }
    }

    fn generate_package_json(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let package_json = json! {
            {
                "name": self.library_name(),
                "version": "0.0.1", // TODO: use user-defined agent version if available
                "description": "Generated by golem-cli",
                "main": "self.library_name().js",
                "types": "self.library_name().d.ts",
                "scripts": {
                    "build": "tsc"
                },
                "dependencies": {
                    "uuid": "^13"
                },
                "devDependencies": {
                    "typescript": "^5.9"
                }
            }
        };
        std::fs::write(path, serde_json::to_string_pretty(&package_json)?)
            .map_err(|e| anyhow!("Failed to write package.json file: {e}"))?;
        Ok(())
    }

    fn generate_tsconfig_json(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let tsconfig_json = json! {
            {
                "compilerOptions": {
                    "target": "es2020",
                    "module": "esnext",
                    "moduleResolution": "node",
                    "strict": true,
                    "esModuleInterop": true,
                    "skipLibCheck": true,
                    "forceConsistentCasingInFileNames": true,
                    "declaration": true,
                },
                "include": [
                    format!("{}.ts", self.library_name()),
                    "base.ts" // TODO: publish this as a base package
                ]
            }
        };
        std::fs::write(path, serde_json::to_string_pretty(&tsconfig_json)?)
            .map_err(|e| anyhow!("Failed to write tsconfig.json file: {e}"))?;
        Ok(())
    }

    fn generate_base_ts(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let base_ts_content = include_str!("../../../ts_bridge/base.ts");
        std::fs::write(path, base_ts_content)
            .map_err(|e| anyhow!("Failed to write base.ts file: {e}"))?;
        Ok(())
    }

    fn generate_ts(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let mut writer = TsWriter::new();

        writer.import_item("v4", "uuidv4", "uuid");
        writer.import_module("base", "./base"); // TODO: replace to dependency

        writer.declare_global(
            &self.global_config_var_name(),
            "base.GolemServer",
            Some("\"local\""),
        );

        let types = super::collect_all_wit_types(&self.agent_type);
        for typ in types {
            self.generate_ts_wit_type_def(&mut writer, &typ)?;
        }

        let class_name = self.agent_type.type_name.0.to_upper_camel_case();
        writer.begin_export_class(&class_name);

        if self.agent_type.mode == AgentMode::Durable {
            let mut get = writer.begin_static_method("get");
            Self::write_parameter_list(&mut get, &self.agent_type.constructor.input_schema)?;
            get.result(&class_name);

            get.write_line("throw new Error(\"Not implemented\");")
        }

        {
            let mut get_phantom = writer.begin_static_method("getPhantom");
            get_phantom.param("phantomId", "base.PhantomId");
            Self::write_parameter_list(
                &mut get_phantom,
                &self.agent_type.constructor.input_schema,
            )?;
            get_phantom.result(&class_name);

            get_phantom.write_line("throw new Error(\"Not implemented\");")
        }

        {
            let mut new_phantom = writer.begin_static_method("newPhantom");
            Self::write_parameter_list(
                &mut new_phantom,
                &self.agent_type.constructor.input_schema,
            )?;
            new_phantom.result(&class_name);

            new_phantom.write_line("throw new Error(\"Not implemented\");")
        }

        for method_def in &self.agent_type.methods {
            let mut method = writer.begin_async_method(&method_def.name);
            Self::write_parameter_list(&mut method, &method_def.input_schema)?;
            Self::write_result(&mut method, &method_def.output_schema)?;
            method.write_line("throw new Error(\"Not implemented\");")

            // TODO: trigger, schedule
        }

        writer.end_export_class();

        {
            let mut configure = writer.begin_export_function("configure");
            configure.param("server", "base.GolemServer");

            configure.write_line(format!("{} = server;", self.global_config_var_name()));
        }

        writer.finish(path)
    }

    fn generate_ts_wit_type_def(
        &self,
        writer: &mut TsWriter,
        typ: &AnalysedType,
    ) -> anyhow::Result<()> {
        if let Some(name) = typ.name() {
            let name = name.to_upper_camel_case(); // TODO: use owner too?
            let def = Self::type_definition(typ)?;
            writer.export_type(&name, &def);
        }

        Ok(())
    }

    fn write_parameter_list(
        writer: &mut TsFunctionWriter<'_>,
        schema: &DataSchema,
    ) -> anyhow::Result<()> {
        match schema {
            DataSchema::Tuple(params) => {
                for param in &params.elements {
                    let param_name = param.name.to_lower_camel_case();
                    match &param.schema {
                        ElementSchema::ComponentModel(component_model) => writer.param(
                            &param_name,
                            &Self::type_reference(&component_model.element_type)?,
                        ),
                        ElementSchema::UnstructuredText(_) => {
                            todo!()
                        }
                        ElementSchema::UnstructuredBinary(_) => {
                            todo!()
                        }
                    }
                }
                Ok(())
            }
            DataSchema::Multimodal(_) => {
                todo!()
            }
        }
    }

    fn write_result(writer: &mut TsFunctionWriter<'_>, schema: &DataSchema) -> anyhow::Result<()> {
        match schema {
            DataSchema::Tuple(params) => {
                for param in &params.elements {
                    match &param.schema {
                        ElementSchema::ComponentModel(component_model) => {
                            writer.result(&Self::type_reference(&component_model.element_type)?)
                        }
                        ElementSchema::UnstructuredText(_) => {
                            todo!()
                        }
                        ElementSchema::UnstructuredBinary(_) => {
                            todo!()
                        }
                    }
                }
                Ok(())
            }
            DataSchema::Multimodal(_) => {
                todo!()
            }
        }
    }

    fn type_reference(typ: &AnalysedType) -> anyhow::Result<String> {
        match typ {
            AnalysedType::Str(_) => Ok("string".to_string()),
            AnalysedType::Chr(_) => Ok("string".to_string()),
            AnalysedType::F64(_) => Ok("number".to_string()),
            AnalysedType::F32(_) => Ok("number".to_string()),
            AnalysedType::U64(_) => Ok("number".to_string()),
            AnalysedType::S64(_) => Ok("number".to_string()),
            AnalysedType::U32(_) => Ok("number".to_string()),
            AnalysedType::S32(_) => Ok("number".to_string()),
            AnalysedType::U16(_) => Ok("number".to_string()),
            AnalysedType::S16(_) => Ok("number".to_string()),
            AnalysedType::U8(_) => Ok("number".to_string()),
            AnalysedType::S8(_) => Ok("number".to_string()),
            AnalysedType::Bool(_) => Ok("boolean".to_string()),
            AnalysedType::Chr(_) => Ok("string".to_string()),
            AnalysedType::Str(_) => Ok("string".to_string()),
            AnalysedType::Option(inner) => {
                let inner_ts_type = Self::type_reference(&*inner.inner)?;
                Ok(format!("{} | undefined", inner_ts_type)) // TODO: use ? in parameter and field positions
            }
            AnalysedType::List(inner) => {
                let inner_ts_type = Self::type_reference(&*inner.inner)?;
                Ok(format!("{}[]", inner_ts_type))
            }
            // TODO: result
            AnalysedType::Handle(_) => Err(anyhow!("Handle types are not supported")),
            _ => match typ.name() {
                Some(name) => Ok(name.to_upper_camel_case()), // TODO: use owner too?
                None => Err(anyhow!("Complex type reference with no type name: {typ:?}")),
            },
        }
    }

    fn type_definition(typ: &AnalysedType) -> anyhow::Result<String> {
        match typ {
            AnalysedType::Variant(variant) => {
                let mut case_defs = Vec::new();
                for case in &variant.cases {
                    let case_name = &case.name;
                    match &case.typ {
                        Some(ty) => {
                            let case_type = Self::type_reference(ty)?;
                            case_defs
                                .push(format!("{{\n  tag: '{case_name}'\n  val: {case_type}\n}}"));
                        }
                        None => {
                            // No type means it's a unit variant
                            case_defs.push(format!("{{\n  tag: '{case_name}'\n}}"));
                        }
                    }
                }
                let cases = format!("\n{}", case_defs.join(" |\n"));
                Ok(cases)
            }
            AnalysedType::Result(result) => {
                let ok_type = result
                    .ok
                    .as_ref()
                    .map(|t| Self::type_reference(&t))
                    .transpose()?
                    .unwrap_or("void".to_string());
                let err_type = result
                    .err
                    .as_ref()
                    .map(|t| Self::type_reference(&t))
                    .transpose()?
                    .unwrap_or("Error".to_string());
                Ok(format!("Result<{ok_type}, {err_type}>")) // TODO: we need a Result type in the common lib
            }
            AnalysedType::Option(option) => {
                let inner_ts_type = Self::type_reference(&*option.inner)?;
                Ok(format!("{} | undefined", inner_ts_type))
            }
            AnalysedType::Enum(r#enum) => {
                let cases = r#enum
                    .cases
                    .iter()
                    .map(|case| format!("\"{}\"", case))
                    .collect::<Vec<_>>();
                Ok(cases.join(" | "))
            }
            AnalysedType::Flags(flags) => {
                let mut flags_def = String::new();
                flags_def.push_str("{\n");
                for flag in &flags.names {
                    let flag_name = escape_js_ident(flag.to_lower_camel_case());
                    flags_def.push_str(&format!("  {flag_name}: boolean;\n"));
                }
                flags_def.push('}');
                Ok(flags_def)
            }
            AnalysedType::Record(record) => {
                let mut record_def = String::new();
                record_def.push_str("{\n");
                for field in &record.fields {
                    let js_name = escape_js_ident(field.name.to_lower_camel_case());
                    let field_str = if let AnalysedType::Option(option) = &field.typ {
                        let field_type = Self::type_reference(&*option.inner)?;
                        format!("{js_name}?: {field_type};\n")
                    } else {
                        let field_type = Self::type_reference(&field.typ)?;
                        format!("{js_name}: {field_type};\n")
                    };
                    let indented = indent(&field_str, 2);
                    record_def.push_str(&indented);
                }
                record_def.push('}');
                Ok(record_def)
            }
            AnalysedType::Tuple(tuple) => {
                let types: Vec<String> = tuple
                    .items
                    .iter()
                    .map(|t| Self::type_reference(t))
                    .collect::<Result<_, _>>()?;
                Ok(format!("[{}]", types.join(", ")))
            }
            AnalysedType::List(list) => {
                if matches!(*list.inner, AnalysedType::U8(_)) {
                    Ok("Uint8Array".to_string())
                } else {
                    let inner_type = Self::type_reference(&*list.inner)?;
                    Ok(format!("{}[]", inner_type))
                }
            }
            AnalysedType::Str(_) => Ok("string".to_string()),
            AnalysedType::Chr(_) => Ok("string".to_string()),
            AnalysedType::F64(_) => Ok("number".to_string()),
            AnalysedType::F32(_) => Ok("number".to_string()),
            AnalysedType::U64(_) => Ok("number".to_string()),
            AnalysedType::S64(_) => Ok("number".to_string()),
            AnalysedType::U32(_) => Ok("number".to_string()),
            AnalysedType::S32(_) => Ok("number".to_string()),
            AnalysedType::U16(_) => Ok("number".to_string()),
            AnalysedType::S16(_) => Ok("number".to_string()),
            AnalysedType::U8(_) => Ok("number".to_string()),
            AnalysedType::S8(_) => Ok("number".to_string()),
            AnalysedType::Bool(_) => Ok("boolean".to_string()),
            AnalysedType::Handle(_) => Err(anyhow!("Handle types are not supported")),
        }
    }

    fn library_name(&self) -> String {
        self.agent_type.type_name.0.to_snake_case()
    }

    fn global_config_var_name(&self) -> String {
        format!(
            "{}Configuration",
            self.agent_type.type_name.0.to_lower_camel_case()
        )
    }
}

impl BridgeGenerator for TypeScriptBridgeGenerator {
    fn new(agent_type: AgentType, target_path: &Utf8Path) -> Self {
        Self {
            target_path: target_path.to_path_buf(),
            agent_type,
        }
    }

    fn generate(&self) -> anyhow::Result<()> {
        let library_name = self.library_name();

        let ts_path = self.target_path.join(format!("{library_name}.ts"));
        let package_json_path = self.target_path.join("package.json".to_string());
        let tsconfig_json_path = self.target_path.join("tsconfig.json".to_string());
        let base_ts_path = self.target_path.join("base.ts");

        if !self.target_path.exists() {
            std::fs::create_dir_all(&self.target_path)?;
        }
        self.generate_ts(&ts_path)?;
        self.generate_package_json(&package_json_path)?;
        self.generate_tsconfig_json(&tsconfig_json_path)?;
        self.generate_base_ts(&base_ts_path)?; // TODO: remove once this is published as a library

        Ok(())
    }
}

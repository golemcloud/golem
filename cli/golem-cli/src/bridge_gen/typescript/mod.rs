// Copyright 2024-2025 Golem Cloud
//
// Licensed under the Golem Source License v1.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://license.golem.cloud/LICENSE
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

mod javascript;
#[allow(dead_code)]
mod ts_writer;
mod type_name;

#[cfg(test)]
mod tests;

use crate::bridge_gen::type_naming::TypeNaming;
use crate::bridge_gen::typescript::javascript::escape_js_ident;
use crate::bridge_gen::typescript::ts_writer::{
    indent, FunctionWriter, TsAnonymousFunctionWriter, TsFunctionWriter, TsWriter,
};
use crate::bridge_gen::typescript::type_name::TypeScriptTypeName;
use crate::bridge_gen::{bridge_client_directory_name, BridgeGenerator};
use anyhow::anyhow;
use camino::{Utf8Path, Utf8PathBuf};
use golem_client::LOCAL_WELL_KNOWN_TOKEN;
use golem_common::model::agent::wit_naming::ToWitNaming;
use golem_common::model::agent::{
    AgentMethod, AgentMode, AgentType, BinaryDescriptor, DataSchema, ElementSchema,
    NamedElementSchema, NamedElementSchemas, TextDescriptor,
};
use golem_wasm::analysis::AnalysedType;
use heck::{ToLowerCamelCase, ToUpperCamelCase};
use indoc::formatdoc;
use serde_json::json;

pub struct TypeScriptBridgeGenerator {
    target_path: Utf8PathBuf,
    type_naming: TypeNaming<TypeScriptTypeName>,
    agent_type: AgentType,
    testing: bool,
}

impl BridgeGenerator for TypeScriptBridgeGenerator {
    fn new(agent_type: AgentType, target_path: &Utf8Path, testing: bool) -> anyhow::Result<Self> {
        TypeScriptBridgeGenerator::new(agent_type, target_path, testing)
    }

    fn generate(&mut self) -> anyhow::Result<()> {
        let library_name = self.library_name();

        let ts_path = self.target_path.join(format!("{library_name}.ts"));
        let package_json_path = self.target_path.join("package.json");
        let tsconfig_json_path = self.target_path.join("tsconfig.json");
        let base_ts_path = self.target_path.join("base.ts");
        let test_path = self.target_path.join("test.ts");

        if !self.target_path.exists() {
            std::fs::create_dir_all(&self.target_path)?;
        }
        self.generate_ts(&ts_path)?;
        self.generate_package_json(&package_json_path)?;
        self.generate_tsconfig_json(&tsconfig_json_path)?;
        self.generate_base_ts(&base_ts_path)?;
        if self.testing {
            self.generate_test(&test_path)?;
        }

        Ok(())
    }
}

impl TypeScriptBridgeGenerator {
    pub fn new(
        agent_type: AgentType,
        target_path: &Utf8Path,
        testing: bool,
    ) -> anyhow::Result<Self> {
        Ok(Self {
            target_path: target_path.to_path_buf(),
            type_naming: TypeNaming::new(&agent_type)?,
            agent_type,
            testing,
        })
    }

    /// Generates the client library's package.json
    fn generate_package_json(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let scripts = if self.testing {
            json!(
              {
                "build": "tsc",
                "test": "npx tsx test.ts"
            })
        } else {
            json!({
                "build": "tsc",
            })
        };
        let package_json = json! {
            {
                "name": self.library_name(),
                "version": "0.0.1", // TODO: use user-defined agent version if available
                "description": "Generated by golem-cli",
                "type": "module",
                "main": format!("{}.js", self.library_name()),
                "types": format!("{}.d.ts", self.library_name()),
                "scripts": scripts,
                "dependencies": {
                    "uuid": "^13"
                },
                "devDependencies": {
                    "typescript": "^5.9",
                    "tsx": "^4.7",
                    "@types/node": "^25",
                }
            }
        };
        std::fs::write(path, serde_json::to_string_pretty(&package_json)?)
            .map_err(|e| anyhow!("Failed to write package.json file: {e}"))?;
        Ok(())
    }

    /// Generates the client library's tsconfig.json
    fn generate_tsconfig_json(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let mut include = vec![format!("{}.ts", self.library_name()), "base.ts".to_string()];
        if self.testing {
            include.push("test.ts".to_string());
        }

        let tsconfig_json = json! {
            {
                "compilerOptions": {
                    "target": "es2020",
                    "module": "esnext",
                    "moduleResolution": "node",
                    "strict": true,
                    "esModuleInterop": true,
                    "skipLibCheck": true,
                    "forceConsistentCasingInFileNames": true,
                    "declaration": true,
                },
                "include": include
            }
        };
        std::fs::write(path, serde_json::to_string_pretty(&tsconfig_json)?)
            .map_err(|e| anyhow!("Failed to write tsconfig.json file: {e}"))?;
        Ok(())
    }

    /// Writes the base.ts common helper file and embeds the well-known local server token into it.
    fn generate_base_ts(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let base_ts_content_template = include_str!("../../../ts_bridge/base.ts");
        let base_ts_content = base_ts_content_template
            .replace("__REPLACE_WITH_LOCAL_TOKEN__", LOCAL_WELL_KNOWN_TOKEN);

        std::fs::write(path, base_ts_content)
            .map_err(|e| anyhow!("Failed to write base.ts file: {e}"))?;
        Ok(())
    }

    /// Generates the test.ts module. This module exposes encoding/decoding functions via
    /// stdin/out to be used from tests only. The test module is not usable by itself and
    /// should never be part of the generated NPM package outside of Golem's internal tests.
    fn generate_test(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let mut writer = TsWriter::new();

        self.generate_test_imports(&mut writer);
        self.generate_test_type_definitions(&mut writer)?;
        self.generate_test_read_stdin_helper(&mut writer);
        self.generate_test_method_functions(&mut writer)?;
        self.generate_test_functions_map(&mut writer);
        self.generate_test_main_handler(&mut writer)?;
        self.generate_test_entry_point(&mut writer);

        writer.finish(path)
    }

    /// Writes the imports section of the test module.
    fn generate_test_imports(&self, writer: &mut TsWriter) {
        writer.import_module("base", "./base");
    }

    /// Defines the test types and their corresponding encode/decode functions. These types and functions are
    /// also generated into the main module, but there they are private. For testing, we duplicate
    /// them in the test module.
    fn generate_test_type_definitions(&self, writer: &mut TsWriter) -> anyhow::Result<()> {
        self.generate_ts_type_definitions(writer)
    }

    /// Write a helper function to the test module to read a JSON from stdin
    fn generate_test_read_stdin_helper(&self, writer: &mut TsWriter) {
        let mut read_stdin = writer.begin_export_async_function("readStdin");
        read_stdin.result("any");
        read_stdin.write_line("let input = '';");
        read_stdin.write_line("for await (const chunk of process.stdin) {");
        read_stdin.indent();
        read_stdin.write_line("input += chunk;");
        read_stdin.unindent();
        read_stdin.write_line("}");
        read_stdin.write_line("return JSON.parse(input);");
        drop(read_stdin);

        writer.write_line("");
    }

    /// Generate encode/decode test functions for each agent method's input and output schema
    fn generate_test_method_functions(&self, writer: &mut TsWriter) -> anyhow::Result<()> {
        // Generate test functions for each method using the same code generators as the main library
        for method_def in &self.agent_type.methods {
            self.generate_test_method_encode_input(writer, method_def)?;
            writer.write_line("");
            self.generate_test_method_decode_input(writer, method_def)?;
            writer.write_line("");
            self.generate_test_method_encode_output(writer, method_def)?;
            writer.write_line("");
            self.generate_test_method_decode_output(writer, method_def)?;
            writer.write_line("");
        }
        Ok(())
    }

    /// Generates a test function that simulates the encoding of an agent method's parameters. The
    /// input coming from stdin is supposed to match the generated method's parameter signature, and
    /// it encodes the values into a DataValue to be passed to the invocation API.
    fn generate_test_method_encode_input(
        &self,
        writer: &mut TsWriter,
        method_def: &AgentMethod,
    ) -> anyhow::Result<()> {
        let method_name_pascal = method_def.name.to_upper_camel_case();
        let mut encode_input =
            writer.begin_export_async_function(&format!("encode{}Input", method_name_pascal));
        encode_input.result("void");
        encode_input.write_line("const __json = await readStdin();");
        if !method_def.input_schema.is_unit() {
            encode_input.write("const [");
            Self::write_parameter_name_list(&mut encode_input, &method_def.input_schema);
            encode_input.write_line("] = __json;");
        }
        encode_input.write_line("const __result: base.DataValue = ");
        self.write_encode_data_value(&mut encode_input, &method_def.input_schema)?;
        encode_input.write_line("console.log(JSON.stringify(__result));");
        Ok(())
    }

    /// Generates a test function that simulates the decoding of an agent method's parameters. The input
    /// coming from the stdin is an (untyped) DataValue, and it decodes it into the method's parameter
    /// signature.
    fn generate_test_method_decode_input(
        &self,
        writer: &mut TsWriter,
        method_def: &AgentMethod,
    ) -> anyhow::Result<()> {
        let method_name_pascal = method_def.name.to_upper_camel_case();
        let mut decode_input =
            writer.begin_export_async_function(&format!("decode{}Input", method_name_pascal));
        decode_input.result("void");
        decode_input.write_line("const __jsonResult = await readStdin();");
        decode_input.write_line("const result = { result: __jsonResult };");
        decode_input.write_line("const __decoded = (() => {");
        decode_input.indent();
        self.write_decode_data_value(&mut decode_input, &method_def.input_schema)?;
        decode_input.unindent();
        decode_input.write_line("})();");
        decode_input.write_line("console.log(JSON.stringify(__decoded));");
        Ok(())
    }

    /// Generates a test function that simulates the encoding of an agent method's return value. The
    /// input coming from stdin is supposed to match the generated method's return signature, and it
    /// encodes the values into a DataValue to be passed to the invocation API.
    fn generate_test_method_encode_output(
        &self,
        writer: &mut TsWriter,
        method_def: &AgentMethod,
    ) -> anyhow::Result<()> {
        let method_name_pascal = method_def.name.to_upper_camel_case();
        let mut encode_output =
            writer.begin_export_async_function(&format!("encode{}Output", method_name_pascal));
        encode_output.result("void");
        if method_def.output_schema.is_unit() {
            encode_output.write_line("console.log('void');");
        } else {
            encode_output.write_line("const __json = await readStdin();");
            if !method_def.output_schema.is_unit() {
                encode_output.write("const [");
                Self::write_parameter_name_list(&mut encode_output, &method_def.output_schema);
                encode_output.write_line("] = __json;");
            }
            encode_output.write_line("const __result: base.DataValue =");
            self.write_encode_data_value(&mut encode_output, &method_def.output_schema)?;
            encode_output.write_line("console.log(JSON.stringify(__result));");
        }
        Ok(())
    }

    /// Generates a test function that simulates the decoding of an agent method's return value. The
    /// input coming from the stdin is an (untyped) DataValue, and it decodes it into the method's return signature.
    fn generate_test_method_decode_output(
        &self,
        writer: &mut TsWriter,
        method_def: &AgentMethod,
    ) -> anyhow::Result<()> {
        let method_name_pascal = method_def.name.to_upper_camel_case();
        let mut decode_output =
            writer.begin_export_async_function(&format!("decode{}Output", method_name_pascal));
        decode_output.result("void");
        if method_def.output_schema.is_unit() {
            decode_output.write_line("console.log('void');");
        } else {
            decode_output.write_line("const __jsonResult = await readStdin();");
            decode_output.write_line("const result = { result: __jsonResult };");
            decode_output.write_line("const __decoded = (() => {");
            decode_output.indent();
            self.write_decode_data_value(&mut decode_output, &method_def.output_schema)?;
            decode_output.unindent();
            decode_output.write_line("})();");
            decode_output.write_line("console.log(JSON.stringify(__decoded));");
        }
        Ok(())
    }

    /// Generates a map of encode/decode pairs keyed by the method name
    fn generate_test_functions_map(&self, writer: &mut TsWriter) {
        // Create a map of available functions
        writer.write_line("const testFunctions: { [key: string]: () => Promise<void> | void } = {");
        writer.indent();
        for method_def in &self.agent_type.methods {
            let method_name_pascal = method_def.name.to_upper_camel_case();
            writer.write_line(format!("encode{}Input,", method_name_pascal));
            writer.write_line(format!("decode{}Input,", method_name_pascal));
            writer.write_line(format!("encode{}Output,", method_name_pascal));
            writer.write_line(format!("decode{}Output,", method_name_pascal));
        }
        writer.unindent();
        writer.write_line("};");
        writer.write_line("");
    }

    /// Generates the main function for the test module
    fn generate_test_main_handler(&self, writer: &mut TsWriter) -> anyhow::Result<()> {
        let mut main = writer.begin_export_async_function("main");
        main.result("void");

        self.generate_test_main_arg_validation(&mut main)?;
        self.generate_test_main_function_lookup(&mut main);
        self.generate_test_main_function_call(&mut main);

        Ok(())
    }

    /// Generates the command line argument validation part of the test module's main function
    fn generate_test_main_arg_validation(
        &self,
        main: &mut TsFunctionWriter<'_>,
    ) -> anyhow::Result<()> {
        main.write_line("const args = process.argv.slice(2);");
        main.write_line("if (args.length === 0) {");
        main.indent();
        main.write_line("console.error('Usage: npx tsx test.ts <function-name>');");
        main.write_line("console.error('Available functions:');");

        for method_def in &self.agent_type.methods {
            let method_name_pascal = method_def.name.to_upper_camel_case();
            main.write_line(format!(
                "console.error('  encode{}Input, decode{}Input, encode{}Output, decode{}Output');",
                method_name_pascal, method_name_pascal, method_name_pascal, method_name_pascal
            ));
        }

        main.write_line("process.exit(1);");
        main.unindent();
        main.write_line("}");

        Ok(())
    }

    /// Lookup an encode/decode function based on the provided function name
    fn generate_test_main_function_lookup(&self, main: &mut TsFunctionWriter<'_>) {
        main.write_line("const functionName = args[0];");
        main.write_line("const fn = testFunctions[functionName];");
        main.write_line("if (!fn) {");
        main.indent();
        main.write_line("console.error(`Unknown function: ${functionName}`);");
        main.write_line(
            "console.error('Available functions:', Object.keys(testFunctions).join(', '));",
        );
        main.write_line("process.exit(1);");
        main.unindent();
        main.write_line("}");
    }

    /// Call the encode/decode function based on the provided function name
    fn generate_test_main_function_call(&self, main: &mut TsFunctionWriter<'_>) {
        main.write_line("try {");
        main.indent();
        main.write_line("await fn();");
        main.unindent();
        main.write_line("} catch (error) {");
        main.indent();
        main.write_line("console.error('Error:', error);");
        main.write_line("process.exit(1);");
        main.unindent();
        main.write_line("}");
    }

    /// Entry point of the test module
    fn generate_test_entry_point(&self, writer: &mut TsWriter) {
        writer.write_line("");
        writer.write_line("main();");
    }

    /// Generates the client module
    fn generate_ts(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let mut writer = TsWriter::new();

        let config_var = self.global_config_var_name();

        self.generate_ts_imports(&mut writer);
        self.generate_ts_config_global(&mut writer, &config_var);
        self.generate_ts_type_definitions(&mut writer)?;
        self.generate_ts_class(&mut writer, &config_var)?;
        self.generate_ts_configure_function(&mut writer, &config_var);

        writer.finish(path)
    }

    /// Generates the import section of the client library
    fn generate_ts_imports(&self, writer: &mut TsWriter) {
        writer.import_item("v4", "uuidv4", "uuid");
        writer.import_module("base", "./base");
    }

    /// Generates the global variables of the client library.
    ///
    /// Configuration is stored in a global variable, set by the exported `configure` function,
    /// instead of being passed to the agent constructors. The primary reason for this is to
    /// make the agent constructors look exactly like they do in agent-to-agent communication,
    /// and to help the REPL use case by allowing pre-configuration of the client classes.
    fn generate_ts_config_global(&self, writer: &mut TsWriter, config_var: &str) {
        writer.declare_global(
            config_var,
            "base.Configuration | undefined",
            Some("undefined"),
        );
    }

    /// Generates a type definition and an encode/decode function pair for custom types used
    /// by the agent.
    fn generate_ts_type_definitions(&self, writer: &mut TsWriter) -> anyhow::Result<()> {
        for (typ, name) in self.type_naming.types() {
            self.generate_ts_wit_type_def(writer, name, typ)?;
            self.generate_ts_wit_type_encode(writer, name, typ)?;
            self.generate_ts_wit_type_decode(writer, name, typ)?;
        }
        Ok(())
    }

    /// Generates the agent client class
    fn generate_ts_class(&self, writer: &mut TsWriter, config_var: &str) -> anyhow::Result<()> {
        let class_name = &self.agent_type.type_name.0;

        writer.write_doc(&self.agent_type.description);
        writer.begin_export_class(class_name);

        self.generate_ts_class_fields(writer);
        self.generate_ts_class_constructor(writer);
        self.generate_ts_constructor_methods(writer, class_name)?;
        self.generate_ts_config_getter(writer, config_var);
        self.generate_ts_remote_methods(writer, class_name)?;

        writer.end_export_class();

        Ok(())
    }

    /// Generates fields of the agent client class.
    ///
    /// We store the encoded parameters and phantom ID of the targeted agent.
    fn generate_ts_class_fields(&self, writer: &mut TsWriter) {
        writer.declare_field("parameters", "base.DataValue", None);
        writer.declare_field("phantomId", "base.PhantomId | undefined", None);
    }

    /// Generates the private constructor of the agent class. The user-facing constructors
    /// are static methods matching the agent-to-agent API (get, getPhantom, newPhantom)
    fn generate_ts_class_constructor(&self, writer: &mut TsWriter) {
        let mut constructor = writer.begin_private_constructor();
        constructor.param("parameters", "base.DataValue");
        constructor.param("phantomId", "base.PhantomId | undefined");
        constructor.write_line("this.parameters = parameters;");
        constructor.write_line("this.phantomId = phantomId;");
    }

    /// Generates the static methods for constructing agent clients. For durable agents we
    /// generate `get`, and for any agent we also generate `getPhantom` and `newPhantom`.
    fn generate_ts_constructor_methods(
        &self,
        writer: &mut TsWriter,
        class_name: &str,
    ) -> anyhow::Result<()> {
        if self.agent_type.mode == AgentMode::Durable {
            self.generate_ts_constructor_get_method(writer, class_name)?;
        }

        self.generate_ts_constructor_get_phantom_method(writer, class_name)?;
        self.generate_ts_constructor_new_phantom_method(writer, class_name)?;

        Ok(())
    }

    /// Generates the `get` constructor method
    fn generate_ts_constructor_get_method(
        &self,
        writer: &mut TsWriter,
        class_name: &str,
    ) -> anyhow::Result<()> {
        writer.write_doc(&format!(
            "Gets or creates an instance of this agent\n{}",
            self.agent_type.constructor.description
        ));
        let mut get = writer.begin_static_method("get");
        self.write_parameter_list(&mut get, &self.agent_type.constructor.input_schema)?;
        get.result(class_name);

        get.write_line("const parameters: base.DataValue = ");
        self.write_encode_data_value(&mut get, &self.agent_type.constructor.input_schema)?;
        get.write_line("const phantomId = undefined;");
        get.write_line(format!("return new {class_name}(parameters, phantomId);"));

        Ok(())
    }

    /// Generates the `getPhantom` constructor method
    fn generate_ts_constructor_get_phantom_method(
        &self,
        writer: &mut TsWriter,
        class_name: &str,
    ) -> anyhow::Result<()> {
        writer.write_doc(&format!(
            "Gets or creates a phantom instance of this agent with a specific phantom ID\n{}",
            self.agent_type.constructor.description
        ));
        let mut get_phantom = writer.begin_static_method("getPhantom");
        get_phantom.param("phantomId", "base.PhantomId");
        self.write_parameter_list(&mut get_phantom, &self.agent_type.constructor.input_schema)?;
        get_phantom.result(class_name);

        get_phantom.write_line("const parameters: base.DataValue = ");
        self.write_encode_data_value(&mut get_phantom, &self.agent_type.constructor.input_schema)?;
        get_phantom.write_line(format!("return new {class_name}(parameters, phantomId);"));

        Ok(())
    }

    /// Generates the `newPhantom` constructor method
    fn generate_ts_constructor_new_phantom_method(
        &self,
        writer: &mut TsWriter,
        class_name: &str,
    ) -> anyhow::Result<()> {
        writer.write_doc(&format!(
            "Creates a new phantom instance of this agent\n{}",
            self.agent_type.constructor.description
        ));
        let mut new_phantom = writer.begin_static_method("newPhantom");
        self.write_parameter_list(&mut new_phantom, &self.agent_type.constructor.input_schema)?;
        new_phantom.result(class_name);

        new_phantom.write_line("const parameters: base.DataValue = ");
        self.write_encode_data_value(&mut new_phantom, &self.agent_type.constructor.input_schema)?;
        new_phantom.write_line("const phantomId = uuidv4();");
        new_phantom.write_line(format!("return new {class_name}(parameters, phantomId);"));

        Ok(())
    }

    /// Generates a private helper method for getting the global configuration and failing if it is missing
    fn generate_ts_config_getter(&self, writer: &mut TsWriter, config_var: &str) {
        let mut get_config = writer.begin_private_method("__getConfig");
        get_config.result("base.Configuration");
        get_config.write_line(format!("if (!{config_var}) {{"));
        get_config.indent();
        get_config.write_line(format!(
            "  throw new Error(\"{} configuration is not set\");",
            self.agent_type.type_name.0
        ));
        get_config.unindent();
        get_config.write_line("}");
        get_config.write_line(format!("return {};", config_var));
    }

    /// Generates the remote agent methods
    fn generate_ts_remote_methods(
        &self,
        writer: &mut TsWriter,
        _class_name: &str,
    ) -> anyhow::Result<()> {
        for method_def in &self.agent_type.methods {
            self.generate_ts_remote_method(writer, method_def)?;
        }
        Ok(())
    }

    /// Generates a specific remote agent method. Agent methods are exposed the same was as agent-to-agent communication,
    /// instead of a simple method, it is an object which is callable (in that case acting as an async 'invoke and await' call),
    /// but also expose a `trigger` and a `schedule` method.
    fn generate_ts_remote_method(
        &self,
        writer: &mut TsWriter,
        method_def: &AgentMethod,
    ) -> anyhow::Result<()> {
        let get_server_config_fn = self.build_get_server_config_fn();
        let get_around_invoke_hook_fn = self.build_get_around_invoke_hook_fn();
        let get_method_request_fn = self.build_get_method_request_fn(method_def);
        let encode_args_fn = self.build_encode_args_fn(method_def)?;
        let decode_result_fn = self.build_decode_result_fn(method_def)?;

        writer.write_doc(&method_def.description);
        writer.declare_field(
            &method_def.name.to_lower_camel_case(),
            &format!(
                "base.RemoteMethod<[{}], {}>",
                self.data_schema_as_type_list(&method_def.input_schema)?,
                self.data_schema_as_result_type(&method_def.output_schema)?
            ),
            Some(&formatdoc! {"
                base.createRemoteMethod(
                    {},
                    {},
                    {},
                    {},
                    {},
                )
            ",
                get_server_config_fn.trim(),
                get_around_invoke_hook_fn.trim(),
                get_method_request_fn.trim(),
                encode_args_fn.trim(),
                decode_result_fn.trim(),
            }),
        );

        Ok(())
    }

    /// Builds the function that extracts the configured server for the remote method implementation
    fn build_get_server_config_fn(&self) -> String {
        let mut get_server_config = TsAnonymousFunctionWriter::new();
        get_server_config.write_line("return this.__getConfig().server;");
        get_server_config.build()
    }

    /// Builds the function that extracts the configured around invoke hook for the remote method implementation
    fn build_get_around_invoke_hook_fn(&self) -> String {
        let mut get_server_config = TsAnonymousFunctionWriter::new();
        get_server_config.write_line("return this.__getConfig().aroundInvokeHook;");
        get_server_config.build()
    }

    /// Builds the function that constructs the base invocation request, with no method parameters set yet
    fn build_get_method_request_fn(&self, method_def: &AgentMethod) -> String {
        let mut get_method_request = TsAnonymousFunctionWriter::new();
        get_method_request.write_line("return {");
        get_method_request.indent();
        get_method_request.write_line("appName: this.__getConfig().application,");
        get_method_request.write_line("envName: this.__getConfig().environment,");
        get_method_request.write_line(format!(
            "agentTypeName: \"{}\",",
            self.agent_type.type_name.to_wit_naming().0
        ));
        get_method_request.write_line("parameters: this.parameters,");
        get_method_request.write_line("phantomId: this.phantomId,");
        get_method_request.write_line(format!("methodName: \"{}\",", method_def.name));
        get_method_request.write_line("mode: \"await\",");
        get_method_request.write_line("methodParameters: { type: \"Tuple\", elements: [] }");
        get_method_request.unindent();
        get_method_request.write_line("};");
        get_method_request.build()
    }

    /// Builds the function that takes the method's parameters and encodes them into a DataValue,
    /// to be injected into the invocation request
    fn build_encode_args_fn(&self, method_def: &AgentMethod) -> anyhow::Result<String> {
        let mut encode_args = TsAnonymousFunctionWriter::new();
        encode_args.param(
            "args",
            &format!(
                "[{}]",
                self.data_schema_as_type_list(&method_def.input_schema)?
            ),
        );
        Self::destructure_args_tuple(&mut encode_args, "args", &method_def.input_schema)?;
        encode_args.write_line("const methodParameters: base.DataValue = ");
        self.write_encode_data_value(&mut encode_args, &method_def.input_schema)?;
        encode_args.write_line("return methodParameters;");
        Ok(encode_args.build())
    }

    /// Builds the function that takes the invocation API's result DataValue and decodes it to
    /// the function's expected return type
    fn build_decode_result_fn(&self, method_def: &AgentMethod) -> anyhow::Result<String> {
        let mut decode_result = TsAnonymousFunctionWriter::new();
        decode_result.param("result", "base.AgentInvocationResult");
        self.write_decode_data_value(&mut decode_result, &method_def.output_schema)?;
        Ok(decode_result.build())
    }

    /// Generates the global function to set the client's configuration
    fn generate_ts_configure_function(&self, writer: &mut TsWriter, config_var: &str) {
        writer.write_doc("Sets the global configuration for this agent client");
        let mut configure = writer.begin_export_function("configure");
        configure.param("config", "base.Configuration");
        configure.write_line(format!("{} = config;", config_var));
    }

    /// Generates an encode function that takes a TypeScript value and encodes it in the
    /// JSON WitValue representation format expected by the invocation API
    fn generate_ts_wit_type_encode(
        &self,
        writer: &mut TsWriter,
        ts_name: &TypeScriptTypeName,
        typ: &AnalysedType,
    ) -> anyhow::Result<()> {
        let encode_fn_name = format!("encode{ts_name}");

        let mut func = writer.begin_function(&encode_fn_name);
        func.param("value", ts_name.as_str());
        func.result("unknown");

        // For the function body, we need to encode the actual structure, not delegate to itself
        // So we strip the name and encode the inner type directly
        let inner_typ = typ.clone().with_optional_name(None);

        self.write_encode_body(&mut func, "value", &inner_typ)?;

        Ok(())
    }

    /// Writes the body of the encode function (`generate_ts_wit_type_encode`)
    fn write_encode_body(
        &self,
        writer: &mut TsFunctionWriter<'_>,
        value: &str,
        typ: &AnalysedType,
    ) -> anyhow::Result<()> {
        match typ {
            AnalysedType::Record(_)
            | AnalysedType::Variant(_)
            | AnalysedType::Result(_)
            | AnalysedType::Flags(_) => {
                // For complex types, write multi-line encode logic
                self.write_encode_logic(writer, value, typ)?;
            }
            AnalysedType::Enum(_) => {
                // Enums are just returned as-is (they're already strings)
                writer.write_line(format!("return {};", value));
            }
            AnalysedType::Tuple(tuple) => {
                // For tuples, write readable array construction
                writer.write_line("return [");
                writer.indent();
                for (idx, item_type) in tuple.items.iter().enumerate() {
                    let item_encode =
                        self.encode_wit_value(&format!("{}[{}]", value, idx), item_type);
                    let comma = if idx < tuple.items.len() - 1 { "," } else { "" };
                    writer.write_line(format!("{}{}", item_encode, comma));
                }
                writer.unindent();
                writer.write_line("];");
            }
            _ => {
                // For simpler primitive types, just return the encoded value
                let encode_expr = self.encode_wit_value(value, typ);
                writer.write_line(format!("return {};", encode_expr));
            }
        }
        Ok(())
    }

    /// Writes the encoding logic for records, variants, result and flag types
    fn write_encode_logic(
        &self,
        writer: &mut TsFunctionWriter<'_>,
        value: &str,
        typ: &AnalysedType,
    ) -> anyhow::Result<()> {
        match typ {
            AnalysedType::Record(record) => {
                writer.write_line("return {");
                writer.indent();
                for (idx, field) in record.fields.iter().enumerate() {
                    let js_field_name = escape_js_ident(field.name.to_lower_camel_case());
                    let wit_field_name = &field.name;
                    let field_encode =
                        self.encode_wit_value(&format!("{}.{}", value, js_field_name), &field.typ);
                    let comma = if idx < record.fields.len() - 1 {
                        ","
                    } else {
                        ""
                    };
                    writer.write_line(format!("\"{}\": {}{}", wit_field_name, field_encode, comma));
                }
                writer.unindent();
                writer.write_line("};");
            }
            AnalysedType::Variant(variant) => {
                // Use nested ternary operators for conciseness, but split across lines
                writer.write_line("return (");
                writer.indent();
                for (idx, case) in variant.cases.iter().enumerate() {
                    let condition = format!("{}.tag === '{}'", value, case.name);
                    let value_expr = match &case.typ {
                        Some(case_type) => {
                            let encoded =
                                self.encode_wit_value(&format!("{}.val", value), case_type);
                            format!("{{ \"{}\": {} }}", case.name, encoded)
                        }
                        None => {
                            format!("{{ \"{}\": null }}", case.name)
                        }
                    };
                    let connector = if idx == 0 { "" } else { ":" };
                    if idx == variant.cases.len() - 1 {
                        writer.write_line(format!(
                            "{} {} ? {} : null",
                            connector, condition, value_expr
                        ));
                    } else {
                        writer.write_line(format!("{} {} ? {} ", connector, condition, value_expr));
                    }
                }
                writer.unindent();
                writer.write_line(");");
            }
            AnalysedType::Result(result) => {
                writer.write_line("return (");
                writer.indent();
                writer.write_line(format!("{}.ok !== undefined ?", value));
                writer.indent();
                let ok_expr = match &result.ok {
                    Some(ok_type) => {
                        let encoded = self.encode_wit_value(&format!("{}.ok", value), ok_type);
                        format!("{{ ok: {} }}", encoded)
                    }
                    None => "{ ok: undefined }".to_string(),
                };
                writer.write_line(format!("{} :", ok_expr));
                writer.unindent();
                let err_expr = match &result.err {
                    Some(err_type) => {
                        let encoded = self.encode_wit_value(&format!("{}.err", value), err_type);
                        format!("{{ err: {} }}", encoded)
                    }
                    None => "{ err: undefined }".to_string(),
                };
                writer.write_line(&err_expr);
                writer.unindent();
                writer.write_line(");");
            }
            AnalysedType::Flags(flags) => {
                writer.write_line("return [");
                writer.indent();
                for flag in &flags.names {
                    let flag_name = escape_js_ident(flag.to_lower_camel_case());
                    writer.write_line(format!(
                        "({}[\"{}\"] ? \"{}\" : undefined),",
                        value, flag_name, flag
                    ));
                }
                writer.unindent();
                writer.write_line("].filter((f) => f !== undefined);");
            }
            _ => {
                // This shouldn't be reached for complex types
                writer.write_line("throw new Error(\"Unsupported type in encode\");");
            }
        }
        Ok(())
    }

    /// Generates a decode function that takes a JSON WIT value representation and returns a TS
    /// type corresponding to the WIT type.
    fn generate_ts_wit_type_decode(
        &self,
        writer: &mut TsWriter,
        ts_name: &TypeScriptTypeName,
        typ: &AnalysedType,
    ) -> anyhow::Result<()> {
        let decode_fn_name = format!("decode{ts_name}");

        let mut func = writer.begin_function(&decode_fn_name);
        func.param("value", "unknown");
        func.result(ts_name.as_str());

        // For the function body, we need to decode the actual structure, not delegate to itself
        // So we strip the name and decode the inner type directly
        let inner_typ = typ.clone().with_optional_name(None);

        self.write_decode_body(&mut func, "value", &inner_typ)?;

        Ok(())
    }

    /// Writes the body of the decode function (`generate_ts_wit_type_decode`)
    fn write_decode_body(
        &self,
        writer: &mut TsFunctionWriter<'_>,
        value: &str,
        typ: &AnalysedType,
    ) -> anyhow::Result<()> {
        match typ {
            AnalysedType::Record(_)
            | AnalysedType::Variant(_)
            | AnalysedType::Result(_)
            | AnalysedType::Flags(_) => {
                // For complex types, write multi-line decode logic
                writer.write_line(format!("const obj = {} as any;", value));
                self.write_decode_logic(writer, typ)?;
            }
            AnalysedType::Enum(enum_type) => {
                // For enums, write a readable multi-line check
                writer.write_line(format!("if (typeof {} !== 'string') {{", value));
                writer.indent();
                writer.write_line(format!(
                    "throw new Error(`Expected string for enum, got ${{{}}})`);",
                    value
                ));
                writer.unindent();
                writer.write_line("}");
                let cases = enum_type
                    .cases
                    .iter()
                    .map(|case| format!("\"{}\"", case))
                    .collect::<Vec<_>>();
                writer.write_line(format!("const validCases = [{}];", cases.join(", ")));
                writer.write_line(format!("if (!validCases.includes({})) {{", value));
                writer.indent();
                writer.write_line(format!("throw new Error(`Invalid enum value ${{{}}}. Expected one of: ${{validCases.join(', ')}})`);", value));
                writer.unindent();
                writer.write_line("}");
                writer.write_line(format!("return {} as any;", value));
            }
            AnalysedType::Tuple(tuple) => {
                // For tuples, write readable validation
                writer.write_line(format!("if (!Array.isArray({})) {{", value));
                writer.indent();
                writer.write_line(format!(
                    "throw new Error(`Expected array for tuple, got ${{{}}}`);",
                    value
                ));
                writer.unindent();
                writer.write_line("}");
                writer.write_line(format!(
                    "if ({}.length !== {}) {{",
                    value,
                    tuple.items.len()
                ));
                writer.indent();
                writer.write_line(format!(
                    "throw new Error(`Expected tuple of length {}, got length ${{{}}}.length`);",
                    tuple.items.len(),
                    value
                ));
                writer.unindent();
                writer.write_line("}");
                writer.write_line("return [");
                writer.indent();
                for (idx, item_type) in tuple.items.iter().enumerate() {
                    let item_decode =
                        self.decode_wit_value(&format!("{}[{}]", value, idx), item_type);
                    let comma = if idx < tuple.items.len() - 1 { "," } else { "" };
                    writer.write_line(format!("{}{}", item_decode, comma));
                }
                writer.unindent();
                writer.write_line("] as any;");
            }
            _ => {
                // For simpler primitive types, just return the decoded value
                let decode_expr = self.decode_wit_value(value, typ);
                writer.write_line(format!("return {};", decode_expr));
            }
        }
        Ok(())
    }

    /// Writes the decoding logic for records, variants, result and flag types
    fn write_decode_logic(
        &self,
        writer: &mut TsFunctionWriter<'_>,
        typ: &AnalysedType,
    ) -> anyhow::Result<()> {
        match typ {
            AnalysedType::Record(record) => {
                writer.write_line("return {");
                writer.indent();
                for (idx, field) in record.fields.iter().enumerate() {
                    let js_field_name = escape_js_ident(field.name.to_lower_camel_case());
                    let wit_field_name = &field.name;
                    let field_decode =
                        self.decode_wit_value(&format!("obj[\"{}\"]", wit_field_name), &field.typ);
                    let comma = if idx < record.fields.len() - 1 {
                        ","
                    } else {
                        ""
                    };
                    writer.write_line(format!("{}: {}{}", js_field_name, field_decode, comma));
                }
                writer.unindent();
                writer.write_line("};");
            }
            AnalysedType::Variant(variant) => {
                for (idx, case) in variant.cases.iter().enumerate() {
                    let if_or_else = if idx == 0 { "if" } else { "else if" };
                    writer.write_line(format!("{}(\"{}\" in obj) {{", if_or_else, case.name));
                    writer.indent();
                    match &case.typ {
                        Some(case_type) => {
                            let value_decode = self
                                .decode_wit_value(&format!("obj[\"{}\"]", case.name), case_type);
                            writer.write_line(format!(
                                "return {{ tag: '{}', val: {} }};",
                                case.name, value_decode
                            ));
                        }
                        None => {
                            writer.write_line(format!("return {{ tag: '{}' }};", case.name));
                        }
                    }
                    writer.unindent();
                    writer.write_line("}");
                }
                writer.write_line("throw new Error(`Unknown variant case in ${obj}`);");
            }
            AnalysedType::Result(result) => {
                writer.write_line("if ('ok' in obj) {");
                writer.indent();
                let ok_value = match &result.ok {
                    Some(ok_type) => self.decode_wit_value("obj.ok", ok_type),
                    None => "undefined".to_string(),
                };
                writer.write_line(format!("return {{ ok: {} }};", ok_value));
                writer.unindent();
                writer.write_line("} else if ('err' in obj) {");
                writer.indent();
                let err_value = match &result.err {
                    Some(err_type) => self.decode_wit_value("obj.err", err_type),
                    None => "undefined".to_string(),
                };
                writer.write_line(format!("return {{ err: {} }};", err_value));
                writer.unindent();
                writer.write_line("} else {");
                writer.indent();
                writer.write_line(
                    "throw new Error(`Expected result object with 'ok' or 'err' key, got ${obj}`);",
                );
                writer.unindent();
                writer.write_line("}");
            }
            AnalysedType::Flags(flags) => {
                writer.write_line("if (!Array.isArray(obj)) {");
                writer.indent();
                writer.write_line("throw new Error(`Expected array of flag names, got ${obj}`);");
                writer.unindent();
                writer.write_line("}");
                writer.write_line("const result = {");
                writer.indent();
                for flag in &flags.names {
                    let flag_name = escape_js_ident(flag.to_lower_camel_case());
                    writer.write_line(format!("{}: false,", flag_name));
                }
                writer.unindent();
                writer.write_line("};");
                writer.write_line("for (const flag of obj) {");
                writer.indent();
                writer.write_line("if (typeof flag !== 'string') {");
                writer.indent();
                writer.write_line("throw new Error(`Expected string flag name, got ${flag}`);");
                writer.unindent();
                writer.write_line("}");
                let flag_names_str = flags
                    .names
                    .iter()
                    .map(|name| format!("'{}'", escape_js_ident(name.to_lower_camel_case())))
                    .collect::<Vec<_>>()
                    .join(", ");
                writer.write_line(format!("if (![{}].includes(flag)) {{", flag_names_str));
                writer.indent();
                writer.write_line("throw new Error(`Unknown flag name ${flag}`);");
                writer.unindent();
                writer.write_line("}");
                writer.write_line("result[flag as keyof typeof result] = true;");
                writer.unindent();
                writer.write_line("}");
                writer.write_line("return result;");
            }
            _ => {
                // This shouldn't be reached for complex types
                writer.write_line("throw new Error(\"Unsupported type in decode\");");
            }
        }
        Ok(())
    }

    /// Writes an exported type definition
    fn generate_ts_wit_type_def(
        &self,
        writer: &mut TsWriter,
        ts_name: &TypeScriptTypeName,
        typ: &AnalysedType,
    ) -> anyhow::Result<()> {
        let def = self.type_definition(typ)?;
        writer.export_type(ts_name, &def);
        Ok(())
    }

    /// Writes a return statement that decodes the JSON DataValue value in `result` to
    /// the expected TS representation
    fn write_decode_data_value<Result: FunctionWriter>(
        &self,
        writer: &mut Result,
        schema: &DataSchema,
    ) -> anyhow::Result<()> {
        match schema {
            DataSchema::Tuple(params) => {
                if params.elements.is_empty() {
                    // Expected unit result
                    writer.write_line("return;");
                    Ok(())
                } else if params.elements.len() == 1 {
                    let element_schema = &params.elements[0].schema;
                    match element_schema {
                        ElementSchema::ComponentModel(component_model) => {
                            writer.write_line("if (result.result && result.result.type === \"Tuple\" && result.result.elements.length === 1) {");
                            writer.indent();
                            writer.write_line(format!(
                                "return {};",
                                self.decode_wit_value(
                                    "result.result.elements[0].value",
                                    &component_model.element_type
                                )
                            ));
                            writer.unindent();
                            writer.write_line("} else {");
                            writer.indent();
                            writer.write_line("  throw new Error(`Invalid result value. Expected tuple DataValue of length 1, got ${JSON.stringify(result)}`);");
                            writer.unindent();
                            writer.write_line("}");
                            Ok(())
                        }
                        ElementSchema::UnstructuredText(descriptor) => {
                            writer.write_line("if (result.result && result.result.type === \"Tuple\" && result.result.elements.length === 1) {");
                            writer.indent();
                            writer.write_line(format!(
                                "return base.UnstructuredText.fromUntypedElementValue(\"result\", result.result.elements[0], [{}]);",
                                descriptor.restrictions.as_ref().map_or("".to_string(), |restrictions| {
                                    restrictions.iter().map(|tt| {
                                        format!("'{}'", tt.language_code)
                                    }).collect::<Vec<_>>().join(", ")
                                }
                                )));
                            writer.unindent();
                            writer.write_line("} else {");
                            writer.indent();
                            writer.write_line("  throw new Error(`Invalid result value. Expected tuple DataValue of length 1, got ${JSON.stringify(result)}`);");
                            writer.unindent();
                            writer.write_line("}");
                            Ok(())
                        }
                        ElementSchema::UnstructuredBinary(descriptor) => {
                            writer.write_line("if (result.result && result.result.type === \"Tuple\" && result.result.elements.length === 1) {");
                            writer.indent();
                            writer.write_line(format!(
                                "return base.UnstructuredBinary.fromUntypedElementValue(\"result\", result.result.elements[0], [{}]);",
                                descriptor.restrictions.as_ref().map_or("".to_string(), |restrictions| {
                                    restrictions.iter().map(|bt| {
                                        format!("'{}'", bt.mime_type)
                                    }).collect::<Vec<_>>().join(", ")
                                }
                                )));
                            writer.unindent();
                            writer.write_line("} else {");
                            writer.indent();
                            writer.write_line("  throw new Error(`Invalid result value. Expected tuple DataValue of length 1, got ${JSON.stringify(result)}`);");
                            writer.unindent();
                            writer.write_line("}");
                            Ok(())
                        }
                    }
                } else {
                    // Multiple result values - return as array
                    writer.write_line("if (result.result && result.result.type === \"Tuple\") {");
                    writer.indent();
                    writer.write_line(format!(
                        "if (result.result.elements.length !== {}) {{",
                        params.elements.len()
                    ));
                    writer.indent();
                    writer.write_line(format!("throw new Error(`Expected {} result elements, got ${{result.result.elements.length}}`);", params.elements.len()));
                    writer.unindent();
                    writer.write_line("}");
                    writer.write_line("return [");
                    writer.indent();
                    for (idx, param) in params.elements.iter().enumerate() {
                        let element_schema = &param.schema;
                        let decode_expr = match element_schema {
                            ElementSchema::ComponentModel(component_model) => self
                                .decode_wit_value(
                                    &format!("result.result.elements[{}].value", idx),
                                    &component_model.element_type,
                                ),
                            ElementSchema::UnstructuredText(descriptor) => {
                                format!(
                                    "base.UnstructuredText.fromUntypedElementValue(\"{}\", result.result.elements[{}], [{}])",
                                    param.name,
                                    idx,
                                    descriptor.restrictions.as_ref().map_or("".to_string(), |restrictions| {
                                        restrictions.iter().map(|tt| {
                                            format!("'{}'", tt.language_code)
                                        }).collect::<Vec<_>>().join(", ")
                                    })
                                )
                            }
                            ElementSchema::UnstructuredBinary(descriptor) => {
                                format!(
                                    "base.UnstructuredBinary.fromUntypedElementValue(\"{}\", result.result.elements[{}], [{}])",
                                    param.name,
                                    idx,
                                    descriptor.restrictions.as_ref().map_or("".to_string(), |restrictions| {
                                        restrictions.iter().map(|bt| {
                                            format!("'{}'", bt.mime_type)
                                        }).collect::<Vec<_>>().join(", ")
                                    })
                                )
                            }
                        };
                        let comma = if idx < params.elements.len() - 1 {
                            ","
                        } else {
                            ""
                        };
                        writer.write_line(format!("{}{}", decode_expr, comma));
                    }
                    writer.unindent();
                    writer.write_line("];");
                    writer.unindent();
                    writer.write_line("} else {");
                    writer.indent();
                    writer.write_line(format!(
                        "throw new Error(`Invalid result value. Expected tuple DataValue with {} elements, got ${{JSON.stringify(result)}}`);",
                        params.elements.len()
                    ));
                    writer.unindent();
                    writer.write_line("}");
                    Ok(())
                }
            }
            DataSchema::Multimodal(multimodal) => {
                writer.write_line("if (result.result && result.result.type === \"Multimodal\") {");
                writer.indent();
                writer.write_line("return result.result.elements.map((item: any) => {");
                writer.indent();

                // Generate union type handling code
                for (idx, element) in multimodal.elements.iter().enumerate() {
                    let if_or_else = if idx == 0 { "if" } else { "else if" };
                    writer.write_line(format!(
                        "{}(item.name === \"{}\") {{",
                        if_or_else, element.name
                    ));
                    writer.indent();
                    match &element.schema {
                        ElementSchema::ComponentModel(component_model) => {
                            let decoded = self.decode_wit_value(
                                "item.value.value",
                                &component_model.element_type,
                            );
                            writer.write_line(format!(
                                "return {{ type: '{}', value: {} }};",
                                element.name, decoded
                            ));
                        }
                        ElementSchema::UnstructuredText(descriptor) => {
                            writer.write_line(format!(
                                "return {{ type: '{}', value: base.UnstructuredText.fromUntypedElementValue('{}', item.value, [{}]) }};",
                                element.name,
                                element.name,
                                descriptor.restrictions.as_ref().map_or("".to_string(), |restrictions| {
                                    restrictions.iter().map(|tt| {
                                        format!("'{}'", tt.language_code)
                                    }).collect::<Vec<_>>().join(", ")
                                })
                            ));
                        }
                        ElementSchema::UnstructuredBinary(descriptor) => {
                            writer.write_line(format!(
                                "return {{ type: '{}', value: base.UnstructuredBinary.fromUntypedElementValue('{}', item.value, [{}]) }};",
                                element.name,
                                element.name,
                                descriptor.restrictions.as_ref().map_or("".to_string(), |restrictions| {
                                    restrictions.iter().map(|bt| {
                                        format!("'{}'", bt.mime_type)
                                    }).collect::<Vec<_>>().join(", ")
                                })
                            ));
                        }
                    }
                    writer.unindent();
                    writer.write_line("}");
                }

                writer.write_line("throw new Error(`Unknown multimodal variant: ${item.name}`);");
                writer.unindent();
                writer.write_line("});");

                writer.unindent();
                writer.write_line("} else {");
                writer.indent();
                writer.write_line("throw new Error(`Invalid result value. Expected multimodal DataValue, got ${JSON.stringify(result)}`);");
                writer.unindent();
                writer.write_line("}");
                Ok(())
            }
        }
    }

    /// Destructures the function arguments coming in `tuple` as a TypeScript tuple
    fn destructure_args_tuple<Target: FunctionWriter>(
        writer: &mut Target,
        tuple: &str,
        schema: &DataSchema,
    ) -> anyhow::Result<()> {
        match schema {
            DataSchema::Tuple(params) => {
                let param_names: Vec<String> = params
                    .elements
                    .iter()
                    .map(|param| escape_js_ident(param.name.to_lower_camel_case()))
                    .collect();
                writer.write_line(format!("const [{}] = {};", param_names.join(", "), tuple));
                Ok(())
            }
            DataSchema::Multimodal(_) => {
                // For multimodal input, extract the array from the args tuple
                writer.write_line(format!("const multimodalInput = {}[0];", tuple));
                Ok(())
            }
        }
    }

    /// Encodes function parameters in a single untyped DataValue
    fn write_encode_data_value<Target: FunctionWriter>(
        &self,
        writer: &mut Target,
        schema: &DataSchema,
    ) -> anyhow::Result<()> {
        match schema {
            DataSchema::Tuple(params) => {
                writer.indent();
                writer.write_line("{ type: \"Tuple\", elements: [");
                writer.indent();
                for param in &params.elements {
                    let param_name = escape_js_ident(param.name.to_lower_camel_case());
                    match &param.schema {
                        ElementSchema::ComponentModel(component_model) => {
                            writer.write_line(format!(
                                "{{ type: 'ComponentModel', value: {} }},",
                                self.encode_wit_value(&param_name, &component_model.element_type)
                            ));
                        }
                        ElementSchema::UnstructuredText(_) => {
                            writer.write_line(format!(
                                "{{ type: 'UnstructuredText', value: base.TextReference.fromUnstructuredText({param_name}) }},",
                            ))
                        }
                        ElementSchema::UnstructuredBinary(_) => {
                            writer.write_line(format!(
                                "{{ type: 'UnstructuredBinary', value: base.BinaryReference.fromUnstructuredBinary({param_name}) }},",
                            ))
                        }
                    }
                }

                writer.unindent();
                writer.write_line("]};");
                writer.unindent();
                Ok(())
            }
            DataSchema::Multimodal(multimodal) => {
                writer.indent();
                writer.write_line(
                    "{ type: \"Multimodal\", elements: multimodalInput.map((item: any) => {",
                );
                writer.indent();

                // Generate encoding for each multimodal variant
                for (idx, element) in multimodal.elements.iter().enumerate() {
                    let if_or_else = if idx == 0 { "if" } else { "else if" };
                    writer.write_line(format!(
                        "{}(item.type === '{}') {{",
                        if_or_else, element.name
                    ));
                    writer.indent();
                    writer.write_line("return {");
                    writer.indent();
                    writer.write_line(format!("name: '{}',", element.name));
                    writer.write_line("value: ");

                    match &element.schema {
                        ElementSchema::ComponentModel(component_model) => {
                            writer.write_line(format!(
                                "{{ type: 'ComponentModel', value: {} }}",
                                self.encode_wit_value("item.value", &component_model.element_type)
                            ));
                        }
                        ElementSchema::UnstructuredText(_) => {
                            writer.write_line("{ type: 'UnstructuredText', value: base.TextReference.fromUnstructuredText(item.value) }");
                        }
                        ElementSchema::UnstructuredBinary(_) => {
                            writer.write_line("{ type: 'UnstructuredBinary', value: base.BinaryReference.fromUnstructuredBinary(item.value) }");
                        }
                    }

                    writer.write_line("};");
                    writer.unindent();
                    writer.write_line("}");
                }

                writer.write_line("throw new Error(`Unknown multimodal type: ${item.type}`);");
                writer.unindent();
                writer.write_line("}) };");
                writer.unindent();
                Ok(())
            }
        }
    }

    fn decode_wit_value(&self, value: &str, typ: &AnalysedType) -> String {
        if let Some(name) = self.type_naming.type_name_for_type(typ) {
            format!("decode{}({})", name, value)
        } else {
            match typ {
                AnalysedType::Str(_) | AnalysedType::Chr(_) => {
                    format!("((v: unknown) => {{ if (typeof v === 'string') {{ return v; }} else {{ throw new Error(`Expected string, got ${{v}}`); }} }})({value})")
                }
                AnalysedType::F64(_)
                | AnalysedType::F32(_)
                | AnalysedType::U64(_)
                | AnalysedType::S64(_)
                | AnalysedType::U32(_)
                | AnalysedType::S32(_)
                | AnalysedType::U16(_)
                | AnalysedType::S16(_)
                | AnalysedType::U8(_)
                | AnalysedType::S8(_) => {
                    format!("((v: unknown) => {{ if (typeof v === 'number') {{ return v; }} else {{ throw new Error(`Expected number, got ${{v}}`); }} }})({value})")
                }
                AnalysedType::Bool(_) => {
                    format!("((v: unknown) => {{ if (typeof v === 'boolean') {{ return v; }} else {{ throw new Error(`Expected boolean, got ${{v}}`); }} }})({value})")
                }
                AnalysedType::Option(inner) => {
                    let inner_decode = self.decode_wit_value("item", &inner.inner);
                    format!("base.decodeOption({value}, (item) => {})", inner_decode)
                }
                AnalysedType::List(inner) => {
                    // Special handling for lists of u8 which are Uint8Array
                    if matches!(*inner.inner, AnalysedType::U8(_)) {
                        format!("((v: unknown) => {{ if (v instanceof Uint8Array) {{ return v; }} else if (Array.isArray(v)) {{ return new Uint8Array(v); }} else {{ throw new Error(`Expected Uint8Array or array, got ${{v}}`); }} }})({value})")
                    } else {
                        let inner_decode = self.decode_wit_value("item", &inner.inner);
                        format!("((v: unknown) => {{ if (!Array.isArray(v)) {{ throw new Error(`Expected array, got ${{v}}`); }} return v.map((item) => {}); }})({value})", inner_decode)
                    }
                }
                AnalysedType::Enum(enum_type) => {
                    // Enum: decoded as a string, validate it's a known case
                    let cases_array = enum_type
                        .cases
                        .iter()
                        .map(|case| format!("\"{}\"", case))
                        .collect::<Vec<_>>()
                        .join(", ");
                    let cases_union = enum_type
                        .cases
                        .iter()
                        .map(|case| format!("\"{}\"", case))
                        .collect::<Vec<_>>()
                        .join(" | ");
                    format!("((v: unknown) => {{ if (typeof v === 'string' && [{cases_array}].includes(v)) {{ return v as {cases_union}; }} else {{ throw new Error(`Expected one of [{cases_array}], got ${{v}}`); }} }})({value})")
                }
                AnalysedType::Flags(flags) => {
                    // Flags: decoded as an array of flag names, convert to boolean object
                    let flag_names = flags
                        .names
                        .iter()
                        .map(|name| {
                            let flag_name = escape_js_ident(name.to_lower_camel_case());
                            format!("'{}'", flag_name)
                        })
                        .collect::<Vec<_>>()
                        .join(", ");
                    let flag_initializers = flags
                        .names
                        .iter()
                        .map(|name| {
                            let flag_name = escape_js_ident(name.to_lower_camel_case());
                            format!("{flag_name}: false")
                        })
                        .collect::<Vec<_>>()
                        .join(", ");
                    format!(
                        "((v: unknown) => {{ if (!Array.isArray(v)) {{ throw new Error(`Expected array of flag names, got ${{v}}`); }} const result = {{ {flag_initializers} }}; for (const flag of v) {{ if (typeof flag !== 'string') {{ throw new Error(`Expected string flag name, got ${{flag}}`); }} if (![{flag_names}].includes(flag)) {{ throw new Error(`Unknown flag name ${{flag}}`); }} result[flag as keyof typeof result] = true; }} return result; }})({value})"
                    )
                }
                AnalysedType::Tuple(tuple) => {
                    // Tuple: decoded from an array
                    let items: Vec<String> = tuple
                        .items
                        .iter()
                        .enumerate()
                        .map(|(idx, item_type)| {
                            let item_decode =
                                self.decode_wit_value(&format!("v[{}]", idx), item_type);
                            item_decode
                        })
                        .collect();
                    format!(
                        "((v: unknown) => {{ if (!Array.isArray(v) || v.length !== {}) {{ throw new Error(`Expected array of length {}, got ${{v}}`); }} return [{}]; }})({value})",
                        tuple.items.len(),
                        tuple.items.len(),
                        items.join(", ")
                    )
                }
                AnalysedType::Record(record) => {
                    // Record: decoded from an object
                    let field_decoders: Vec<String> = record
                        .fields
                        .iter()
                        .map(|field| {
                            let js_field_name = escape_js_ident(field.name.to_lower_camel_case());
                            let wit_field_name = &field.name;
                            let field_decode = self.decode_wit_value(
                                &format!("(v as any)[\"{}\"]", wit_field_name),
                                &field.typ,
                            );
                            format!("{js_field_name}: {field_decode}")
                        })
                        .collect();
                    format!(
                        "((v: unknown) => {{ if (typeof v !== 'object' || v === null) {{ throw new Error(`Expected object, got ${{v}}`); }} return {{ {} }}; }})({value})",
                        field_decoders.join(", ")
                    )
                }
                AnalysedType::Variant(variant) => {
                    // Variant: decoded from an object with a single key (case name)
                    // Create a series of checks: if 'case1' in v { ... } else if 'case2' in v { ... }
                    let cases = variant
                        .cases
                        .iter()
                        .map(|case| match &case.typ {
                            Some(case_type) => {
                                let value_decode = self.decode_wit_value(
                                    &format!("(obj as any)[\"{}\"]", case.name),
                                    case_type,
                                );
                                format!(
                                    "if (\"{}\" in obj) {{ return {{ tag: '{}', val: {} }}; }}",
                                    case.name, case.name, value_decode
                                )
                            }
                            None => {
                                format!(
                                    "if (\"{}\" in obj) {{ return {{ tag: '{}' }}; }}",
                                    case.name, case.name
                                )
                            }
                        })
                        .collect::<Vec<_>>()
                        .join(" else ");
                    format!(
                        "((v: unknown) => {{ if (typeof v !== 'object' || v === null || Array.isArray(v)) {{ throw new Error(`Expected variant object, got ${{v}}`); }} const obj = v as Record<string, any>; {} else {{ throw new Error(`Unknown variant case in ${{v}}`); }} }})({value})",
                        cases
                    )
                }
                AnalysedType::Result(result) => {
                    // Result: decoded from an object with either 'ok' or 'err' key
                    let ok_expr = match &result.ok {
                        Some(ok_type) => {
                            let decoded = self.decode_wit_value("(obj as any).ok", ok_type);
                            format!("{{ ok: {} }}", decoded)
                        }
                        None => "{ ok: undefined }".to_string(),
                    };
                    let err_expr = match &result.err {
                        Some(err_type) => {
                            let decoded = self.decode_wit_value("(obj as any).err", err_type);
                            format!("{{ err: {} }}", decoded)
                        }
                        None => "{ err: undefined }".to_string(),
                    };
                    format!(
                        "((v: unknown) => {{ if (typeof v !== 'object' || v === null || Array.isArray(v)) {{ throw new Error(`Expected result object, got ${{v}}`); }} const obj = v as Record<string, any>; if ('ok' in obj) {{ return {}; }} else if ('err' in obj) {{ return {}; }} else {{ throw new Error(`Expected result object with 'ok' or 'err' key, got ${{v}}`); }} }})({value})",
                        ok_expr, err_expr
                    )
                }
                AnalysedType::Handle(_) => {
                    // Handles are not supported in decoding
                    "undefined".to_string()
                }
            }
        }
    }

    fn encode_wit_value(&self, value: &str, typ: &AnalysedType) -> String {
        if let Some(name) = self.type_naming.type_name_for_type(typ) {
            format!("encode{}({})", name, value)
        } else {
            match typ {
                AnalysedType::Str(_) => value.to_string(),
                AnalysedType::Chr(_) => value.to_string(),
                AnalysedType::F64(_) => value.to_string(),
                AnalysedType::F32(_) => value.to_string(),
                AnalysedType::U64(_) => value.to_string(),
                AnalysedType::S64(_) => value.to_string(),
                AnalysedType::U32(_) => value.to_string(),
                AnalysedType::S32(_) => value.to_string(),
                AnalysedType::U16(_) => value.to_string(),
                AnalysedType::S16(_) => value.to_string(),
                AnalysedType::U8(_) => value.to_string(),
                AnalysedType::S8(_) => value.to_string(),
                AnalysedType::Bool(_) => value.to_string(),
                AnalysedType::Option(inner) => {
                    let inner_encode = self.encode_wit_value("item", &inner.inner);
                    format!("base.encodeOption({value}, (item) => {})", inner_encode)
                }
                AnalysedType::List(inner) => {
                    let inner_encode = self.encode_wit_value("item", &inner.inner);
                    // For primitives, just return the value as-is since no transformation is needed
                    if inner_encode == "item" {
                        value.to_string()
                    } else {
                        format!("{}.map((item: any) => {})", value, inner_encode)
                    }
                }
                AnalysedType::Enum(_) => {
                    // Enum: encoded as a string
                    value.to_string()
                }
                AnalysedType::Flags(flags) => {
                    // Flags: encoded as an array of flag names that are true
                    let flag_names: Vec<String> = flags
                        .names
                        .iter()
                        .map(|name| {
                            let flag_name = escape_js_ident(name.to_lower_camel_case());
                            format!("({}[\"{}\"]) ? \"{}\" : undefined", value, flag_name, name)
                        })
                        .collect();
                    format!("[{}].filter((f) => f !== undefined)", flag_names.join(", "))
                }
                AnalysedType::Tuple(tuple) => {
                    // Tuple: encoded as an array
                    let items: Vec<String> = tuple
                        .items
                        .iter()
                        .enumerate()
                        .map(|(idx, item_type)| {
                            let item_encode =
                                self.encode_wit_value(&format!("{}[{}]", value, idx), item_type);
                            item_encode
                        })
                        .collect();
                    format!("[{}]", items.join(", "))
                }
                AnalysedType::Record(record) => {
                    // Record: encoded as an object
                    let fields: Vec<String> = record
                        .fields
                        .iter()
                        .map(|field| {
                            let js_field_name = escape_js_ident(field.name.to_lower_camel_case());
                            let field_encode = self.encode_wit_value(
                                &format!("{}.{}", value, js_field_name),
                                &field.typ,
                            );
                            format!("\"{}\": {}", field.name, field_encode)
                        })
                        .collect();
                    format!("{{ {} }}", fields.join(", "))
                }
                AnalysedType::Variant(variant) => {
                    // Variant: encoded as an object with a single key (case name)
                    // Generate nested ternary: case1 ? obj1 : (case2 ? obj2 : (case3 ? obj3 : null))
                    let cases: Vec<(String, String)> = variant
                        .cases
                        .iter()
                        .map(|case| {
                            let condition = format!("{}.tag === '{}'", value, case.name);
                            let value_expr = match &case.typ {
                                Some(case_type) => {
                                    let encoded =
                                        self.encode_wit_value(&format!("{}.val", value), case_type);
                                    format!("{{ \"{}\": {} }}", case.name, encoded)
                                }
                                None => {
                                    format!("{{ \"{}\": null }}", case.name)
                                }
                            };
                            (condition, value_expr)
                        })
                        .collect();

                    // Nest the ternary operators properly from right to left
                    if cases.is_empty() {
                        "null".to_string()
                    } else {
                        let mut result = "null".to_string();
                        for (cond, expr) in cases.iter().rev() {
                            result = format!("({} ? {} : {})", cond, expr, result);
                        }
                        result
                    }
                }
                AnalysedType::Result(result) => {
                    // Result: encoded as { ok: value } or { err: error }
                    // value has structure: { ok: T } | { err: E }
                    let ok_expr = match &result.ok {
                        Some(ok_type) => {
                            let encoded = self.encode_wit_value(&format!("{}.ok", value), ok_type);
                            format!("{{ ok: {} }}", encoded)
                        }
                        None => "{ ok: undefined }".to_string(),
                    };
                    let err_expr = match &result.err {
                        Some(err_type) => {
                            let encoded =
                                self.encode_wit_value(&format!("{}.err", value), err_type);
                            format!("{{ err: {} }}", encoded)
                        }
                        None => "{ err: undefined }".to_string(),
                    };
                    format!("({}.ok !== undefined ? {} : {})", value, ok_expr, err_expr)
                }
                AnalysedType::Handle(_) => {
                    // Handles are not supported in encoding
                    "undefined".to_string()
                }
            }
        }
    }

    fn unstructured_text_type(descriptor: &TextDescriptor) -> String {
        if let Some(restrictions) = &descriptor.restrictions {
            format!(
                "base.UnstructuredText<[{}]>",
                restrictions
                    .iter()
                    .map(|tt| { format!("'{}'", tt.language_code) })
                    .collect::<Vec<_>>()
                    .join(", ")
            )
        } else {
            "base.UnstructuredText".to_string()
        }
    }

    fn unstructured_binary_type(descriptor: &BinaryDescriptor) -> String {
        if let Some(restrictions) = &descriptor.restrictions {
            format!(
                "base.UnstructuredBinary<[{}]>",
                restrictions
                    .iter()
                    .map(|bt| { format!("'{}'", bt.mime_type) })
                    .collect::<Vec<_>>()
                    .join(", ")
            )
        } else {
            "base.UnstructuredBinary".to_string()
        }
    }

    fn data_schema_as_type_list(&self, schema: &DataSchema) -> anyhow::Result<String> {
        Ok(match schema {
            DataSchema::Tuple(params) => params
                .elements
                .iter()
                .map(|elem| self.named_element_schema_as_type(elem))
                .collect::<Result<Vec<_>, _>>()?
                .join(", "),
            DataSchema::Multimodal(multimodal) => {
                let union_types = multimodal
                    .elements
                    .iter()
                    .map(|elem| self.named_element_schema_as_type(elem))
                    .collect::<Result<Vec<_>, _>>()?
                    .join(" | ");
                format!("({})[]", union_types)
            }
        })
    }

    fn named_element_schema_as_type(&self, schema: &NamedElementSchema) -> anyhow::Result<String> {
        self.element_schema_as_type(&schema.schema)
    }

    fn named_element_schemas_as_type(
        &self,
        schemas: &NamedElementSchemas,
    ) -> anyhow::Result<String> {
        Ok(schemas
            .elements
            .iter()
            .map(|element| {
                Ok::<String, anyhow::Error>(format!(
                    "{{ type: '{}', value: {} }}",
                    element.name,
                    self.named_element_schema_as_type(element)?
                ))
            })
            .collect::<Result<Vec<_>, _>>()?
            .join(" | "))
    }

    fn element_schema_as_type(&self, schema: &ElementSchema) -> anyhow::Result<String> {
        Ok(match schema {
            ElementSchema::ComponentModel(component_model) => {
                self.type_reference(&component_model.element_type)?
            }
            ElementSchema::UnstructuredText(descriptor) => Self::unstructured_text_type(descriptor),
            ElementSchema::UnstructuredBinary(descriptor) => {
                Self::unstructured_binary_type(descriptor)
            }
        })
    }

    fn write_parameter_name_list(writer: &mut TsFunctionWriter<'_>, schema: &DataSchema) {
        match schema {
            DataSchema::Tuple(params) => {
                let param_names: Vec<String> = params
                    .elements
                    .iter()
                    .map(|param| escape_js_ident(param.name.to_lower_camel_case()))
                    .collect();
                writer.write(param_names.join(", "));
            }
            DataSchema::Multimodal(_) => {
                writer.write("multimodalInput");
            }
        }
    }

    fn write_parameter_list(
        &self,
        writer: &mut TsFunctionWriter<'_>,
        schema: &DataSchema,
    ) -> anyhow::Result<()> {
        match schema {
            DataSchema::Tuple(params) => {
                for param in &params.elements {
                    let param_name = escape_js_ident(param.name.to_lower_camel_case());
                    match &param.schema {
                        ElementSchema::ComponentModel(component_model) => writer.param(
                            &param_name,
                            &self.type_reference(&component_model.element_type)?,
                        ),
                        ElementSchema::UnstructuredText(descriptor) => {
                            writer.param(&param_name, &Self::unstructured_text_type(descriptor));
                        }
                        ElementSchema::UnstructuredBinary(descriptor) => {
                            writer.param(&param_name, &Self::unstructured_binary_type(descriptor));
                        }
                    }
                }
                Ok(())
            }
            DataSchema::Multimodal(multimodal) => {
                writer.param(
                    "multimodalInput",
                    &format!("({})[]", self.named_element_schemas_as_type(multimodal)?),
                );
                Ok(())
            }
        }
    }

    fn data_schema_as_result_type(&self, schema: &DataSchema) -> anyhow::Result<String> {
        Ok(match schema {
            DataSchema::Tuple(params) => {
                if params.elements.is_empty() {
                    "void".to_string()
                } else if params.elements.len() == 1 {
                    self.named_element_schema_as_type(&params.elements[0])?
                } else {
                    let types = params
                        .elements
                        .iter()
                        .map(|elem| self.named_element_schema_as_type(elem))
                        .collect::<Result<Vec<_>, _>>()?
                        .join(", ");
                    format!("[{}]", types)
                }
            }
            DataSchema::Multimodal(multimodal) => {
                format!("({})[]", self.named_element_schemas_as_type(multimodal)?)
            }
        })
    }

    fn type_reference(&self, typ: &AnalysedType) -> anyhow::Result<String> {
        match self.type_naming.type_name_for_type(typ) {
            Some(name) => Ok(name.to_string()),
            None => {
                match typ {
                    AnalysedType::Str(_) => Ok("string".to_string()),
                    AnalysedType::Chr(_) => Ok("string".to_string()),
                    AnalysedType::F64(_) => Ok("number".to_string()),
                    AnalysedType::F32(_) => Ok("number".to_string()),
                    AnalysedType::U64(_) => Ok("number".to_string()),
                    AnalysedType::S64(_) => Ok("number".to_string()),
                    AnalysedType::U32(_) => Ok("number".to_string()),
                    AnalysedType::S32(_) => Ok("number".to_string()),
                    AnalysedType::U16(_) => Ok("number".to_string()),
                    AnalysedType::S16(_) => Ok("number".to_string()),
                    AnalysedType::U8(_) => Ok("number".to_string()),
                    AnalysedType::S8(_) => Ok("number".to_string()),
                    AnalysedType::Bool(_) => Ok("boolean".to_string()),
                    AnalysedType::Option(inner) => {
                        let inner_ts_type = self.type_reference(&inner.inner)?;
                        Ok(format!("{} | undefined", inner_ts_type)) // TODO: use ? in parameter and field positions
                    }
                    AnalysedType::List(inner) => {
                        if matches!(&*inner.inner, AnalysedType::U8(_)) {
                            Ok("Uint8Array".to_string())
                        } else {
                            let inner_ts_type = self.type_reference(&inner.inner)?;
                            Ok(format!("{}[]", inner_ts_type))
                        }
                    }
                    AnalysedType::Tuple(inner) => {
                        let types: Vec<String> = inner
                            .items
                            .iter()
                            .map(|item| self.type_reference(item))
                            .collect::<Result<_, _>>()?;
                        Ok(format!("[{}]", types.join(", ")))
                    }
                    AnalysedType::Result(result) => {
                        let ok_type = result
                            .ok
                            .as_ref()
                            .map(|t| self.type_reference(t))
                            .transpose()?
                            .unwrap_or("void".to_string());
                        let err_type = result
                            .err
                            .as_ref()
                            .map(|t| self.type_reference(t))
                            .transpose()?
                            .unwrap_or("void".to_string());
                        Ok(format!("base.JsonResult<{ok_type}, {err_type}>"))
                    }
                    AnalysedType::Handle(_) => Err(anyhow!("Handle types are not supported")),
                    _ => match typ.name() {
                        Some(name) => Ok(name.to_upper_camel_case()), // TODO: use owner too?
                        None => self.type_definition(typ),
                    },
                }
            }
        }
    }

    fn type_definition(&self, typ: &AnalysedType) -> anyhow::Result<String> {
        match typ {
            AnalysedType::Variant(variant) => {
                let mut case_defs = Vec::new();
                for case in &variant.cases {
                    let case_name = &case.name;
                    match &case.typ {
                        Some(ty) => {
                            let case_type = self.type_reference(ty)?;
                            case_defs
                                .push(format!("{{\n  tag: '{case_name}'\n  val: {case_type}\n}}"));
                        }
                        None => {
                            // No type means it's a unit variant
                            case_defs.push(format!("{{\n  tag: '{case_name}'\n}}"));
                        }
                    }
                }
                let cases = format!("\n{}", case_defs.join(" |\n"));
                Ok(cases)
            }
            AnalysedType::Result(result) => {
                let ok_type = result
                    .ok
                    .as_ref()
                    .map(|t| self.type_reference(t))
                    .transpose()?
                    .unwrap_or("void".to_string());
                let err_type = result
                    .err
                    .as_ref()
                    .map(|t| self.type_reference(t))
                    .transpose()?
                    .unwrap_or("void".to_string());
                Ok(format!("base.JsonResult<{ok_type}, {err_type}>")) // TODO: convert to a more convenient result type
            }
            AnalysedType::Option(option) => {
                let inner_ts_type = self.type_reference(&option.inner)?;
                Ok(format!("{} | undefined", inner_ts_type))
            }
            AnalysedType::Enum(r#enum) => {
                let cases = r#enum
                    .cases
                    .iter()
                    .map(|case| format!("\"{}\"", case))
                    .collect::<Vec<_>>();
                Ok(cases.join(" | "))
            }
            AnalysedType::Flags(flags) => {
                let mut flags_def = String::new();
                flags_def.push_str("{\n");
                for flag in &flags.names {
                    let flag_name = escape_js_ident(flag.to_lower_camel_case());
                    flags_def.push_str(&format!("  {flag_name}: boolean;\n"));
                }
                flags_def.push('}');
                Ok(flags_def)
            }
            AnalysedType::Record(record) => {
                let mut record_def = String::new();
                record_def.push_str("{\n");
                for field in &record.fields {
                    let js_name = escape_js_ident(field.name.to_lower_camel_case());
                    let field_str = if let AnalysedType::Option(option) = &field.typ {
                        let field_type = self.type_reference(&option.inner)?;
                        format!("{js_name}?: {field_type};\n")
                    } else {
                        let field_type = self.type_reference(&field.typ)?;
                        format!("{js_name}: {field_type};\n")
                    };
                    let indented = indent(&field_str, 2);
                    record_def.push_str(&indented);
                }
                record_def.push('}');
                Ok(record_def)
            }
            AnalysedType::Tuple(tuple) => {
                let types: Vec<String> = tuple
                    .items
                    .iter()
                    .map(|item| self.type_reference(item))
                    .collect::<Result<_, _>>()?;
                Ok(format!("[{}]", types.join(", ")))
            }
            AnalysedType::List(list) => {
                if matches!(*list.inner, AnalysedType::U8(_)) {
                    Ok("Uint8Array".to_string())
                } else {
                    let inner_type = self.type_reference(&list.inner)?;
                    Ok(format!("{}[]", inner_type))
                }
            }
            AnalysedType::Str(_) => Ok("string".to_string()),
            AnalysedType::Chr(_) => Ok("string".to_string()),
            AnalysedType::F64(_) => Ok("number".to_string()),
            AnalysedType::F32(_) => Ok("number".to_string()),
            AnalysedType::U64(_) => Ok("number".to_string()),
            AnalysedType::S64(_) => Ok("number".to_string()),
            AnalysedType::U32(_) => Ok("number".to_string()),
            AnalysedType::S32(_) => Ok("number".to_string()),
            AnalysedType::U16(_) => Ok("number".to_string()),
            AnalysedType::S16(_) => Ok("number".to_string()),
            AnalysedType::U8(_) => Ok("number".to_string()),
            AnalysedType::S8(_) => Ok("number".to_string()),
            AnalysedType::Bool(_) => Ok("boolean".to_string()),
            AnalysedType::Handle(_) => Err(anyhow!("Handle types are not supported")),
        }
    }

    fn library_name(&self) -> String {
        bridge_client_directory_name(&self.agent_type.type_name)
    }

    fn global_config_var_name(&self) -> String {
        format!(
            "{}Configuration",
            self.agent_type.type_name.0.to_lower_camel_case()
        )
    }
}

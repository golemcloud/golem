// Copyright 2024-2025 Golem Cloud
//
// Licensed under the Golem Source License v1.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://license.golem.cloud/LICENSE
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::bridge_gen::rust::rust::to_rust_ident;
use crate::bridge_gen::BridgeGenerator;
use anyhow::anyhow;
use camino::{Utf8Path, Utf8PathBuf};
use golem_common::model::agent::{
    AgentMethod, AgentType, BinaryType, DataSchema, ElementSchema, NamedElementSchemas, TextType,
};
use golem_wasm::analysis::AnalysedType;
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::{Ident, Span, TokenStream};
use quote::quote;
use std::collections::{BTreeMap, HashMap};
use syn::{Lit, LitStr};
use toml_edit::{value, Array, DocumentMut, Item, Table};

mod rust;
#[cfg(test)]
mod tests;

#[allow(dead_code)]
pub struct RustBridgeGenerator {
    target_path: Utf8PathBuf,
    agent_type: AgentType,
    testing: bool,

    generated_language_enums: BTreeMap<Vec<TextType>, String>,
    generated_mimetypes_enums: BTreeMap<Vec<BinaryType>, String>,
    known_types: HashMap<AnalysedType, RustType>,
    known_multimodals: HashMap<NamedElementSchemas, String>,
}

// TODO: convert panics to error results
impl BridgeGenerator for RustBridgeGenerator {
    fn new(agent_type: AgentType, target_path: &Utf8Path, testing: bool) -> Self {
        Self {
            target_path: target_path.to_path_buf(),
            agent_type,
            testing,

            generated_language_enums: BTreeMap::new(),
            generated_mimetypes_enums: BTreeMap::new(),
            known_types: HashMap::new(),
            known_multimodals: HashMap::new(),
        }
    }

    fn generate(&mut self) -> anyhow::Result<()> {
        let cargo_toml_path = self.target_path.join("Cargo.toml");
        let lib_rs_path = self.target_path.join("src/lib.rs");

        if !self.target_path.exists() {
            std::fs::create_dir_all(&self.target_path)?;
        }

        let src_dir = self.target_path.join("src");
        if !src_dir.exists() {
            std::fs::create_dir_all(&src_dir)?;
        }

        self.generate_cargo_toml(&cargo_toml_path)?;
        self.generate_lib_rs(&lib_rs_path)?;

        Ok(())
    }
}

impl RustBridgeGenerator {
    /// Generates the Cargo.toml manifest file
    fn generate_cargo_toml(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let package_name = self.package_name();

        let mut doc = DocumentMut::new();

        // Set up [package] section
        doc["package"] = Item::Table(Default::default());
        doc["package"]["name"] = value(package_name);
        doc["package"]["version"] = value("0.0.1");
        doc["package"]["edition"] = value("2021");
        doc["package"]["description"] = value("Generated by golem-cli");

        fn add_features(entry: &mut Item, features: &[&str]) {
            if !features.is_empty() {
                let mut feature_items = Array::default();
                for feature in features {
                    feature_items.push(*feature);
                }
                entry["default-features"] = value(false);
                entry["features"] = value(feature_items);
            }
        }

        fn dep(version: &str, features: &[&str]) -> Item {
            let mut entry = Item::Table(Table::default());
            entry["version"] = value(version);
            add_features(&mut entry, features);
            entry
        }

        fn git_dep(url: &str, branch: &str, features: &[&str]) -> Item {
            let mut entry = Item::Table(Table::default());
            entry["git"] = value(url);
            entry["branch"] = value(branch);
            add_features(&mut entry, features);
            entry
        }

        doc["dependencies"] = Item::Table(Table::default());
        doc["dependencies"]["chrono"] = dep("0.4", &[]);
        doc["dependencies"]["golem-client"] =
            git_dep("https://github.com/golemcloud/golem", "rust-bridge", &[]); // TODO: use published version when available
        doc["dependencies"]["golem-common"] = git_dep(
            "https://github.com/golemcloud/golem",
            "rust-bridge",
            &["client"],
        ); // TODO: use published version when available
        doc["dependencies"]["golem-wasm"] = git_dep(
            "https://github.com/golemcloud/golem",
            "rust-bridge",
            &["client"],
        ); // TODO: use published version when available
        doc["dependencies"]["nonempty-collections"] = dep("0.3.1", &[]);
        doc["dependencies"]["reqwest"] = dep("0.12", &["default-tls"]);
        doc["dependencies"]["uuid"] = dep("1.18.1", &["v4"]);

        std::fs::write(path, doc.to_string())
            .map_err(|e| anyhow!("Failed to write Cargo.toml file: {e}"))?;

        Ok(())
    }

    /// Generates the lib.rs source file
    fn generate_lib_rs(&mut self, path: &Utf8Path) -> anyhow::Result<()> {
        let tokens = self.generate_lib_rs_tokens()?;

        println!("{}", tokens);
        let formatted = prettyplease::unparse(&syn::parse2(tokens)?);

        std::fs::write(path, formatted).map_err(|e| anyhow!("Failed to write lib.rs file: {e}"))?;

        Ok(())
    }

    /// Generates the TokenStream for lib.rs content
    fn generate_lib_rs_tokens(&mut self) -> anyhow::Result<TokenStream> {
        let agent_type_name = &self.agent_type.type_name.0;
        let agent_type_name_lit = Lit::Str(LitStr::new(agent_type_name, Span::call_site()));
        let client_struct_name =
            Ident::new(&agent_type_name.to_upper_camel_case(), Span::call_site());

        self.collect_named_types();

        let input_schema = self.agent_type.constructor.input_schema.clone();
        let constructor_params = self.parameter_list(&input_schema);

        let typed_constructor_parameters_ident =
            Ident::new("typed_constructor_parameters", Span::call_site());
        let constructor_params_to_data_value = self.encode_as_data_value(
            &typed_constructor_parameters_ident,
            &self.agent_type.constructor.input_schema,
        );

        let methods = self
            .agent_type
            .methods
            .clone()
            .iter()
            .flat_map(|method| self.methods(method))
            .collect::<Vec<_>>();

        let global_config = self.global_config();

        let types = self.type_definitions();
        let multimodals = self.multimodals();
        let languages = self.languages_module();
        let mimetypes = self.mimetypes_module();

        let multimodal_import = if self.known_multimodals.is_empty() {
            quote! {}
        } else {
            quote! { use crate::multimodal::MultimodalEnum; }
        };

        let tokens = quote! {
            #![allow(unused)]

            use golem_common::base_model::agent::{UnstructuredBinaryExtensions, UnstructuredTextExtensions};
            use golem_wasm::{FromValueAndType, IntoValueAndType};
            #multimodal_import

            pub struct #client_struct_name {
                constructor_parameters: golem_client::model::UntypedJsonDataValue,
                phantom_id: Option<uuid::Uuid>,
            }

            impl #client_struct_name {
                pub fn get(#(#constructor_params),*) -> Self {
                    #constructor_params_to_data_value
                    let constructor_parameters: golem_common::model::agent::UntypedJsonDataValue =
                        typed_constructor_parameters.into();
                    Self { constructor_parameters, phantom_id: None }
                }

                pub fn get_phantom(uuid: uuid::Uuid, #(#constructor_params),*) -> Self {
                    #constructor_params_to_data_value
                    let constructor_parameters: golem_common::model::agent::UntypedJsonDataValue =
                        typed_constructor_parameters.into();
                    Self { constructor_parameters, phantom_id: Some(uuid) }
                }

                pub fn new_phantom(#(#constructor_params),*) -> Self {
                    #constructor_params_to_data_value
                    let constructor_parameters: golem_common::model::agent::UntypedJsonDataValue =
                        typed_constructor_parameters.into();
                    Self { constructor_parameters, phantom_id: Some(uuid::Uuid::new_v4()) }
                }

                #(#methods)*

                async fn invoke(
                    &self,
                    method_name: &str,
                    method_parameters: golem_client::model::UntypedJsonDataValue,
                    mode: golem_client::model::AgentInvocationMode,
                    schedule_at: Option<chrono::DateTime<chrono::Utc>>,
                ) -> Result<Option<golem_client::model::UntypedJsonDataValue>, golem_client::bridge::ClientError> {
                    let config = CONFIG.get().expect("Configuration has not been set");

                    let client = reqwest::Client::builder().build().unwrap();
                    let context = golem_client::Context {
                        client,
                        base_url: config.server.url(),
                        security_token: config.server.token(),
                    };
                    let client = golem_client::api::AgentClientLive { context };
                    let response = golem_client::api::AgentClient::invoke_agent(
                        &client,
                        None,
                        &golem_client::model::AgentInvocationRequest {
                            app_name: config.app_name.to_string(),
                            env_name: config.env_name.to_string(),
                            agent_type_name: #agent_type_name_lit.to_string(),
                            parameters: self.constructor_parameters.clone(),
                            phantom_id: self.phantom_id.clone(),
                            method_name: method_name.to_string(),
                            method_parameters,
                            mode,
                            schedule_at,
                            idempotency_key: None,
                        },
                    )
                    .await?;
                    Ok(response.result)
                }
            }

            #global_config

            #types

            #multimodals

            #languages

            #mimetypes
        };

        Ok(tokens)
    }

    fn get_or_create_multimodal(&mut self, elements: &NamedElementSchemas) -> String {
        let cnt = self.known_multimodals.len() + 1;
        self.known_multimodals
            .entry(elements.clone())
            .or_insert_with(|| format!("Multimodal{}", cnt))
            .clone()
    }

    fn parameter_list(&mut self, data_schema: &DataSchema) -> Vec<TokenStream> {
        // each item is 'name: type'

        match data_schema {
            DataSchema::Tuple(elements) => {
                let mut result = Vec::new();
                for element in &elements.elements {
                    let name = Ident::new(&to_rust_ident(&element.name), Span::call_site());
                    let typ = self.element_schema_to_typeref(&element.schema);
                    result.push(quote! {#name: #typ});
                }
                result
            }
            DataSchema::Multimodal(elements) => {
                let name = self.get_or_create_multimodal(elements);
                let name = Ident::new(&name, Span::call_site());
                vec![quote! { values: crate::multimodal::Multimodal<crate::multimodal::#name> }]
            }
        }
    }

    fn parameter_refs(&mut self, data_schema: &DataSchema) -> Vec<TokenStream> {
        // each item is 'name: type'

        match data_schema {
            DataSchema::Tuple(elements) => {
                let mut result = Vec::new();
                for element in &elements.elements {
                    let name = Ident::new(&to_rust_ident(&element.name), Span::call_site());
                    result.push(quote! {#name});
                }
                result
            }
            DataSchema::Multimodal(_elements) => {
                vec![quote! { values }]
            }
        }
    }

    fn get_languages_enum(&mut self, restrictions: &[TextType]) -> TokenStream {
        let restrictions = restrictions.to_vec();
        if let Some(existing) = self.generated_language_enums.get(&restrictions) {
            let ident = Ident::new(existing, Span::call_site());
            quote! { crate::languages::#ident }
        } else {
            let counter = self.generated_language_enums.len();
            let ident = Ident::new(&format!("Languages{}", counter), Span::call_site());
            self.generated_language_enums
                .insert(restrictions.clone(), ident.to_string());
            quote! { crate::languages::#ident }
        }
    }

    fn get_mimetypes_enum(&mut self, restrictions: &[BinaryType]) -> TokenStream {
        let restrictions = restrictions.to_vec();
        if let Some(existing) = self.generated_mimetypes_enums.get(&restrictions) {
            let ident = Ident::new(existing, Span::call_site());
            quote! { crate::mimetypes::#ident }
        } else {
            let counter = self.generated_mimetypes_enums.len();
            let ident = Ident::new(&format!("Mimetypes{}", counter), Span::call_site());
            self.generated_mimetypes_enums
                .insert(restrictions.clone(), ident.to_string());
            quote! { crate::mimetypes::#ident }
        }
    }

    fn element_schema_to_typeref(&mut self, element_schema: &ElementSchema) -> TokenStream {
        match element_schema {
            ElementSchema::ComponentModel(schema) => self.wit_type_to_typeref(&schema.element_type),
            ElementSchema::UnstructuredText(descriptor) => {
                if let Some(restrictions) = &descriptor.restrictions {
                    let languages_enum = self.get_languages_enum(restrictions);
                    quote! { golem_wasm::agentic::unstructured_text::UnstructuredText<#languages_enum> }
                } else {
                    quote! { golem_wasm::agentic::unstructured_text::UnstructuredText }
                }
            }
            ElementSchema::UnstructuredBinary(descriptor) => {
                if let Some(restrictions) = &descriptor.restrictions {
                    let mimetypes_enum = self.get_mimetypes_enum(restrictions);
                    quote! { golem_wasm::agentic::unstructured_binary::UnstructuredBinary<#mimetypes_enum> }
                } else {
                    quote! { golem_wasm::agentic::unstructured_binary::UnstructuredBinary<String> }
                }
            }
        }
    }

    fn wit_type_to_typedef(&mut self, typ: &AnalysedType) -> TokenStream {
        if let Some(type_name) = typ.name() {
            let name = Ident::new(&type_name, Span::call_site());
            match typ {
                AnalysedType::Variant(variant) => {
                    let mut cases = Vec::new();
                    let mut into_value_cases = Vec::new();
                    let mut from_value_cases = Vec::new();
                    let mut case_names_lit = Vec::new();

                    for (idx, case) in variant.cases.iter().enumerate() {
                        let case_ident = Ident::new(
                            &to_rust_ident(&case.name).to_upper_camel_case(),
                            Span::call_site(),
                        );
                        let idx_u32 = idx as u32;
                        case_names_lit.push(case.name.clone());

                        match &case.typ {
                            Some(typ) => {
                                // TODO: auto-inline anonymous records

                                let inner = self.wit_type_to_typeref(typ);
                                cases.push(quote! { #case_ident(#inner) });

                                // IntoValue implementation
                                into_value_cases.push(quote! {
                                    Self::#case_ident(value) => golem_wasm::Value::Variant {
                                        case_idx: #idx_u32,
                                        case_value: Some(Box::new(value.into_value())),
                                    }
                                });

                                // FromValue implementation
                                from_value_cases.push(quote! {
                                    #idx_u32 => {
                                        let inner_value = case_value.ok_or_else(|| format!("Expected case_value for {}", stringify!(#case_ident)))?;
                                        Ok(Self::#case_ident(<#inner as golem_wasm::FromValue>::from_value(*inner_value)?))
                                    }
                                });
                            }
                            None => {
                                cases.push(quote! { #case_ident });

                                // IntoValue implementation
                                into_value_cases.push(quote! {
                                    Self::#case_ident => golem_wasm::Value::Variant {
                                        case_idx: #idx_u32,
                                        case_value: None,
                                    }
                                });

                                // FromValue implementation
                                from_value_cases.push(quote! {
                                    #idx_u32 => Ok(Self::#case_ident)
                                });
                            }
                        }
                    }

                    quote! {
                        #[derive(Debug, Clone)]
                        pub enum #name {
                            #(#cases),*
                        }

                        impl golem_wasm::IntoValue for #name {
                            fn into_value(self) -> golem_wasm::Value {
                                match self {
                                    #(#into_value_cases),*
                                }
                            }

                            fn get_type() -> golem_wasm::analysis::AnalysedType {
                                golem_wasm::analysis::AnalysedType::Variant(golem_wasm::analysis::TypeVariant {
                                    name: Some(stringify!(#name).to_string()),
                                    owner: None,
                                    cases: vec![
                                        #(
                                            golem_wasm::analysis::NameOptionTypePair {
                                                name: #case_names_lit.to_string(),
                                                typ: None,
                                            }
                                        ),*
                                    ],
                                })
                            }
                        }

                        impl golem_wasm::FromValue for #name {
                            fn from_value(value: golem_wasm::Value) -> Result<Self, String> {
                                match value {
                                    golem_wasm::Value::Variant { case_idx, case_value } => {
                                        match case_idx {
                                            #(#from_value_cases,)*
                                            _ => Err(format!("Invalid variant case index: {}", case_idx)),
                                        }
                                    }
                                    _ => Err(format!("Expected Variant value, got {:?}", value)),
                                }
                            }
                        }
                    }
                }
                AnalysedType::Result(result) => {
                    let ok = result
                        .ok
                        .as_ref()
                        .map(|ok| self.wit_type_to_typeref(ok))
                        .unwrap_or_else(|| quote! { () });
                    let err = result
                        .err
                        .as_ref()
                        .map(|err| self.wit_type_to_typeref(err))
                        .unwrap_or_else(|| quote! { () });
                    quote! { pub type #name = Result<#ok, #err> }
                }
                AnalysedType::Option(option) => {
                    let inner = self.wit_type_to_typeref(&*option.inner);
                    quote! { pub type #name = Option<#inner>; }
                }
                AnalysedType::Enum(r#enum) => {
                    let mut cases = Vec::new();
                    let mut into_value_cases = Vec::new();
                    let mut from_value_cases = Vec::new();
                    let mut case_names_lit = Vec::new();

                    for (idx, case) in r#enum.cases.iter().enumerate() {
                        let case_ident = Ident::new(
                            &to_rust_ident(&case).to_upper_camel_case(),
                            Span::call_site(),
                        );
                        cases.push(quote! { #case_ident });
                        case_names_lit.push(case.clone());

                        // IntoValue implementation
                        into_value_cases.push(quote! {
                            Self::#case_ident => golem_wasm::Value::Enum(#idx as u32)
                        });

                        // FromValue implementation
                        let idx_u32 = idx as u32;
                        from_value_cases.push(quote! {
                            #idx_u32 => Ok(Self::#case_ident)
                        });
                    }

                    quote! {
                        #[derive(Debug, Clone)]
                        pub enum #name {
                            #(#cases),*
                        }

                        impl golem_wasm::IntoValue for #name {
                            fn into_value(self) -> golem_wasm::Value {
                                match self {
                                    #(#into_value_cases),*
                                }
                            }

                            fn get_type() -> golem_wasm::analysis::AnalysedType {
                                golem_wasm::analysis::AnalysedType::Enum(golem_wasm::analysis::TypeEnum {
                                    cases: vec![#(#case_names_lit.to_string()),*],
                                    name: Some(stringify!(#name).to_string()),
                                    owner: None,
                                })
                            }
                        }

                        impl golem_wasm::FromValue for #name {
                            fn from_value(value: golem_wasm::Value) -> Result<Self, String> {
                                match value {
                                    golem_wasm::Value::Enum(idx) => {
                                        match idx {
                                            #(#from_value_cases,)*
                                            _ => Err(format!("Invalid enum index: {}", idx)),
                                        }
                                    }
                                    _ => Err(format!("Expected Enum value, got {:?}", value)),
                                }
                            }
                        }
                    }
                }
                AnalysedType::Flags(_flags) => {
                    panic!("Flags are not supported") // NOTE: none of the code-first SDKs support flags at the moment
                }
                AnalysedType::Record(record) => {
                    let mut fields = Vec::new();
                    let mut field_idents = Vec::new();
                    let mut field_types = Vec::new();
                    let mut field_names_lit = Vec::new();
                    let mut into_value_fields = Vec::new();
                    let mut from_value_fields = Vec::new();

                    for field in &record.fields {
                        let field_ident =
                            Ident::new(&to_rust_ident(&field.name), Span::call_site());
                        let field_type = self.wit_type_to_typeref(&field.typ);

                        fields.push(quote! { pub #field_ident: #field_type });
                        field_idents.push(field_ident.clone());
                        field_types.push(field_type.clone());
                        field_names_lit.push(field.name.clone());

                        // IntoValue implementation
                        into_value_fields.push(quote! {
                            self.#field_ident.into_value()
                        });

                        // FromValue implementation
                        from_value_fields.push(quote! {
                            let #field_ident = <#field_type as golem_wasm::FromValue>::from_value(fields.remove(0))?;
                        });
                    }

                    let field_count = field_idents.len();

                    quote! {
                        #[derive(Debug, Clone)]
                        pub struct #name {
                            #(#fields),*
                        }

                        impl golem_wasm::IntoValue for #name {
                            fn into_value(self) -> golem_wasm::Value {
                                golem_wasm::Value::Record(vec![
                                    #(#into_value_fields),*
                                ])
                            }

                            fn get_type() -> golem_wasm::analysis::AnalysedType {
                                use golem_wasm::analysis::analysed_type::field;

                                golem_wasm::analysis::AnalysedType::Record(golem_wasm::analysis::TypeRecord {
                                    fields: vec![
                                        #(
                                            field(#field_names_lit, <#field_types as golem_wasm::IntoValue>::get_type())
                                        ),*
                                    ],
                                    name: Some(stringify!(#name).to_string()),
                                    owner: None,
                                })
                            }
                        }

                        impl golem_wasm::FromValue for #name {
                            fn from_value(value: golem_wasm::Value) -> Result<Self, String> {
                                match value {
                                    golem_wasm::Value::Record(mut fields) if fields.len() == #field_count => {
                                        #(#from_value_fields)*
                                        Ok(Self {
                                            #(#field_idents),*
                                        })
                                    }
                                    golem_wasm::Value::Record(fields) => {
                                        Err(format!("Expected Record with {} fields, got {}", #field_count, fields.len()))
                                    }
                                    _ => Err(format!("Expected Record value, got {:?}", value)),
                                }
                            }
                        }
                    }
                }
                AnalysedType::Tuple(tuple) => {
                    let elements = tuple
                        .items
                        .iter()
                        .map(|item| self.wit_type_to_typeref(item))
                        .collect::<Vec<_>>();
                    quote! { pub type #name = (#(#elements),*); }
                }
                AnalysedType::List(list) => {
                    let inner = self.wit_type_to_typeref(&list.inner);
                    quote! { pub type #name = Vec<#inner>; }
                }
                AnalysedType::Str(_) => {
                    quote! { pub type #name = String; }
                }
                AnalysedType::Chr(_) => {
                    quote! { pub type #name = char; }
                }
                AnalysedType::F64(_) => {
                    quote! { pub type #name = f64; }
                }
                AnalysedType::F32(_) => {
                    quote! { pub type #name = f32; }
                }
                AnalysedType::U64(_) => {
                    quote! { pub type #name = u64; }
                }
                AnalysedType::S64(_) => {
                    quote! { pub type #name = i64; }
                }
                AnalysedType::U32(_) => {
                    quote! { pub type #name = u32; }
                }
                AnalysedType::S32(_) => {
                    quote! { pub type #name = i32; }
                }
                AnalysedType::U16(_) => {
                    quote! { pub type #name = u16; }
                }
                AnalysedType::S16(_) => {
                    quote! { pub type #name = i16; }
                }
                AnalysedType::U8(_) => {
                    quote! { pub type #name = u8; }
                }
                AnalysedType::S8(_) => {
                    quote! { pub type #name = i8; }
                }
                AnalysedType::Bool(_) => {
                    quote! { pub type #name = bool; }
                }
                AnalysedType::Handle(_) => {
                    panic!("Handles are not supported");
                }
            }
        } else {
            panic!("Only named types can be defined");
        }
    }

    fn wit_type_to_typeref(&mut self, typ: &AnalysedType) -> TokenStream {
        if let Some(_) = typ.name() {
            let rust_type = self.known_types.get(typ).expect("Must be in known_types");
            match rust_type {
                RustType::Defined { name, .. } => {
                    let name = Ident::new(&name, Span::call_site());
                    quote! { #name }
                }
                RustType::Remapped(remap) => remap.clone(),
            }
        } else {
            match typ {
                AnalysedType::Option(inner) => {
                    let inner = self.wit_type_to_typeref(&*inner.inner);
                    quote! { Option<#inner> }
                }
                AnalysedType::Str(_) => {
                    quote! { String }
                }
                AnalysedType::Chr(_) => {
                    quote! { char }
                }
                AnalysedType::F64(_) => {
                    quote! { f64 }
                }
                AnalysedType::F32(_) => {
                    quote! { f32 }
                }
                AnalysedType::U64(_) => {
                    quote! { u64 }
                }
                AnalysedType::S64(_) => {
                    quote! { i64 }
                }
                AnalysedType::U32(_) => {
                    quote! { u32 }
                }
                AnalysedType::S32(_) => {
                    quote! { i32 }
                }
                AnalysedType::U16(_) => {
                    quote! { u16 }
                }
                AnalysedType::S16(_) => {
                    quote! { i16 }
                }
                AnalysedType::U8(_) => {
                    quote! { u8 }
                }
                AnalysedType::S8(_) => {
                    quote! { i8 }
                }
                AnalysedType::Bool(_) => {
                    quote! { bool }
                }
                AnalysedType::Tuple(tuple) => {
                    let elements = tuple
                        .items
                        .iter()
                        .map(|item| self.wit_type_to_typeref(item))
                        .collect::<Vec<_>>();
                    quote! { (#(#elements),*) }
                }
                AnalysedType::List(list) => {
                    let inner = self.wit_type_to_typeref(&*list.inner);
                    quote! { Vec<#inner> }
                }
                AnalysedType::Result(result) => {
                    let ok = result
                        .ok
                        .as_ref()
                        .map(|ok| self.wit_type_to_typeref(ok))
                        .unwrap_or_else(|| quote! { () });
                    let err = result
                        .err
                        .as_ref()
                        .map(|err| self.wit_type_to_typeref(err))
                        .unwrap_or_else(|| quote! { () });
                    quote! { Result<#ok, #err> }
                }
                AnalysedType::Handle(_)
                | AnalysedType::Variant(_)
                | AnalysedType::Enum(_)
                | AnalysedType::Flags(_)
                | AnalysedType::Record(_) => {
                    // Anonymous complex types need to be associated with a name
                    let name = self.name_anonymous_type(&typ);
                    self.known_types.insert(
                        typ.clone(),
                        RustType::Defined {
                            name: name.clone(),
                            typ: typ.clone(),
                        },
                    );
                    let _def = self.wit_type_to_typedef(&typ); // ensuring the whole type is traversed early
                    let name = Ident::new(&name, Span::call_site());
                    quote! { #name }
                }
            }
        }
    }

    fn name_anonymous_type(&self, _typ: &AnalysedType) -> String {
        // TODO: better naming rules
        let cnt = self.known_types.len();
        format!("AnonType{cnt}")
    }

    fn encode_as_data_value(&self, name: &Ident, data_schema: &DataSchema) -> TokenStream {
        //         let typed_constructor_parameters = golem_common::model::agent::DataValue::Tuple(
        //             golem_common::model::agent::ElementValues {
        //                 elements: vec![golem_common::model::agent::ElementValue::ComponentModel(
        //                     name.into_value_and_type(),
        //                 )],
        //             },
        //         );
        match data_schema {
            DataSchema::Tuple(elements) => {
                let encoded_elements = elements
                    .elements
                    .iter()
                    .map(|named_element| {
                        let name =
                            Ident::new(&to_rust_ident(&named_element.name), Span::call_site());
                        match &named_element.schema {
                            ElementSchema::ComponentModel(_) => {
                                quote! { golem_common::model::agent::ElementValue::ComponentModel(#name.into_value_and_type()) }
                            }
                            ElementSchema::UnstructuredText(_) => {
                                quote! { golem_common::model::agent::ElementValue::UnstructuredText(#name.into_text_reference()) }
                            }
                            ElementSchema::UnstructuredBinary(_) => {
                                quote! { golem_common::model::agent::ElementValue::UnstructuredBinary(#name.into_binary_reference()) }
                            }
                        }
                    })
                    .collect::<Vec<_>>();

                quote! {
                    let #name = golem_common::model::agent::DataValue::Tuple(
                        golem_common::model::agent::ElementValues {
                            elements: vec![#(#encoded_elements),*]
                        }
                    );
                }
            }
            DataSchema::Multimodal(_) => {
                quote! {
                    let #name = golem_common::model::agent::DataValue::Multimodal(
                        golem_common::model::agent::NamedElementValues {
                            elements: values.values.iter().map(|v| v.to_named_element_value()).collect()
                        }
                    );
                }
            }
        }
    }

    fn return_type_from_data_schema(&mut self, data_schema: &DataSchema) -> Option<TokenStream> {
        match data_schema {
            DataSchema::Tuple(elements) => {
                if elements.elements.len() == 0 {
                    None
                } else if elements.elements.len() == 1 {
                    let element = &elements.elements[0];
                    Some(self.element_schema_to_typeref(&element.schema))
                } else {
                    panic!("Multiple return values are not supported");
                }
            }
            DataSchema::Multimodal(elements) => {
                let name = self.get_or_create_multimodal(elements);
                let name = Ident::new(&name, Span::call_site());
                Some(quote! { multimodal::Multimodal<crate::multimodal::#name> })
            }
        }
    }

    fn methods(&mut self, method: &AgentMethod) -> Vec<TokenStream> {
        vec![
            self.await_method(method),
            self.trigger_method(method),
            self.schedule_method(method),
            self.internal_method(method),
        ]
    }

    fn await_method_name(&self, method: &AgentMethod) -> Ident {
        let base_name = to_rust_ident(&method.name);
        Ident::new(&base_name, Span::call_site())
    }

    fn trigger_method_name(&self, method: &AgentMethod) -> Ident {
        let base_name = to_rust_ident(&method.name);
        Ident::new(&format!("trigger_{}", base_name), Span::call_site())
    }

    fn schedule_method_name(&self, method: &AgentMethod) -> Ident {
        let base_name = to_rust_ident(&method.name);
        Ident::new(&format!("schedule_{}", base_name), Span::call_site())
    }

    fn internal_method_name(&self, method: &AgentMethod) -> Ident {
        let base_name = to_rust_ident(&method.name);
        Ident::new(&format!("__{}", base_name), Span::call_site())
    }

    fn await_method(&mut self, method: &AgentMethod) -> TokenStream {
        //     pub async fn increment(&self) -> Result<f64, golem_client::bridge::ClientError> {
        //         let result = self
        //             .__increment(golem_client::model::AgentInvocationMode::Await, None)
        //             .await?;
        //         let result = result.unwrap(); // always Some because of Await
        //         Ok(result)
        //     }
        let name = self.await_method_name(method);
        let internal_name = self.internal_method_name(method);

        let return_type = self.return_type_from_data_schema(&method.output_schema);
        let param_defs = self.parameter_list(&method.input_schema);
        let param_refs = self.parameter_refs(&method.input_schema);

        match return_type {
            Some(return_type) => {
                quote! {
                    pub async fn #name(&self, #(#param_defs),*) -> Result<#return_type, golem_client::bridge::ClientError> {
                        let result = self.#internal_name(golem_client::model::AgentInvocationMode::Await, None, #(#param_refs),*).await?;
                        let result = result.unwrap(); // always Some because of Await
                        Ok(result)
                    }
                }
            }
            None => {
                quote! {
                    pub async fn #name(&self, #(#param_defs),*) -> Result<(), golem_client::bridge::ClientError> {
                        let result = self.#internal_name(golem_client::model::AgentInvocationMode::Await, None, #(#param_refs),*).await?;
                        let _result = result.unwrap(); // always Some because of Await
                        Ok(())
                    }
                }
            }
        }
    }

    fn trigger_method(&mut self, method: &AgentMethod) -> TokenStream {
        //     pub async fn trigger_increment(&self) -> Result<(), golem_client::bridge::ClientError> {
        //         let _ = self
        //             .__increment(golem_client::model::AgentInvocationMode::Schedule, None)
        //             .await?;
        //         Ok(())
        //     }
        let name = self.trigger_method_name(method);
        let internal_name = self.internal_method_name(method);

        let param_defs = self.parameter_list(&method.input_schema);
        let param_refs = self.parameter_refs(&method.input_schema);

        quote! {
            pub async fn #name(&self, #(#param_defs),*) -> Result<(), golem_client::bridge::ClientError> {
                let _ = self.#internal_name(golem_client::model::AgentInvocationMode::Schedule, None, #(#param_refs),*).await?;
                Ok(())
            }
        }
    }

    fn schedule_method(&mut self, method: &AgentMethod) -> TokenStream {
        //  pub async fn schedule_increment(
        //         &self,
        //         when: chrono::DateTime<chrono::Utc>,
        //     ) -> Result<(), golem_client::bridge::ClientError> {
        //         let _ = self
        //             .__increment(
        //                 golem_client::model::AgentInvocationMode::Schedule,
        //                 Some(when),
        //             )
        //             .await?;
        //         Ok(())
        //     }
        let name = self.schedule_method_name(method);
        let internal_name = self.internal_method_name(method);

        let param_defs = self.parameter_list(&method.input_schema);
        let param_refs = self.parameter_refs(&method.input_schema);

        quote! {
            pub async fn #name(&self, when: chrono::DateTime<chrono::Utc>, #(#param_defs),*) -> Result<(), golem_client::bridge::ClientError> {
                let _ = self.#internal_name(golem_client::model::AgentInvocationMode::Schedule, Some(when), #(#param_refs),*).await?;
                Ok(())
            }
        }
    }

    fn internal_method(&mut self, method: &AgentMethod) -> TokenStream {
        let name_lit = Lit::Str(LitStr::new(&method.name, Span::call_site()));
        let name = self.internal_method_name(method);
        let param_defs = self.parameter_list(&method.input_schema);
        let return_type = self.return_type_from_data_schema(&method.output_schema);
        let typed_method_parameters_ident =
            Ident::new("typed_method_parameters", Span::call_site());
        let typed_method_parameters_to_data_value =
            self.encode_as_data_value(&typed_method_parameters_ident, &method.input_schema);

        let output_schema_as_value = self.schema_as_value(&method.output_schema);
        let decode_typed_data_value = self.decode_from_data_value(
            &Ident::new("typed_data_value", Span::call_site()),
            &method.output_schema,
        );

        match return_type {
            Some(return_type) => {
                quote! {
                    async fn #name(&self, mode: golem_client::model::AgentInvocationMode, when: Option<chrono::DateTime<chrono::Utc>>, #(#param_defs),*) -> Result<Option<#return_type>, golem_client::bridge::ClientError> {
                        #typed_method_parameters_to_data_value
                        let method_parameters: golem_common::model::agent::UntypedJsonDataValue = typed_method_parameters.into();
                        let response = self.invoke(#name_lit, method_parameters, mode, when).await?;
                        if let Some(untyped_data_value) = response {
                            let typed_data_value = golem_common::model::agent::DataValue::try_from_untyped_json(
                                untyped_data_value,
                                #output_schema_as_value
                            ).map_err(|err| golem_client::bridge::ClientError::InvocationFailed { message: format!("Failed to decode result value: {err}") })?;
                            #decode_typed_data_value
                        } else {
                            Ok(None)
                        }
                    }
                }
            }
            None => {
                quote! {
                    async fn #name(&self, mode: golem_client::model::AgentInvocationMode, when: Option<chrono::DateTime<chrono::Utc>>, #(#param_defs),*) -> Result<Option<()>, golem_client::bridge::ClientError> {
                        #typed_method_parameters_to_data_value
                        let method_parameters: golem_common::model::agent::UntypedJsonDataValue = typed_method_parameters.into();
                        let response = self.invoke(#name_lit, method_parameters, mode, when).await?;
                        if let Some(untyped_data_value) = response {
                            let typed_data_value = golem_common::model::agent::DataValue::try_from_untyped_json(
                                untyped_data_value,
                                #output_schema_as_value
                            ).map_err(|err| golem_client::bridge::ClientError::InvocationFailed { message: format!("Failed to decode result value: {err}") })?;
                            Ok(Some(()))
                        } else {
                            Ok(None)
                        }
                    }
                }
            }
        }
    }

    fn schema_as_value(&self, schema: &DataSchema) -> TokenStream {
        let named_element_schemas = self.named_element_schemas_as_value(match schema {
            DataSchema::Tuple(s) | DataSchema::Multimodal(s) => s,
        });

        match schema {
            DataSchema::Tuple(_) => {
                quote! {
                    golem_common::model::agent::DataSchema::Tuple(#named_element_schemas)
                }
            }
            DataSchema::Multimodal(_) => {
                quote! {
                    golem_common::model::agent::DataSchema::Multimodal(#named_element_schemas)
                }
            }
        }
    }

    fn named_element_schemas_as_value(&self, schemas: &NamedElementSchemas) -> TokenStream {
        let elements = schemas
            .elements
            .iter()
            .map(|elem| self.named_element_schema_as_value(elem))
            .collect::<Vec<_>>();

        quote! {
            golem_common::model::agent::NamedElementSchemas {
                elements: vec![#(#elements),*],
            }
        }
    }

    fn named_element_schema_as_value(
        &self,
        schema: &golem_common::model::agent::NamedElementSchema,
    ) -> TokenStream {
        let name = &schema.name;
        let element_schema = self.element_schema_as_value(&schema.schema);

        quote! {
            golem_common::model::agent::NamedElementSchema {
                name: #name.to_string(),
                schema: #element_schema,
            }
        }
    }

    fn element_schema_as_value(&self, schema: &ElementSchema) -> TokenStream {
        match schema {
            ElementSchema::ComponentModel(cm_schema) => {
                let element_type = self.analysed_type_as_value(&cm_schema.element_type);
                quote! {
                    golem_common::model::agent::ElementSchema::ComponentModel(
                        golem_common::model::agent::ComponentModelElementSchema {
                            element_type: #element_type,
                        },
                    )
                }
            }
            ElementSchema::UnstructuredText(text_descriptor) => {
                let restrictions = match &text_descriptor.restrictions {
                    Some(text_types) => {
                        let text_type_tokens = text_types
                            .iter()
                            .map(|tt| {
                                let language_code = &tt.language_code;
                                quote! {
                                    golem_common::model::agent::TextType {
                                        language_code: #language_code.to_string(),
                                    }
                                }
                            })
                            .collect::<Vec<_>>();
                        quote! {
                            Some(vec![#(#text_type_tokens),*])
                        }
                    }
                    None => quote! { None },
                };

                quote! {
                    golem_common::model::agent::ElementSchema::UnstructuredText(
                        golem_common::model::agent::TextDescriptor {
                            restrictions: #restrictions,
                        },
                    )
                }
            }
            ElementSchema::UnstructuredBinary(binary_descriptor) => {
                let restrictions = match &binary_descriptor.restrictions {
                    Some(binary_types) => {
                        let binary_type_tokens = binary_types
                            .iter()
                            .map(|bt| {
                                let mime_type = &bt.mime_type;
                                quote! {
                                    golem_common::model::agent::BinaryType {
                                        mime_type: #mime_type.to_string(),
                                    }
                                }
                            })
                            .collect::<Vec<_>>();
                        quote! {
                            Some(vec![#(#binary_type_tokens),*])
                        }
                    }
                    None => quote! { None },
                };

                quote! {
                    golem_common::model::agent::ElementSchema::UnstructuredBinary(
                        golem_common::model::agent::BinaryDescriptor {
                            restrictions: #restrictions,
                        },
                    )
                }
            }
        }
    }

    fn analysed_type_as_value(&self, analysed_type: &AnalysedType) -> TokenStream {
        match analysed_type {
            AnalysedType::Variant(tv) => {
                let name = tv
                    .name
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let owner = tv
                    .owner
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let cases = tv
                    .cases
                    .iter()
                    .map(|case| {
                        let case_name = &case.name;
                        let case_type = case.typ.as_ref().map(|t| self.analysed_type_as_value(t));
                        match case_type {
                            Some(typ) => {
                                quote! {
                                    golem_wasm::analysis::NameOptionTypePair {
                                        name: #case_name.to_string(),
                                        typ: Some(#typ),
                                    }
                                }
                            }
                            None => {
                                quote! {
                                    golem_wasm::analysis::NameOptionTypePair {
                                        name: #case_name.to_string(),
                                        typ: None,
                                    }
                                }
                            }
                        }
                    })
                    .collect::<Vec<_>>();
                quote! {
                    golem_wasm::analysis::AnalysedType::Variant(
                        golem_wasm::analysis::TypeVariant {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            cases: vec![#(#cases),*],
                        },
                    )
                }
            }
            AnalysedType::Result(tr) => {
                let name = tr
                    .name
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let owner = tr
                    .owner
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let ok_type = tr.ok.as_ref().map(|t| self.analysed_type_as_value(t));
                let err_type = tr.err.as_ref().map(|t| self.analysed_type_as_value(t));
                let ok_tokens = match ok_type {
                    Some(t) => quote! { Some(Box::new(#t)) },
                    None => quote! { None },
                };
                let err_tokens = match err_type {
                    Some(t) => quote! { Some(Box::new(#t)) },
                    None => quote! { None },
                };
                quote! {
                    golem_wasm::analysis::AnalysedType::Result(
                        golem_wasm::analysis::TypeResult {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            ok: #ok_tokens,
                            err: #err_tokens,
                        },
                    )
                }
            }
            AnalysedType::Option(to) => {
                let name = to
                    .name
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let owner = to
                    .owner
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let inner = self.analysed_type_as_value(&to.inner);
                quote! {
                    golem_wasm::analysis::AnalysedType::Option(
                        golem_wasm::analysis::TypeOption {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            inner: Box::new(#inner),
                        },
                    )
                }
            }
            AnalysedType::Enum(te) => {
                let name = te
                    .name
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let owner = te
                    .owner
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let cases = &te.cases;
                quote! {
                    golem_wasm::analysis::AnalysedType::Enum(
                        golem_wasm::analysis::TypeEnum {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            cases: vec![#(#cases.to_string()),*],
                        },
                    )
                }
            }
            AnalysedType::Flags(tf) => {
                let name = tf
                    .name
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let owner = tf
                    .owner
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let names = &tf.names;
                quote! {
                    golem_wasm::analysis::AnalysedType::Flags(
                        golem_wasm::analysis::TypeFlags {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            names: vec![#(#names.to_string()),*],
                        },
                    )
                }
            }
            AnalysedType::Record(tr) => {
                let name = tr
                    .name
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let owner = tr
                    .owner
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let fields = tr
                    .fields
                    .iter()
                    .map(|field| {
                        let field_name = &field.name;
                        let field_type = self.analysed_type_as_value(&field.typ);
                        quote! {
                            golem_wasm::analysis::NameTypePair {
                                name: #field_name.to_string(),
                                typ: #field_type,
                            }
                        }
                    })
                    .collect::<Vec<_>>();
                quote! {
                    golem_wasm::analysis::AnalysedType::Record(
                        golem_wasm::analysis::TypeRecord {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            fields: vec![#(#fields),*],
                        },
                    )
                }
            }
            AnalysedType::Tuple(tt) => {
                let name = tt
                    .name
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let owner = tt
                    .owner
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let items = tt
                    .items
                    .iter()
                    .map(|item| self.analysed_type_as_value(item))
                    .collect::<Vec<_>>();
                quote! {
                    golem_wasm::analysis::AnalysedType::Tuple(
                        golem_wasm::analysis::TypeTuple {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            items: vec![#(#items),*],
                        },
                    )
                }
            }
            AnalysedType::List(tl) => {
                let name = tl
                    .name
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let owner = tl
                    .owner
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let inner = self.analysed_type_as_value(&tl.inner);
                quote! {
                    golem_wasm::analysis::AnalysedType::List(
                        golem_wasm::analysis::TypeList {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            inner: Box::new(#inner),
                        },
                    )
                }
            }
            AnalysedType::Str(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::Str(
                        golem_wasm::analysis::TypeStr,
                    )
                }
            }
            AnalysedType::Chr(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::Chr(
                        golem_wasm::analysis::TypeChr,
                    )
                }
            }
            AnalysedType::F64(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::F64(
                        golem_wasm::analysis::TypeF64,
                    )
                }
            }
            AnalysedType::F32(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::F32(
                        golem_wasm::analysis::TypeF32,
                    )
                }
            }
            AnalysedType::U64(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::U64(
                        golem_wasm::analysis::TypeU64,
                    )
                }
            }
            AnalysedType::S64(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::S64(
                        golem_wasm::analysis::TypeS64,
                    )
                }
            }
            AnalysedType::U32(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::U32(
                        golem_wasm::analysis::TypeU32,
                    )
                }
            }
            AnalysedType::S32(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::S32(
                        golem_wasm::analysis::TypeS32,
                    )
                }
            }
            AnalysedType::U16(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::U16(
                        golem_wasm::analysis::TypeU16,
                    )
                }
            }
            AnalysedType::S16(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::S16(
                        golem_wasm::analysis::TypeS16,
                    )
                }
            }
            AnalysedType::U8(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::U8(
                        golem_wasm::analysis::TypeU8,
                    )
                }
            }
            AnalysedType::S8(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::S8(
                        golem_wasm::analysis::TypeS8,
                    )
                }
            }
            AnalysedType::Bool(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::Bool(
                        golem_wasm::analysis::TypeBool,
                    )
                }
            }
            AnalysedType::Handle(th) => {
                let name = th
                    .name
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let owner = th
                    .owner
                    .as_ref()
                    .map(|n| {
                        let lit = Lit::Str(LitStr::new(n, Span::call_site()));
                        quote! { Some(#lit.to_string()) }
                    })
                    .unwrap_or_else(|| quote! { None });
                let resource_id = th.resource_id.0;
                let mode = match th.mode {
                    golem_wasm::analysis::AnalysedResourceMode::Owned => {
                        quote! { golem_wasm::analysis::AnalysedResourceMode::Owned }
                    }
                    golem_wasm::analysis::AnalysedResourceMode::Borrowed => {
                        quote! { golem_wasm::analysis::AnalysedResourceMode::Borrowed }
                    }
                };
                quote! {
                    golem_wasm::analysis::AnalysedType::Handle(
                        golem_wasm::analysis::TypeHandle {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            resource_id: golem_wasm::analysis::AnalysedResourceId(#resource_id),
                            mode: #mode,
                        },
                    )
                }
            }
        }
    }

    fn decode_from_data_value(&mut self, ident: &Ident, data_schema: &DataSchema) -> TokenStream {
        match data_schema {
            DataSchema::Tuple(elements) => {
                if elements.elements.len() > 1 {
                    panic!("multiple result values not supported");
                } else if elements.elements.len() == 0 {
                    quote! {
                        Ok(())
                    }
                } else {
                    let element = &elements.elements[0];
                    match &element.schema {
                        ElementSchema::ComponentModel(_) => {
                            if let Some(return_type) =
                                self.return_type_from_data_schema(data_schema)
                            {
                                quote! {
                                    match #ident {
                                        golem_common::model::agent::DataValue::Tuple(element_values) => {
                                            match element_values.elements.get(0) {
                                                Some(golem_common::model::agent::ElementValue::ComponentModel(vnt)) => {
                                                    Ok(Some(<#return_type>::from_value_and_type(vnt.clone()).map_err(
                                                        |err| golem_client::bridge::ClientError::InvocationFailed {
                                                            message: format!("Failed to decode result value: {err}"),
                                                        },
                                                    )?))
                                                }
                                                _ => Err(golem_client::bridge::ClientError::InvocationFailed {
                                                    message: format!("Failed to decode result value"),
                                                })?,
                                            }
                                        }
                                        _ => Err(golem_client::bridge::ClientError::InvocationFailed {
                                            message: format!("Failed to decode result value"),
                                        })?,
                                    }
                                }
                            } else {
                                quote! { Ok(()) }
                            }
                        }
                        ElementSchema::UnstructuredText(descriptor) => {
                            let unstructured_text = match &descriptor.restrictions {
                                Some(restrictions) => {
                                    let languages_enum = self.get_languages_enum(restrictions);
                                    quote! {
                                        golem_wasm::agentic::unstructured_text::UnstructuredText<#languages_enum>
                                    }
                                }
                                None => {
                                    quote! { golem_wasm::agentic::unstructured_text::UnstructuredText }
                                }
                            };
                            quote! {
                                match #ident {
                                    golem_common::model::agent::DataValue::Tuple(element_values) => {
                                        match element_values.elements.get(0) {
                                            Some(golem_common::model::agent::ElementValue::UnstructuredText(text_ref)) => {
                                                <#unstructured_text>::from_text_reference(text_ref.clone())
                                                    .map(Some)
                                                    .map_err(|err| golem_client::bridge::ClientError::InvocationFailed {
                                                        message: format!("Failed to decode result value: {err}"),
                                                    })
                                            }
                                            _ => Err(golem_client::bridge::ClientError::InvocationFailed {
                                                message: format!("Failed to decode result value"),
                                            })?,
                                        }
                                    }
                                    _ => Err(golem_client::bridge::ClientError::InvocationFailed {
                                        message: format!("Failed to decode result value"),
                                    })?,
                                }
                            }
                        }
                        ElementSchema::UnstructuredBinary(descriptor) => {
                            let unstructured_binary = match &descriptor.restrictions {
                                Some(restrictions) => {
                                    let mimetypes_enum = self.get_mimetypes_enum(restrictions);
                                    quote! {
                                        golem_wasm::agentic::unstructured_binary::UnstructuredBinary<#mimetypes_enum>
                                    }
                                }
                                None => {
                                    quote! { golem_wasm::agentic::unstructured_binary::UnstructuredBinary<String> }
                                }
                            };
                            quote! {
                                match #ident {
                                    golem_common::model::agent::DataValue::Tuple(element_values) => {
                                        match element_values.elements.get(0) {
                                            Some(golem_common::model::agent::ElementValue::UnstructuredBinary(binary_ref)) => {
                                                <#unstructured_binary>::from_binary_reference(binary_ref.clone())
                                                    .map(Some)
                                                    .map_err(|err| golem_client::bridge::ClientError::InvocationFailed {
                                                        message: format!("Failed to decode result value: {err}"),
                                                    })
                                            }
                                            _ => Err(golem_client::bridge::ClientError::InvocationFailed {
                                                message: format!("Failed to decode result value"),
                                            })?,
                                        }
                                    }
                                    _ => Err(golem_client::bridge::ClientError::InvocationFailed {
                                        message: format!("Failed to decode result value"),
                                    })?,
                                }
                            }
                        }
                    }
                }
            }
            DataSchema::Multimodal(elements) => {
                let name = self.get_or_create_multimodal(elements);
                let name = Ident::new(&name, Span::call_site());
                quote! {
                    match #ident {
                        golem_common::model::agent::DataValue::Multimodal(multimodal_value) => {
                            Ok(Some(crate::multimodal::Multimodal::<crate::multimodal::#name>::from_named_element_values(multimodal_value)?))
                        }
                        _ => Err(golem_client::bridge::ClientError::InvocationFailed {
                            message: format!("Failed to decode result value"),
                        })
                    }
                }
            }
        }
    }

    fn global_config(&self) -> TokenStream {
        quote! {
            static CONFIG: std::sync::OnceLock<golem_client::bridge::Configuration> = std::sync::OnceLock::new();

            pub fn configure(server: golem_client::bridge::GolemServer, app_name: &str, env_name: &str) {
                CONFIG
                    .set(golem_client::bridge::Configuration {
                        app_name: app_name.to_string(),
                        env_name: env_name.to_string(),
                        server,
                    })
                    .map_err(|_| ())
                    .expect("Configuration has already been set");
            }
        }
    }

    fn multimodals(&mut self) -> TokenStream {
        if self.known_multimodals.is_empty() {
            quote! {}
        } else {
            let mut multimodal_enums = Vec::new();

            for (named_elements, name) in self.known_multimodals.clone() {
                let name = Ident::new(&name, Span::call_site());
                let mut cases = Vec::new();
                let mut to_named_element_value_cases = Vec::new();
                let mut from_named_element_value_cases = Vec::new();

                for named_element in &named_elements.elements {
                    let case_name_lit =
                        Lit::Str(LitStr::new(&named_element.name, Span::call_site()));
                    let case_name = Ident::new(
                        &to_rust_ident(&named_element.name).to_upper_camel_case(),
                        Span::call_site(),
                    );
                    let case_type = self.element_schema_to_typeref(&named_element.schema);
                    cases.push(quote! { #case_name(#case_type) });

                    let encode_value = match &named_element.schema {
                        ElementSchema::ComponentModel(_) => {
                            quote! { golem_common::model::agent::ElementValue::ComponentModel(value.clone().into_value_and_type()) }
                        }
                        ElementSchema::UnstructuredText(_) => {
                            quote! { golem_common::model::agent::ElementValue::UnstructuredText(value.clone().into_text_reference()) }
                        }
                        ElementSchema::UnstructuredBinary(_) => {
                            quote! { golem_common::model::agent::ElementValue::UnstructuredBinary(value.clone().into_binary_reference()) }
                        }
                    };
                    to_named_element_value_cases.push(quote! {
                        Self::#case_name(value) => golem_common::model::agent::NamedElementValue {
                            name: #case_name_lit.to_string(),
                            value: #encode_value
                        },
                    });

                    let decode_value = match &named_element.schema {
                        ElementSchema::ComponentModel(schema) => {
                            let value_type = self.wit_type_to_typeref(&schema.element_type);
                            quote! {
                                let value = match &named_element_value.value {
                                    golem_common::model::agent::ElementValue::ComponentModel(vnt) => {
                                        Ok(<#value_type>::from_value_and_type(vnt.clone()).map_err(
                                            |err| golem_client::bridge::ClientError::InvocationFailed {
                                                message: format!("Failed to decode result value: {err}"),
                                            }
                                        )?)
                                    }
                                    _ => {
                                        Err(golem_client::bridge::ClientError::InvocationFailed {
                                            message: format!("Failed to decode result value"),
                                        })
                                    }
                                }?;
                            }
                        }
                        ElementSchema::UnstructuredText(descriptor) => {
                            let unstructured_text = match &descriptor.restrictions {
                                Some(restrictions) => {
                                    let languages_enum = self.get_languages_enum(restrictions);
                                    quote! {
                                        golem_wasm::agentic::unstructured_text::UnstructuredText<#languages_enum>
                                    }
                                }
                                None => {
                                    quote! { golem_wasm::agentic::unstructured_text::UnstructuredText }
                                }
                            };
                            quote! {
                                let value = match &named_element_value.value {
                                    golem_common::model::agent::ElementValue::UnstructuredText(text_ref) => {
                                        <#unstructured_text>::from_text_reference(text_ref.clone())
                                            .map_err(|err| golem_client::bridge::ClientError::InvocationFailed {
                                                message: format!("Failed to decode result value: {err}"),
                                            })
                                    }
                                    _ => {
                                        Err(golem_client::bridge::ClientError::InvocationFailed {
                                            message: format!("Failed to decode result value"),
                                        })
                                    }
                                }?;
                            }
                        }
                        ElementSchema::UnstructuredBinary(descriptor) => {
                            let unstructured_binary = match &descriptor.restrictions {
                                Some(restrictions) => {
                                    let mimetypes_enum = self.get_mimetypes_enum(restrictions);
                                    quote! {
                                        golem_wasm::agentic::unstructured_binary::UnstructuredBinary<#mimetypes_enum>
                                    }
                                }
                                None => {
                                    quote! { golem_wasm::agentic::unstructured_binary::UnstructuredBinary<String> }
                                }
                            };
                            quote! {
                                let value = match &named_element_value.value {
                                    golem_common::model::agent::ElementValue::UnstructuredBinary(binary_ref) => {
                                        <#unstructured_binary>::from_binary_reference(binary_ref.clone())
                                            .map_err(|err| golem_client::bridge::ClientError::InvocationFailed {
                                                message: format!("Failed to decode result value: {err}"),
                                            })
                                    }
                                    _ => {
                                        Err(golem_client::bridge::ClientError::InvocationFailed {
                                            message: format!("Failed to decode result value"),
                                        })
                                    }
                                }?;
                            }
                        }
                    };
                    from_named_element_value_cases.push(quote! {
                        #case_name_lit => {
                            #decode_value
                            values.push(Self::#case_name(value));
                        },
                    });
                }

                multimodal_enums.push(quote! {
                    pub enum #name {
                        #(#cases),*
                    }

                    impl MultimodalEnum for #name {
                        fn to_named_element_value(&self) -> golem_common::model::agent::NamedElementValue {
                            match self {
                                #(#to_named_element_value_cases)*
                            }
                        }

                        fn from_named_element_values(named_element_values: golem_common::model::agent::NamedElementValues) -> Result<Multimodal<Self>, golem_client::bridge::ClientError> {
                            let mut values = Vec::new();
                            for named_element_value in named_element_values.elements {
                                match named_element_value.name.as_str() {
                                    #(#from_named_element_value_cases)*
                                    _ => {
                                        return Err(golem_client::bridge::ClientError::InvocationFailed {
                                            message: format!("Unknown multimodal element name: {}", named_element_value.name),
                                        });
                                    }
                                }
                            }
                            Ok(Multimodal {
                                values: nonempty_collections::NEVec::try_from_vec(values).ok_or_else(|| golem_client::bridge::ClientError::InvocationFailed { message: "Empty multimodal value".to_string() })?,
                            })
                        }
                    }
                });
            }

            quote! {
                pub mod multimodal {
                    use super::*;
                    use golem_common::base_model::agent::{UnstructuredBinaryExtensions, UnstructuredTextExtensions};
                    use golem_wasm::{FromValueAndType, IntoValueAndType};

                    #[derive(Debug, Clone)]
                    pub struct Multimodal<T: MultimodalEnum> {
                        pub values: nonempty_collections::NEVec<T>
                    }

                    impl<T: MultimodalEnum> Multimodal<T> {
                        pub fn from_named_element_values(named_element_values: golem_common::model::agent::NamedElementValues) -> Result<Self, golem_client::bridge::ClientError> {
                            T::from_named_element_values(named_element_values)
                        }
                    }

                    pub trait MultimodalEnum: Sized {
                        fn to_named_element_value(&self) -> golem_common::model::agent::NamedElementValue;
                        fn from_named_element_values(named_element_values: golem_common::model::agent::NamedElementValues) -> Result<Multimodal<Self>, golem_client::bridge::ClientError>;
                    }

                    #(#multimodal_enums)*
                }
            }
        }
    }

    fn languages_module(&self) -> TokenStream {
        if self.generated_language_enums.is_empty() {
            quote! {}
        } else {
            let mut language_enums = Vec::new();

            for (types, name) in &self.generated_language_enums {
                let ident = Ident::new(name, Span::call_site());

                let mut cases = Vec::new();
                let mut code_strings = Vec::new();
                let mut from_match_cases = Vec::new();
                let mut to_match_cases = Vec::new();

                for typ in types {
                    let ident = Ident::new(
                        &to_rust_ident(&typ.language_code).to_upper_camel_case(),
                        Span::call_site(),
                    );
                    let lit = Lit::Str(LitStr::new(&typ.language_code, Span::call_site()));

                    cases.push(quote! { #ident });
                    code_strings.push(quote! { #lit });
                    from_match_cases
                        .push(quote! { #ident => golem_wasm::analysis::TextType::#ident });
                    to_match_cases
                        .push(quote! { golem_wasm::analysis::TextType::#ident => Ok(#ident) });
                }

                language_enums.push(quote! {
                    #[derive(Debug, Clone)]
                    pub enum #ident {
                        #(#cases),*
                    }

                    impl golem_wasm::agentic::unstructured_text::AllowedLanguages for #ident {
                        fn all() -> &'static [&'static str] {
                            &[#(#code_strings),*]
                        }

                        fn from_language_code(code: &str) -> Option<Self>
                        where
                            Self: Sized {
                            match code {
                                #(#from_match_cases),*
                            }
                        }

                        fn to_language_code(&self) -> &'static str {
                            match self {
                                #(#to_match_cases),*
                            }
                        }
                    }
                });
            }

            quote! {
                pub mod languages {
                    #(#language_enums)*
                }
            }
        }
    }

    fn mimetypes_module(&self) -> TokenStream {
        if self.generated_mimetypes_enums.is_empty() {
            quote! {}
        } else {
            let mut mimetypes_enums = Vec::new();

            for (types, name) in &self.generated_mimetypes_enums {
                let ident = Ident::new(name, Span::call_site());

                let mut cases = Vec::new();
                let mut code_strings = Vec::new();
                let mut from_match_cases = Vec::new();
                let mut to_match_cases = Vec::new();

                for typ in types {
                    let enum_variant_ident = Ident::new(
                        &to_rust_ident(&typ.mime_type).to_upper_camel_case(),
                        Span::call_site(),
                    );
                    let lit = Lit::Str(LitStr::new(&typ.mime_type, Span::call_site()));

                    cases.push(quote! { #enum_variant_ident });
                    code_strings.push(quote! { #lit });
                    from_match_cases.push(quote! { #lit => Some(Self::#enum_variant_ident), });
                    to_match_cases.push(quote! { Self::#enum_variant_ident => #lit.to_string(), });
                }

                mimetypes_enums.push(quote! {
                    #[derive(Debug, Clone)]
                    pub enum #ident {
                        #(#cases),*
                    }

                    impl golem_wasm::agentic::unstructured_binary::AllowedMimeTypes for #ident {
                        fn all() -> &'static [&'static str] {
                            &[#(#code_strings),*]
                        }

                        fn from_string(mime_type: &str) -> Option<Self>
                        where
                            Self: Sized {
                            match mime_type {
                                #(#from_match_cases)*
                                _ => None,
                            }
                        }

                        fn to_string(&self) -> String {
                            match self {
                                #(#to_match_cases)*
                            }
                        }
                    }
                });
            }

            quote! {
                pub mod mimetypes {
                    #(#mimetypes_enums)*
                }
            }
        }
    }

    fn collect_named_types(&mut self) {
        let all_types = super::collect_all_wit_types(&self.agent_type);
        for typ in all_types {
            if let Some(name) = typ.name() {
                // TODO: detect special known types and store them as Remapped
                // TODO: detect name collisions
                // TODO: use owner for the name

                self.known_types.insert(
                    typ.clone(),
                    RustType::Defined {
                        name: to_rust_ident(name).to_upper_camel_case(),
                        typ,
                    },
                );
            }
        }
    }

    fn type_definitions(&mut self) -> TokenStream {
        let mut type_definitions = Vec::new();

        let defined = self
            .known_types
            .iter()
            .filter_map(|(_, rust_type)| match rust_type {
                RustType::Defined { name, typ } => Some((name.clone(), typ.clone())),
                _ => None,
            })
            .collect::<BTreeMap<String, AnalysedType>>();

        for (name, typ) in defined {
            let def = self.wit_type_to_typedef(&typ.named(name));
            type_definitions.push(def);
        }

        quote! {
            #(#type_definitions)*
        }
    }

    fn package_name(&self) -> String {
        format!("{}_client", self.agent_type.type_name.0.to_snake_case())
    }
}

enum RustType {
    Defined { name: String, typ: AnalysedType },
    Remapped(TokenStream),
}

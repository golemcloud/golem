// Copyright 2024-2025 Golem Cloud
//
// Licensed under the Golem Source License v1.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://license.golem.cloud/LICENSE
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::bridge_gen::BridgeGenerator;
use anyhow::anyhow;
use camino::{Utf8Path, Utf8PathBuf};
use golem_common::model::agent::AgentType;
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::{Ident, Span, TokenStream};
use quote::quote;
use toml_edit::{array, value, Array, DocumentMut, Item, Table};

#[cfg(test)]
mod tests;

#[allow(dead_code)]
pub struct RustBridgeGenerator {
    target_path: Utf8PathBuf,
    agent_type: AgentType,
    testing: bool,
}

impl BridgeGenerator for RustBridgeGenerator {
    fn new(agent_type: AgentType, target_path: &Utf8Path, testing: bool) -> Self {
        Self {
            target_path: target_path.to_path_buf(),
            agent_type,
            testing,
        }
    }

    fn generate(&self) -> anyhow::Result<()> {
        let cargo_toml_path = self.target_path.join("Cargo.toml");
        let lib_rs_path = self.target_path.join("src/lib.rs");

        if !self.target_path.exists() {
            std::fs::create_dir_all(&self.target_path)?;
        }

        let src_dir = self.target_path.join("src");
        if !src_dir.exists() {
            std::fs::create_dir_all(&src_dir)?;
        }

        self.generate_cargo_toml(&cargo_toml_path)?;
        self.generate_lib_rs(&lib_rs_path)?;

        Ok(())
    }
}

impl RustBridgeGenerator {
    /// Generates the Cargo.toml manifest file
    fn generate_cargo_toml(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let package_name = self.package_name();

        let mut doc = DocumentMut::new();

        // Set up [package] section
        doc["package"] = Item::Table(Default::default());
        doc["package"]["name"] = value(package_name);
        doc["package"]["version"] = value("0.0.1");
        doc["package"]["edition"] = value("2021");
        doc["package"]["description"] = value("Generated by golem-cli");

        fn add_features(entry: &mut Item, features: &[&str]) {
            if !features.is_empty() {
                let mut feature_items = Array::default();
                for feature in features {
                    feature_items.push(*feature);
                }
                entry["features"] = value(feature_items);
            }
        }

        // Set up [dependencies] section
        fn dep(version: &str, features: &[&str]) -> Item {
            let mut entry = Item::Table(Table::default());
            entry["version"] = value(version);
            add_features(&mut entry, features);
            entry
        }

        fn git_dep(url: &str, branch: &str, features: &[&str]) -> Item {
            let mut entry = Item::Table(Table::default());
            entry["git"] = value(url);
            entry["branch"] = value(branch);
            add_features(&mut entry, features);
            entry
        }

        // TODO: reduce features if possible
        doc["dependencies"] = Item::Table(Table::default());
        doc["dependencies"]["golem-client"] =
            git_dep("https://github.com/golemcloud/golem", "main", &[]); // TODO: we don't want a git dependency in the final (and don't want to depend on wasmtime etc)
        doc["dependencies"]["reqwest"] = dep("0.13", &[]);
        doc["dependencies"]["serde"] = dep("1.0", &["derive"]);
        doc["dependencies"]["serde_json"] = dep("1.0", &[]);
        doc["dependencies"]["tokio"] = dep("1", &["full"]);
        doc["dependencies"]["uuid"] = dep("1.18.1", &[""]);

        // TODO: these patches should not be necessary
        doc["patch"]["crates-io"]["wasmtime"] = git_dep("https://github.com/golemcloud/wasmtime.git", "golem-wasmtime-v33.0.0", &[]);
        doc["patch"]["crates-io"]["wasmtime-wasi"] = git_dep("https://github.com/golemcloud/wasmtime.git", "golem-wasmtime-v33.0.0", &[]);
        doc["patch"]["crates-io"]["wasmtime-wasi-http"] = git_dep("https://github.com/golemcloud/wasmtime.git", "golem-wasmtime-v33.0.0", &[]);

        std::fs::write(path, doc.to_string())
            .map_err(|e| anyhow!("Failed to write Cargo.toml file: {e}"))?;

        Ok(())
    }

    /// Generates the lib.rs source file
    fn generate_lib_rs(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let tokens = self.generate_lib_rs_tokens()?;
        let formatted = prettyplease::unparse(&syn::parse2(tokens)?);

        std::fs::write(path, formatted).map_err(|e| anyhow!("Failed to write lib.rs file: {e}"))?;

        Ok(())
    }

    /// Generates the TokenStream for lib.rs content
    fn generate_lib_rs_tokens(&self) -> anyhow::Result<TokenStream> {
        let agent_type_name = &self.agent_type.type_name.0;
        let client_struct_name =
            Ident::new(&agent_type_name.to_upper_camel_case(), Span::call_site());

        let tokens = quote! {
            struct #client_struct_name {}
        };

        Ok(tokens)
    }

    /// Helper to generate the package name from the agent type name
    fn package_name(&self) -> String {
        format!("{}_client", self.agent_type.type_name.0.to_snake_case())
    }
}

// Copyright 2024-2025 Golem Cloud
//
// Licensed under the Golem Source License v1.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://license.golem.cloud/LICENSE
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::bridge_gen::rust::rust::to_rust_ident;
use crate::bridge_gen::BridgeGenerator;
use anyhow::anyhow;
use camino::{Utf8Path, Utf8PathBuf};
use golem_common::model::agent::{AgentMethod, AgentType, DataSchema, ElementSchema};
use golem_wasm::analysis::AnalysedType;
use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::{Ident, Span, TokenStream};
use quote::quote;
use syn::{Lit, LitStr};
use toml_edit::{value, Array, DocumentMut, Item, Table};

mod rust;
#[cfg(test)]
mod tests;

#[allow(dead_code)]
pub struct RustBridgeGenerator {
    target_path: Utf8PathBuf,
    agent_type: AgentType,
    testing: bool,
}

// TODO: convert panics to error results
impl BridgeGenerator for RustBridgeGenerator {
    fn new(agent_type: AgentType, target_path: &Utf8Path, testing: bool) -> Self {
        Self {
            target_path: target_path.to_path_buf(),
            agent_type,
            testing,
        }
    }

    fn generate(&self) -> anyhow::Result<()> {
        let cargo_toml_path = self.target_path.join("Cargo.toml");
        let lib_rs_path = self.target_path.join("src/lib.rs");

        if !self.target_path.exists() {
            std::fs::create_dir_all(&self.target_path)?;
        }

        let src_dir = self.target_path.join("src");
        if !src_dir.exists() {
            std::fs::create_dir_all(&src_dir)?;
        }

        self.generate_cargo_toml(&cargo_toml_path)?;
        self.generate_lib_rs(&lib_rs_path)?;

        Ok(())
    }
}

impl RustBridgeGenerator {
    /// Generates the Cargo.toml manifest file
    fn generate_cargo_toml(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let package_name = self.package_name();

        let mut doc = DocumentMut::new();

        // Set up [package] section
        doc["package"] = Item::Table(Default::default());
        doc["package"]["name"] = value(package_name);
        doc["package"]["version"] = value("0.0.1");
        doc["package"]["edition"] = value("2021");
        doc["package"]["description"] = value("Generated by golem-cli");

        fn add_features(entry: &mut Item, features: &[&str]) {
            if !features.is_empty() {
                let mut feature_items = Array::default();
                for feature in features {
                    feature_items.push(*feature);
                }
                entry["default-features"] = value(false);
                entry["features"] = value(feature_items);
            }
        }

        fn dep(version: &str, features: &[&str]) -> Item {
            let mut entry = Item::Table(Table::default());
            entry["version"] = value(version);
            add_features(&mut entry, features);
            entry
        }

        fn git_dep(url: &str, branch: &str, features: &[&str]) -> Item {
            let mut entry = Item::Table(Table::default());
            entry["git"] = value(url);
            entry["branch"] = value(branch);
            add_features(&mut entry, features);
            entry
        }

        doc["dependencies"] = Item::Table(Table::default());
        doc["dependencies"]["chrono"] = dep("0.4", &[]);
        doc["dependencies"]["golem-client"] =
            git_dep("https://github.com/golemcloud/golem", "rust-bridge", &[]); // TODO: use published version when available
        doc["dependencies"]["golem-common"] = git_dep(
            "https://github.com/golemcloud/golem",
            "rust-bridge",
            &["client"],
        ); // TODO: use published version when available
        doc["dependencies"]["golem-wasm"] = git_dep(
            "https://github.com/golemcloud/golem",
            "rust-bridge",
            &["client"],
        ); // TODO: use published version when available
        doc["dependencies"]["reqwest"] = dep("0.12", &["default-tls"]);
        // doc["dependencies"]["serde"] = dep("1.0", &["derive"]); // TODO: not needed?
        // doc["dependencies"]["serde_json"] = dep("1.0", &[]); // TODO: not needed?
        // doc["dependencies"]["tokio"] = dep("1", &[]); // TODO: not needed?
        doc["dependencies"]["uuid"] = dep("1.18.1", &["v4"]);

        std::fs::write(path, doc.to_string())
            .map_err(|e| anyhow!("Failed to write Cargo.toml file: {e}"))?;

        Ok(())
    }

    /// Generates the lib.rs source file
    fn generate_lib_rs(&self, path: &Utf8Path) -> anyhow::Result<()> {
        let tokens = self.generate_lib_rs_tokens()?;

        // println!("{}", tokens);
        let formatted = prettyplease::unparse(&syn::parse2(tokens)?);

        std::fs::write(path, formatted).map_err(|e| anyhow!("Failed to write lib.rs file: {e}"))?;

        Ok(())
    }

    /// Generates the TokenStream for lib.rs content
    fn generate_lib_rs_tokens(&self) -> anyhow::Result<TokenStream> {
        let agent_type_name = &self.agent_type.type_name.0;
        let agent_type_name_lit = Lit::Str(LitStr::new(agent_type_name, Span::call_site()));
        let client_struct_name =
            Ident::new(&agent_type_name.to_upper_camel_case(), Span::call_site());

        let constructor_params = self.parameter_list(&self.agent_type.constructor.input_schema);

        let typed_constructor_parameters_ident =
            Ident::new("typed_constructor_parameters", Span::call_site());
        let constructor_params_to_data_value = self.encode_as_data_value(
            &typed_constructor_parameters_ident,
            &self.agent_type.constructor.input_schema,
        );

        let methods = self
            .agent_type
            .methods
            .iter()
            .flat_map(|method| self.methods(method))
            .collect::<Vec<_>>();

        let global_config = self.global_config();

        let tokens = quote! {
            use golem_wasm::{FromValueAndType, IntoValueAndType};

            pub struct #client_struct_name {
                constructor_parameters: golem_client::model::UntypedJsonDataValue,
                phantom_id: Option<uuid::Uuid>,
            }

            impl #client_struct_name {
                pub fn get(#(#constructor_params),*) -> Self {
                    #constructor_params_to_data_value
                    let constructor_parameters: golem_common::model::agent::UntypedJsonDataValue =
                        typed_constructor_parameters.into();
                    Self { constructor_parameters, phantom_id: None }
                }

                pub fn get_phantom(uuid: uuid::Uuid, #(#constructor_params),*) -> Self {
                    #constructor_params_to_data_value
                    let constructor_parameters: golem_common::model::agent::UntypedJsonDataValue =
                        typed_constructor_parameters.into();
                    Self { constructor_parameters, phantom_id: Some(uuid) }
                }

                pub fn new_phantom(#(#constructor_params),*) -> Self {
                    #constructor_params_to_data_value
                    let constructor_parameters: golem_common::model::agent::UntypedJsonDataValue =
                        typed_constructor_parameters.into();
                    Self { constructor_parameters, phantom_id: Some(uuid::Uuid::new_v4()) }
                }

                #(#methods)*

                async fn invoke(
                    &self,
                    method_name: &str,
                    method_parameters: golem_client::model::UntypedJsonDataValue,
                    mode: golem_client::model::AgentInvocationMode,
                    schedule_at: Option<chrono::DateTime<chrono::Utc>>,
                ) -> Result<Option<golem_client::model::UntypedJsonDataValue>, golem_client::bridge::ClientError> {
                    let config = CONFIG.get().expect("Configuration has not been set");

                    let client = reqwest::Client::builder().build().unwrap();
                    let context = golem_client::Context {
                        client,
                        base_url: config.server.url(),
                        security_token: config.server.token(),
                    };
                    let client = golem_client::api::AgentClientLive { context };
                    let response = golem_client::api::AgentClient::invoke_agent(
                        &client,
                        None,
                        &golem_client::model::AgentInvocationRequest {
                            app_name: config.app_name.to_string(),
                            env_name: config.env_name.to_string(),
                            agent_type_name: #agent_type_name_lit.to_string(),
                            parameters: self.constructor_parameters.clone(),
                            phantom_id: self.phantom_id.clone(),
                            method_name: method_name.to_string(),
                            method_parameters,
                            mode,
                            schedule_at,
                            idempotency_key: None,
                        },
                    )
                    .await?;
                    Ok(response.result)
                }
            }

            #global_config
        };

        Ok(tokens)
    }

    fn parameter_list(&self, data_schema: &DataSchema) -> Vec<TokenStream> {
        // each item is 'name: type'

        match data_schema {
            DataSchema::Tuple(elements) => {
                let mut result = Vec::new();
                for element in &elements.elements {
                    let name = Ident::new(&to_rust_ident(&element.name), Span::call_site());
                    let typ = self.element_schema_to_typeref(&element.schema);
                    result.push(quote! {#name: #typ});
                }
                result
            }
            DataSchema::Multimodal(elements) => {
                todo!()
            }
        }
    }

    fn parameter_refs(&self, data_schema: &DataSchema) -> Vec<TokenStream> {
        // each item is 'name: type'

        match data_schema {
            DataSchema::Tuple(elements) => {
                let mut result = Vec::new();
                for element in &elements.elements {
                    let name = Ident::new(&to_rust_ident(&element.name), Span::call_site());
                    let typ = self.element_schema_to_typeref(&element.schema);
                    result.push(quote! {#name});
                }
                result
            }
            DataSchema::Multimodal(elements) => {
                todo!()
            }
        }
    }

    fn element_schema_to_typeref(&self, element_schema: &ElementSchema) -> TokenStream {
        match element_schema {
            ElementSchema::ComponentModel(schema) => self.wit_type_to_typeref(&schema.element_type),
            ElementSchema::UnstructuredText(_) => {
                todo!()
            }
            ElementSchema::UnstructuredBinary(_) => {
                todo!()
            }
        }
    }

    fn wit_type_to_typeref(&self, typ: &AnalysedType) -> TokenStream {
        if let Some(name) = typ.name() {
            let name = Ident::new(&to_rust_ident(&name), Span::call_site());
            quote! { #name }
        } else {
            match typ {
                AnalysedType::Variant(_) => {
                    todo!()
                }
                AnalysedType::Result(_) => {
                    todo!()
                }
                AnalysedType::Option(inner) => {
                    let inner = self.wit_type_to_typeref(&*inner.inner);
                    quote! { Option<#inner> }
                }
                AnalysedType::Enum(_) => {
                    todo!()
                }
                AnalysedType::Flags(_) => {
                    todo!()
                }
                AnalysedType::Record(_) => {
                    todo!()
                }
                AnalysedType::Tuple(_) => {
                    todo!()
                }
                AnalysedType::List(_) => {
                    todo!()
                }
                AnalysedType::Str(_) => {
                    quote! { String }
                }
                AnalysedType::Chr(_) => {
                    quote! { char }
                }
                AnalysedType::F64(_) => {
                    quote! { f64 }
                }
                AnalysedType::F32(_) => {
                    quote! { f32 }
                }
                AnalysedType::U64(_) => {
                    quote! { u64 }
                }
                AnalysedType::S64(_) => {
                    quote! { i64 }
                }
                AnalysedType::U32(_) => {
                    quote! { u32 }
                }
                AnalysedType::S32(_) => {
                    quote! { i32 }
                }
                AnalysedType::U16(_) => {
                    quote! { u16 }
                }
                AnalysedType::S16(_) => {
                    quote! { i16 }
                }
                AnalysedType::U8(_) => {
                    quote! { u8 }
                }
                AnalysedType::S8(_) => {
                    quote! { i8 }
                }
                AnalysedType::Bool(_) => {
                    quote! { bool }
                }
                AnalysedType::Handle(_) => {
                    todo!()
                }
            }
        }
    }

    fn encode_as_data_value(&self, name: &Ident, data_schema: &DataSchema) -> TokenStream {
        //         let typed_constructor_parameters = golem_common::model::agent::DataValue::Tuple(
        //             golem_common::model::agent::ElementValues {
        //                 elements: vec![golem_common::model::agent::ElementValue::ComponentModel(
        //                     name.into_value_and_type(),
        //                 )],
        //             },
        //         );
        match data_schema {
            DataSchema::Tuple(elements) => {
                let encoded_elements = elements
                    .elements
                    .iter()
                    .map(|named_element| {
                        // TODO: support unstructured text/binary

                        let name =
                            Ident::new(&to_rust_ident(&named_element.name), Span::call_site());
                        quote! { golem_common::model::agent::ElementValue::ComponentModel(#name.into_value_and_type()) }
                    })
                    .collect::<Vec<_>>();

                quote! {
                    let #name = golem_common::model::agent::DataValue::Tuple(
                        golem_common::model::agent::ElementValues {
                            elements: vec![#(#encoded_elements),*]
                        }
                    );
                }
            }
            DataSchema::Multimodal(_) => {
                todo!()
            }
        }
    }

    fn return_type_from_data_schema(&self, data_schema: &DataSchema) -> TokenStream {
        match data_schema {
            DataSchema::Tuple(elements) => {
                if elements.elements.len() == 1 {
                    let element = &elements.elements[0];
                    self.element_schema_to_typeref(&element.schema)
                } else {
                    panic!("Multiple return values are not supported");
                }
            }
            DataSchema::Multimodal(elements) => {
                todo!()
            }
        }
    }

    fn methods(&self, method: &AgentMethod) -> Vec<TokenStream> {
        vec![
            self.await_method(method),
            self.trigger_method(method),
            self.schedule_method(method),
            self.internal_method(method),
        ]
    }

    fn await_method_name(&self, method: &AgentMethod) -> Ident {
        let base_name = to_rust_ident(&method.name);
        Ident::new(&base_name, Span::call_site())
    }

    fn trigger_method_name(&self, method: &AgentMethod) -> Ident {
        let base_name = to_rust_ident(&method.name);
        Ident::new(&format!("trigger_{}", base_name), Span::call_site())
    }

    fn schedule_method_name(&self, method: &AgentMethod) -> Ident {
        let base_name = to_rust_ident(&method.name);
        Ident::new(&format!("schedule_{}", base_name), Span::call_site())
    }

    fn internal_method_name(&self, method: &AgentMethod) -> Ident {
        let base_name = to_rust_ident(&method.name);
        Ident::new(&format!("__{}", base_name), Span::call_site())
    }

    fn await_method(&self, method: &AgentMethod) -> TokenStream {
        //     pub async fn increment(&self) -> Result<f64, golem_client::bridge::ClientError> {
        //         let result = self
        //             .__increment(golem_client::model::AgentInvocationMode::Await, None)
        //             .await?;
        //         let result = result.unwrap(); // always Some because of Await
        //         Ok(result)
        //     }
        let name = self.await_method_name(method);
        let internal_name = self.internal_method_name(method);

        let return_type = self.return_type_from_data_schema(&method.output_schema);
        let param_defs = self.parameter_list(&method.input_schema);
        let param_refs = self.parameter_refs(&method.input_schema);

        quote! {
            pub async fn #name(&self, #(#param_defs),*) -> Result<#return_type, golem_client::bridge::ClientError> {
                let result = self.#internal_name(golem_client::model::AgentInvocationMode::Await, None, #(#param_refs),*).await?;
                let result = result.unwrap(); // always Some because of Await
                Ok(result)
            }
        }
    }

    fn trigger_method(&self, method: &AgentMethod) -> TokenStream {
        //     pub async fn trigger_increment(&self) -> Result<(), golem_client::bridge::ClientError> {
        //         let _ = self
        //             .__increment(golem_client::model::AgentInvocationMode::Schedule, None)
        //             .await?;
        //         Ok(())
        //     }
        let name = self.trigger_method_name(method);
        let internal_name = self.internal_method_name(method);

        let param_defs = self.parameter_list(&method.input_schema);
        let param_refs = self.parameter_refs(&method.input_schema);

        quote! {
            pub async fn #name(&self, #(#param_defs),*) -> Result<(), golem_client::bridge::ClientError> {
                let _ = self.#internal_name(golem_client::model::AgentInvocationMode::Schedule, None, #(#param_refs),*).await?;
                Ok(())
            }
        }
    }

    fn schedule_method(&self, method: &AgentMethod) -> TokenStream {
        //  pub async fn schedule_increment(
        //         &self,
        //         when: chrono::DateTime<chrono::Utc>,
        //     ) -> Result<(), golem_client::bridge::ClientError> {
        //         let _ = self
        //             .__increment(
        //                 golem_client::model::AgentInvocationMode::Schedule,
        //                 Some(when),
        //             )
        //             .await?;
        //         Ok(())
        //     }
        let name = self.schedule_method_name(method);
        let internal_name = self.internal_method_name(method);

        let param_defs = self.parameter_list(&method.input_schema);
        let param_refs = self.parameter_refs(&method.input_schema);

        quote! {
            pub async fn #name(&self, when: chrono::DateTime<chrono::Utc>, #(#param_defs),*) -> Result<(), golem_client::bridge::ClientError> {
                let _ = self.#internal_name(golem_client::model::AgentInvocationMode::Schedule, Some(when), #(#param_refs),*).await?;
                Ok(())
            }
        }
    }

    fn internal_method(&self, method: &AgentMethod) -> TokenStream {
        let name_lit = Lit::Str(LitStr::new(&method.name, Span::call_site()));
        let name = self.internal_method_name(method);
        let param_defs = self.parameter_list(&method.input_schema);
        let return_type = self.return_type_from_data_schema(&method.output_schema);
        let typed_method_parameters_ident =
            Ident::new("typed_method_parameters", Span::call_site());
        let typed_method_parameters_to_data_value =
            self.encode_as_data_value(&typed_method_parameters_ident, &method.input_schema);

        let output_schema_as_value = self.schema_as_value(&method.output_schema);
        let decode_typed_data_value = self.decode_from_data_value(
            &Ident::new("typed_data_value", Span::call_site()),
            &method.output_schema,
        );

        quote! {
            async fn #name(&self, mode: golem_client::model::AgentInvocationMode, when: Option<chrono::DateTime<chrono::Utc>>, #(#param_defs),*) -> Result<Option<#return_type>, golem_client::bridge::ClientError> {
                #typed_method_parameters_to_data_value
                let method_parameters: golem_common::model::agent::UntypedJsonDataValue = typed_method_parameters.into();
                let response = self.invoke(#name_lit, method_parameters, mode, when).await?;
                if let Some(untyped_data_value) = response {
                    let typed_data_value = golem_common::model::agent::DataValue::try_from_untyped_json(
                        untyped_data_value,
                        #output_schema_as_value
                    ).map_err(|err| golem_client::bridge::ClientError::InvocationFailed { message: format!("Failed to decode result value: {err}") })?;
                    #decode_typed_data_value
                } else {
                    Ok(None)
                }
            }
        }
    }

    fn schema_as_value(&self, schema: &DataSchema) -> TokenStream {
        let named_element_schemas = self.named_element_schemas_as_value(match schema {
            DataSchema::Tuple(s) | DataSchema::Multimodal(s) => s,
        });

        match schema {
            DataSchema::Tuple(_) => {
                quote! {
                    golem_common::model::agent::DataSchema::Tuple(#named_element_schemas)
                }
            }
            DataSchema::Multimodal(_) => {
                quote! {
                    golem_common::model::agent::DataSchema::Multimodal(#named_element_schemas)
                }
            }
        }
    }

    fn named_element_schemas_as_value(
        &self,
        schemas: &golem_common::model::agent::NamedElementSchemas,
    ) -> TokenStream {
        let elements = schemas
            .elements
            .iter()
            .map(|elem| self.named_element_schema_as_value(elem))
            .collect::<Vec<_>>();

        quote! {
            golem_common::model::agent::NamedElementSchemas {
                elements: vec![#(#elements),*],
            }
        }
    }

    fn named_element_schema_as_value(
        &self,
        schema: &golem_common::model::agent::NamedElementSchema,
    ) -> TokenStream {
        let name = &schema.name;
        let element_schema = self.element_schema_as_value(&schema.schema);

        quote! {
            golem_common::model::agent::NamedElementSchema {
                name: #name.to_string(),
                schema: #element_schema,
            }
        }
    }

    fn element_schema_as_value(&self, schema: &ElementSchema) -> TokenStream {
        match schema {
            ElementSchema::ComponentModel(cm_schema) => {
                let element_type = self.analysed_type_as_value(&cm_schema.element_type);
                quote! {
                    golem_common::model::agent::ElementSchema::ComponentModel(
                        golem_common::model::agent::ComponentModelElementSchema {
                            element_type: #element_type,
                        },
                    )
                }
            }
            ElementSchema::UnstructuredText(text_descriptor) => {
                let restrictions = match &text_descriptor.restrictions {
                    Some(text_types) => {
                        let text_type_tokens = text_types
                            .iter()
                            .map(|tt| {
                                let language_code = &tt.language_code;
                                quote! {
                                    golem_common::model::agent::TextType {
                                        language_code: #language_code.to_string(),
                                    }
                                }
                            })
                            .collect::<Vec<_>>();
                        quote! {
                            Some(vec![#(#text_type_tokens),*])
                        }
                    }
                    None => quote! { None },
                };

                quote! {
                    golem_common::model::agent::ElementSchema::UnstructuredText(
                        golem_common::model::agent::TextDescriptor {
                            restrictions: #restrictions,
                        },
                    )
                }
            }
            ElementSchema::UnstructuredBinary(binary_descriptor) => {
                let restrictions = match &binary_descriptor.restrictions {
                    Some(binary_types) => {
                        let binary_type_tokens = binary_types
                            .iter()
                            .map(|bt| {
                                let mime_type = &bt.mime_type;
                                quote! {
                                    golem_common::model::agent::BinaryType {
                                        mime_type: #mime_type.to_string(),
                                    }
                                }
                            })
                            .collect::<Vec<_>>();
                        quote! {
                            Some(vec![#(#binary_type_tokens),*])
                        }
                    }
                    None => quote! { None },
                };

                quote! {
                    golem_common::model::agent::ElementSchema::UnstructuredBinary(
                        golem_common::model::agent::BinaryDescriptor {
                            restrictions: #restrictions,
                        },
                    )
                }
            }
        }
    }

    fn analysed_type_as_value(&self, analysed_type: &AnalysedType) -> TokenStream {
        match analysed_type {
            AnalysedType::Variant(tv) => {
                let name = &tv.name;
                let owner = &tv.owner;
                let cases = tv
                    .cases
                    .iter()
                    .map(|case| {
                        let case_name = &case.name;
                        let case_type = case.typ.as_ref().map(|t| self.analysed_type_as_value(t));
                        match case_type {
                            Some(typ) => {
                                quote! {
                                    golem_wasm::analysis::NameOptionTypePair {
                                        name: #case_name.to_string(),
                                        typ: Some(Box::new(#typ)),
                                    }
                                }
                            }
                            None => {
                                quote! {
                                    golem_wasm::analysis::NameOptionTypePair {
                                        name: #case_name.to_string(),
                                        typ: None,
                                    }
                                }
                            }
                        }
                    })
                    .collect::<Vec<_>>();
                quote! {
                    golem_wasm::analysis::AnalysedType::Variant(
                        golem_wasm::analysis::TypeVariant {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            cases: vec![#(#cases),*],
                        },
                    )
                }
            }
            AnalysedType::Result(tr) => {
                let name = &tr.name;
                let owner = &tr.owner;
                let ok_type = tr.ok.as_ref().map(|t| self.analysed_type_as_value(t));
                let err_type = tr.err.as_ref().map(|t| self.analysed_type_as_value(t));
                let ok_tokens = match ok_type {
                    Some(t) => quote! { Some(Box::new(#t)) },
                    None => quote! { None },
                };
                let err_tokens = match err_type {
                    Some(t) => quote! { Some(Box::new(#t)) },
                    None => quote! { None },
                };
                quote! {
                    golem_wasm::analysis::AnalysedType::Result(
                        golem_wasm::analysis::TypeResult {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            ok: #ok_tokens,
                            err: #err_tokens,
                        },
                    )
                }
            }
            AnalysedType::Option(to) => {
                let name = &to.name;
                let owner = &to.owner;
                let inner = self.analysed_type_as_value(&to.inner);
                quote! {
                    golem_wasm::analysis::AnalysedType::Option(
                        golem_wasm::analysis::TypeOption {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            inner: Box::new(#inner),
                        },
                    )
                }
            }
            AnalysedType::Enum(te) => {
                let name = &te.name;
                let owner = &te.owner;
                let cases = &te.cases;
                quote! {
                    golem_wasm::analysis::AnalysedType::Enum(
                        golem_wasm::analysis::TypeEnum {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            cases: vec![#(#cases.to_string()),*],
                        },
                    )
                }
            }
            AnalysedType::Flags(tf) => {
                let name = &tf.name;
                let owner = &tf.owner;
                let names = &tf.names;
                quote! {
                    golem_wasm::analysis::AnalysedType::Flags(
                        golem_wasm::analysis::TypeFlags {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            names: vec![#(#names.to_string()),*],
                        },
                    )
                }
            }
            AnalysedType::Record(tr) => {
                let name = &tr.name;
                let owner = &tr.owner;
                let fields = tr
                    .fields
                    .iter()
                    .map(|field| {
                        let field_name = &field.name;
                        let field_type = self.analysed_type_as_value(&field.typ);
                        quote! {
                            golem_wasm::analysis::NameTypePair {
                                name: #field_name.to_string(),
                                typ: #field_type,
                            }
                        }
                    })
                    .collect::<Vec<_>>();
                quote! {
                    golem_wasm::analysis::AnalysedType::Record(
                        golem_wasm::analysis::TypeRecord {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            fields: vec![#(#fields),*],
                        },
                    )
                }
            }
            AnalysedType::Tuple(tt) => {
                let name = &tt.name;
                let owner = &tt.owner;
                let items = tt
                    .items
                    .iter()
                    .map(|item| self.analysed_type_as_value(item))
                    .collect::<Vec<_>>();
                quote! {
                    golem_wasm::analysis::AnalysedType::Tuple(
                        golem_wasm::analysis::TypeTuple {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            items: vec![#(#items),*],
                        },
                    )
                }
            }
            AnalysedType::List(tl) => {
                let name = &tl.name;
                let owner = &tl.owner;
                let inner = self.analysed_type_as_value(&tl.inner);
                quote! {
                    golem_wasm::analysis::AnalysedType::List(
                        golem_wasm::analysis::TypeList {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            inner: Box::new(#inner),
                        },
                    )
                }
            }
            AnalysedType::Str(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::Str(
                        golem_wasm::analysis::TypeStr,
                    )
                }
            }
            AnalysedType::Chr(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::Chr(
                        golem_wasm::analysis::TypeChr,
                    )
                }
            }
            AnalysedType::F64(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::F64(
                        golem_wasm::analysis::TypeF64,
                    )
                }
            }
            AnalysedType::F32(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::F32(
                        golem_wasm::analysis::TypeF32,
                    )
                }
            }
            AnalysedType::U64(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::U64(
                        golem_wasm::analysis::TypeU64,
                    )
                }
            }
            AnalysedType::S64(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::S64(
                        golem_wasm::analysis::TypeS64,
                    )
                }
            }
            AnalysedType::U32(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::U32(
                        golem_wasm::analysis::TypeU32,
                    )
                }
            }
            AnalysedType::S32(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::S32(
                        golem_wasm::analysis::TypeS32,
                    )
                }
            }
            AnalysedType::U16(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::U16(
                        golem_wasm::analysis::TypeU16,
                    )
                }
            }
            AnalysedType::S16(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::S16(
                        golem_wasm::analysis::TypeS16,
                    )
                }
            }
            AnalysedType::U8(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::U8(
                        golem_wasm::analysis::TypeU8,
                    )
                }
            }
            AnalysedType::S8(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::S8(
                        golem_wasm::analysis::TypeS8,
                    )
                }
            }
            AnalysedType::Bool(_) => {
                quote! {
                    golem_wasm::analysis::AnalysedType::Bool(
                        golem_wasm::analysis::TypeBool,
                    )
                }
            }
            AnalysedType::Handle(th) => {
                let name = &th.name;
                let owner = &th.owner;
                let resource_id = th.resource_id.0;
                let mode = match th.mode {
                    golem_wasm::analysis::AnalysedResourceMode::Owned => {
                        quote! { golem_wasm::analysis::AnalysedResourceMode::Owned }
                    }
                    golem_wasm::analysis::AnalysedResourceMode::Borrowed => {
                        quote! { golem_wasm::analysis::AnalysedResourceMode::Borrowed }
                    }
                };
                quote! {
                    golem_wasm::analysis::AnalysedType::Handle(
                        golem_wasm::analysis::TypeHandle {
                            name: #name.clone(),
                            owner: #owner.clone(),
                            resource_id: golem_wasm::analysis::AnalysedResourceId(#resource_id),
                            mode: #mode,
                        },
                    )
                }
            }
        }
    }

    fn decode_from_data_value(&self, ident: &Ident, data_schema: &DataSchema) -> TokenStream {
        match data_schema {
            DataSchema::Tuple(elements) => {
                if elements.elements.len() != 1 {
                    panic!("multiple result values not supported");
                }

                let element = &elements.elements[0];
                match &element.schema {
                    ElementSchema::ComponentModel(_) => {
                        let return_type = self.return_type_from_data_schema(data_schema);
                        quote! {
                            match #ident {
                                golem_common::model::agent::DataValue::Tuple(element_values) => {
                                    match element_values.elements.get(0) {
                                        Some(golem_common::model::agent::ElementValue::ComponentModel(vnt)) => {
                                            Ok(Some(<#return_type>::from_value_and_type(vnt.clone()).map_err(
                                                |err| golem_client::bridge::ClientError::InvocationFailed {
                                                    message: format!("Failed to decode result value: {err}"),
                                                },
                                            )?))
                                        }
                                        _ => Err(golem_client::bridge::ClientError::InvocationFailed {
                                            message: format!("Failed to decode result value"),
                                        })?,
                                    }
                                }
                                _ => Err(golem_client::bridge::ClientError::InvocationFailed {
                                    message: format!("Failed to decode result value"),
                                })?,
                            }
                        }
                    }
                    ElementSchema::UnstructuredText(_) => {
                        quote! {
                            todo!("unstructured text decoding not yet implemented")
                        }
                    }
                    ElementSchema::UnstructuredBinary(_) => {
                        quote! {
                            todo!("unstructured binary decoding not yet implemented")
                        }
                    }
                }
            }
            DataSchema::Multimodal(_) => {
                quote! {
                    todo!("multimodal decoding not yet implemented")
                }
            }
        }
    }

    fn global_config(&self) -> TokenStream {
        quote! {
            static CONFIG: std::sync::OnceLock<golem_client::bridge::Configuration> = std::sync::OnceLock::new();

            pub fn configure(server: golem_client::bridge::GolemServer, app_name: &str, env_name: &str) {
                CONFIG
                    .set(golem_client::bridge::Configuration {
                        app_name: app_name.to_string(),
                        env_name: env_name.to_string(),
                        server,
                    })
                    .map_err(|_| ())
                    .expect("Configuration has already been set");
            }
        }
    }

    /// Helper to generate the package name from the agent type name
    fn package_name(&self) -> String {
        format!("{}_client", self.agent_type.type_name.0.to_snake_case())
    }
}

//     async fn __increment(
//         &self,
//         mode: golem_client::model::AgentInvocationMode,
//         when: Option<chrono::DateTime<chrono::Utc>>,
//     ) -> Result<Option<f64>, golem_client::bridge::ClientError> {
//         let typed_method_parameters = golem_common::model::agent::DataValue::Tuple(
//             golem_common::model::agent::ElementValues { elements: vec![] },
//         );
//         let method_parameters: golem_common::model::agent::UntypedJsonDataValue =
//             typed_method_parameters.into();
//         let response = self
//             .invoke("increment", method_parameters, mode, when)
//             .await?;
//         if let Some(untyped_data_value) = response {
//             let typed_data_value = golem_common::model::agent::DataValue::try_from_untyped_json(
//                 untyped_data_value,
//                 golem_common::model::agent::DataSchema::Tuple(
//                     golem_common::model::agent::NamedElementSchemas {
//                         elements: vec![golem_common::model::agent::NamedElementSchema {
//                             name: "return".to_string(),
//                             schema: golem_common::model::agent::ElementSchema::ComponentModel(
//                                 golem_common::model::agent::ComponentModelElementSchema {
//                                     element_type: golem_wasm::analysis::analysed_type::f64(),
//                                 },
//                             ),
//                         }],
//                     },
//                 ),
//             )
//             .map_err(|err| golem_client::bridge::ClientError::InvocationFailed {
//                 message: format!("Failed to decode result value: {err}"),
//             })?;
//             match typed_data_value {
//                 golem_common::model::agent::DataValue::Tuple(element_values) => {
//                     match element_values.elements.get(0) {
//                         Some(golem_common::model::agent::ElementValue::ComponentModel(vnt)) => {
//                             Ok(Some(f64::from_value_and_type(vnt.clone()).map_err(
//                                 |err| golem_client::bridge::ClientError::InvocationFailed {
//                                     message: format!("Failed to decode result value: {err}"),
//                                 },
//                             )?))
//                         }
//                         _ => Err(golem_client::bridge::ClientError::InvocationFailed {
//                             message: format!("Failed to decode result value"),
//                         })?,
//                     }
//                 }
//                 _ => Err(golem_client::bridge::ClientError::InvocationFailed {
//                     message: format!("Failed to decode result value"),
//                 })?,
//             }
//         } else {
//             Ok(None)
//         }
//     }

package golem:durability@1.2.1;

interface durability {
    use golem:api/host@2.0.0.{persistence-level};
    use golem:api/oplog@2.0.0.{oplog-index, wrapped-function-type};
    use wasi:clocks/wall-clock@0.2.3.{datetime};
    use wasi:io/poll@0.2.3.{pollable};
    use golem:rpc/types@0.2.2.{value-and-type};

    type durable-function-type = wrapped-function-type;

    /// Represents the current durable execution state
    record durable-execution-state {
        /// If true, the executor is in live mode, side-effects should be performed and persisted.
        /// If false, the executor is in replay mode, side-effects should be replayed from the persisted data.
        is-live: bool,
        /// The currently active persistence level
        persistence-level: persistence-level,
    }

    /// Represents the oplog entry version; this is for backward compatibility and most use cases should always use
    /// (and expect) the latest version.
    enum oplog-entry-version {
        v1,
        v2
    }

    /// Represents a raw persisted durable function invocation. This record is not self-describing, the `response` field
    /// can store an arbitrary data. This is used internally for some predefined invocations. For user-defined custom
    /// durability, the `typed` variants are recommended, as those contain type information about the payload that can
    /// be used by tools to observe the contents of the entries.
    record persisted-durable-function-invocation {
        /// The timestamp of the invocation.
        timestamp: datetime,
        /// The invoked function's unique name
        function-name: string,
        /// Arbitrary byte array storing the persisted result of the function
        response: list<u8>,
        /// Type of the durable function invocation
        function-type: durable-function-type,
        /// Oplog entry version
        entry-version: oplog-entry-version
    }

    /// The typed, self-describing version of `persisted-durable-function-invocation`. The difference is that the `response` field
    /// contains a value and its type information together, making the user-defined payload observable by external tools.
    record persisted-typed-durable-function-invocation {
        /// The timestamp of the invocation.
        timestamp: datetime,
        /// The invoked function's unique name
        function-name: string,
        /// Arbitrary structured value (and type) describing the invocation's result
        response: value-and-type,
        /// Type of the durable function invocation
        function-type: durable-function-type,
        /// Oplog entry version
        entry-version: oplog-entry-version
    }

    /// Observes a function call (produces logs and metrics)
    observe-function-call: func(iface: string, function: string);

    /// Marks the beginning of a durable function.
    ///
    /// There must be a corresponding call to `end-durable-function` after the function has
    /// performed its work (it can be ended in a different context, for example after an async
    /// pollable operation has been completed)
    begin-durable-function: func(function-type: durable-function-type) -> oplog-index;

    /// Marks the end of a durable function
    ///
    /// This is a pair of `begin-durable-function` and should be called after the durable function
    /// has performed and persisted or replayed its work. The `begin-index` should be the index
    /// returned by `begin-durable-function`.
    ///
    /// Normally commit behavior is decided by the executor based on the `function-type`. However, in special
    /// cases the `forced-commit` parameter can be used to force commit the oplog in an efficient way.
    end-durable-function: func(function-type: durable-function-type, begin-index: oplog-index, forced-commit: bool);

    /// Gets the current durable execution state
    current-durable-execution-state: func() -> durable-execution-state;

    /// Writes a record to the agent's oplog representing a durable function invocation
    persist-durable-function-invocation: func(
        function-name: string,
        request: list<u8>,
        response: list<u8>,
        function-type: durable-function-type,
    );

    /// Writes a record to the agent's oplog representing a durable function invocation
    ///
    /// The request and response are defined as pairs of value and type, which makes it
    /// self-describing for observers of oplogs. This is the recommended way to persist
    /// third-party function invocations.
    persist-typed-durable-function-invocation: func(
        function-name: string,
        request: value-and-type,
        response: value-and-type,
        function-type: durable-function-type,
    );

    /// Reads the next persisted durable function invocation from the oplog during replay
    read-persisted-durable-function-invocation: func() -> persisted-durable-function-invocation;

    /// Reads the next persisted durable function invocation from the oplog during replay, assuming it
    /// was created with `persist-typed-durable-function-invocation`
    read-persisted-typed-durable-function-invocation: func() -> persisted-typed-durable-function-invocation;

    /// A pollable which can be later attached to a real `pollable`, but it can be subscribed to even
    /// before that.
    resource lazy-initialized-pollable {
        /// Creates a `pollable` that is never ready until it gets attached to a real `pollable` implementation
        /// using `set-lazy-initialized-pollable`.
        constructor();

        /// Sets the underlying `pollable` for a pollable created with `create-lazy-initialized-pollable`.
        set: func(pollable: pollable);

        subscribe: func() -> pollable;
    }
}

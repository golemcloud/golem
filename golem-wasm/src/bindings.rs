// Generated by `wit-bindgen` 0.42.1. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
//   * with "wasi:io/poll@0.2.3" = "wstd::wasi::io::poll"
//   * with "wasi:clocks/wall-clock@0.2.3" = "wstd::wasi::clocks::wall_clock"
//   * generate_unused_types
use wstd::wasi::clocks::wall_clock as __with_name0;
use wstd::wasi::io::poll as __with_name1;
#[allow(dead_code, clippy::all)]
pub mod golem {
  pub mod core {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      /// UUID
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct Uuid {
        pub high_bits: u64,
        pub low_bits: u64,
      }
      impl ::core::fmt::Debug for Uuid {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Uuid").field("high-bits", &self.high_bits).field("low-bits", &self.low_bits).finish()
        }
      }
      /// Represents a Golem component
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct ComponentId {
        pub uuid: Uuid,
      }
      impl ::core::fmt::Debug for ComponentId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ComponentId").field("uuid", &self.uuid).finish()
        }
      }
      /// Represents a Golem agent
      #[derive(Clone)]
      pub struct AgentId {
        /// Identifies the component the agent belongs to
        pub component_id: ComponentId,
        /// String representation of the agent ID (agent type and constructor parameters)
        pub agent_id: _rt::String,
      }
      impl ::core::fmt::Debug for AgentId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("AgentId").field("component-id", &self.component_id).field("agent-id", &self.agent_id).finish()
        }
      }
      /// Represents a Golem account
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct AccountId {
        pub uuid: Uuid,
      }
      impl ::core::fmt::Debug for AccountId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("AccountId").field("uuid", &self.uuid).finish()
        }
      }
      /// An index into the persistent log storing all performed operations of an agent
      pub type OplogIndex = u64;
      /// A promise ID is a value that can be passed to an external Golem API to complete that promise
      /// from an arbitrary external source, while Golem agents can await for this completion.
      #[derive(Clone)]
      pub struct PromiseId {
        pub agent_id: AgentId,
        pub oplog_idx: OplogIndex,
      }
      impl ::core::fmt::Debug for PromiseId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("PromiseId").field("agent-id", &self.agent_id).field("oplog-idx", &self.oplog_idx).finish()
        }
      }
      /// The index type used in `wit-value` and `wit-type` to identify nodes
      pub type NodeIndex = i32;
      /// Represents a WIT resource in an instance
      pub type ResourceId = u64;
      /// Resource handle modes
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum ResourceMode {
        /// The resource is owned by this handle
        Owned,
        /// The resource is owned by someone else, and this handle is just a borrow
        Borrowed,
      }
      impl ::core::fmt::Debug for ResourceMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            ResourceMode::Owned => {
              f.debug_tuple("ResourceMode::Owned").finish()
            }
            ResourceMode::Borrowed => {
              f.debug_tuple("ResourceMode::Borrowed").finish()
            }
          }
        }
      }

      impl ResourceMode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ResourceMode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ResourceMode::Owned,
            1 => ResourceMode::Borrowed,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      /// Represents a type within a `wit-type` definition. `node-index` values are indices into the
      /// parent `wit-type`'s `nodes` list.
      #[derive(Clone)]
      pub enum WitTypeNode {
        /// Record type, defined by a list of name-type pairs.
        RecordType(_rt::Vec::<(_rt::String,NodeIndex,)>),
        /// Variant type, defined by a list of name-type pairs. The type is optional, in case it is not defined, the case
        /// is a unit case.
        VariantType(_rt::Vec::<(_rt::String,Option<NodeIndex>,)>),
        /// Enum type, defined by a list of its cases.
        EnumType(_rt::Vec::<_rt::String>),
        /// Flags type, defined by a list of its flags.
        FlagsType(_rt::Vec::<_rt::String>),
        /// Tuple type, defined by a list of its field's types.
        TupleType(_rt::Vec::<NodeIndex>),
        /// List type, defined by the element type
        ListType(NodeIndex),
        /// Option type, defined by the element type
        OptionType(NodeIndex),
        /// Result type, defined by the success and error types. Both types are optional, in case they are not defined, the
        /// ok or error case is a unit case.
        ResultType((Option<NodeIndex>,Option<NodeIndex>,)),
        /// Unsigned 8-bit integer
        PrimU8Type,
        /// Unsigned 16-bit integer
        PrimU16Type,
        /// Unsigned 32-bit integer
        PrimU32Type,
        /// Unsigned 64-bit integer
        PrimU64Type,
        /// Signed 8-bit integer
        PrimS8Type,
        /// Signed 16-bit integer
        PrimS16Type,
        /// Signed 32-bit integer
        PrimS32Type,
        /// Signed 64-bit integer
        PrimS64Type,
        /// 32-bit floating point number
        PrimF32Type,
        /// 64-bit floating point number
        PrimF64Type,
        /// Unicode character
        PrimCharType,
        /// Boolean value
        PrimBoolType,
        /// String value
        PrimStringType,
        /// Handle type, defined by a resource ID and borrowing mode
        HandleType((ResourceId,ResourceMode,)),
      }
      impl ::core::fmt::Debug for WitTypeNode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            WitTypeNode::RecordType(e) => {
              f.debug_tuple("WitTypeNode::RecordType").field(e).finish()
            }
            WitTypeNode::VariantType(e) => {
              f.debug_tuple("WitTypeNode::VariantType").field(e).finish()
            }
            WitTypeNode::EnumType(e) => {
              f.debug_tuple("WitTypeNode::EnumType").field(e).finish()
            }
            WitTypeNode::FlagsType(e) => {
              f.debug_tuple("WitTypeNode::FlagsType").field(e).finish()
            }
            WitTypeNode::TupleType(e) => {
              f.debug_tuple("WitTypeNode::TupleType").field(e).finish()
            }
            WitTypeNode::ListType(e) => {
              f.debug_tuple("WitTypeNode::ListType").field(e).finish()
            }
            WitTypeNode::OptionType(e) => {
              f.debug_tuple("WitTypeNode::OptionType").field(e).finish()
            }
            WitTypeNode::ResultType(e) => {
              f.debug_tuple("WitTypeNode::ResultType").field(e).finish()
            }
            WitTypeNode::PrimU8Type => {
              f.debug_tuple("WitTypeNode::PrimU8Type").finish()
            }
            WitTypeNode::PrimU16Type => {
              f.debug_tuple("WitTypeNode::PrimU16Type").finish()
            }
            WitTypeNode::PrimU32Type => {
              f.debug_tuple("WitTypeNode::PrimU32Type").finish()
            }
            WitTypeNode::PrimU64Type => {
              f.debug_tuple("WitTypeNode::PrimU64Type").finish()
            }
            WitTypeNode::PrimS8Type => {
              f.debug_tuple("WitTypeNode::PrimS8Type").finish()
            }
            WitTypeNode::PrimS16Type => {
              f.debug_tuple("WitTypeNode::PrimS16Type").finish()
            }
            WitTypeNode::PrimS32Type => {
              f.debug_tuple("WitTypeNode::PrimS32Type").finish()
            }
            WitTypeNode::PrimS64Type => {
              f.debug_tuple("WitTypeNode::PrimS64Type").finish()
            }
            WitTypeNode::PrimF32Type => {
              f.debug_tuple("WitTypeNode::PrimF32Type").finish()
            }
            WitTypeNode::PrimF64Type => {
              f.debug_tuple("WitTypeNode::PrimF64Type").finish()
            }
            WitTypeNode::PrimCharType => {
              f.debug_tuple("WitTypeNode::PrimCharType").finish()
            }
            WitTypeNode::PrimBoolType => {
              f.debug_tuple("WitTypeNode::PrimBoolType").finish()
            }
            WitTypeNode::PrimStringType => {
              f.debug_tuple("WitTypeNode::PrimStringType").finish()
            }
            WitTypeNode::HandleType(e) => {
              f.debug_tuple("WitTypeNode::HandleType").field(e).finish()
            }
          }
        }
      }
      /// Represents a node of `wit-type`, with attached metadata
      #[derive(Clone)]
      pub struct NamedWitTypeNode {
        /// Name of the type
        pub name: Option<_rt::String>,
        /// Owner of the type (usually pointing to a WIT package and interface)
        pub owner: Option<_rt::String>,
        /// The node representing a type
        pub type_: WitTypeNode,
      }
      impl ::core::fmt::Debug for NamedWitTypeNode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("NamedWitTypeNode").field("name", &self.name).field("owner", &self.owner).field("type", &self.type_).finish()
        }
      }
      /// Describes a type of a `wit-value`
      #[derive(Clone)]
      pub struct WitType {
        /// The nodes consisting of the type definition. Because WIT does not support recursive types, the nodes are represented as a list of named nodes.
        /// The list is always non-empty, and the first item is the root node.
        pub nodes: _rt::Vec::<NamedWitTypeNode>,
      }
      impl ::core::fmt::Debug for WitType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("WitType").field("nodes", &self.nodes).finish()
        }
      }
      /// URI value
      #[derive(Clone)]
      pub struct Uri {
        pub value: _rt::String,
      }
      impl ::core::fmt::Debug for Uri {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Uri").field("value", &self.value).finish()
        }
      }
      /// One node of a `wit-value`
      #[derive(Clone)]
      pub enum WitNode {
        /// A record value defined by a list of its field values
        RecordValue(_rt::Vec::<NodeIndex>),
        /// A variant value defined by a pair of the case index and its inner value
        VariantValue((u32,Option<NodeIndex>,)),
        /// An enum value defined by a case index
        EnumValue(u32),
        /// A flags value defined by a list of its flag states
        FlagsValue(_rt::Vec::<bool>),
        /// A tuple value defined by a list of its item values
        TupleValue(_rt::Vec::<NodeIndex>),
        /// A list value defined by a list of its item values
        ListValue(_rt::Vec::<NodeIndex>),
        /// An option value defined by an optional inner value
        OptionValue(Option<NodeIndex>),
        /// A result value defined by either an ok value or an error value. Both values are optional,
        /// where the `none` case represents the absence of a value.
        ResultValue(Result<Option<NodeIndex>,Option<NodeIndex>>),
        /// Primitive unsigned 8-bit integer
        PrimU8(u8),
        /// Primitive unsigned 16-bit integer
        PrimU16(u16),
        /// Primitive unsigned 32-bit integer
        PrimU32(u32),
        /// Primitive unsigned 64-bit integer
        PrimU64(u64),
        /// Primitive signed 8-bit integer
        PrimS8(i8),
        /// Primitive signed 16-bit integer
        PrimS16(i16),
        /// Primitive signed 32-bit integer
        PrimS32(i32),
        /// Primitive signed 64-bit integer
        PrimS64(i64),
        /// Primitive 32-bit floating point number
        PrimFloat32(f32),
        /// Primitive 64-bit floating point number
        PrimFloat64(f64),
        /// Primitive character
        PrimChar(char),
        /// Primitive boolean
        PrimBool(bool),
        /// Primitive string
        PrimString(_rt::String),
        /// Resource handle pointing to a URI and a resource ID
        Handle((Uri,u64,)),
      }
      impl ::core::fmt::Debug for WitNode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            WitNode::RecordValue(e) => {
              f.debug_tuple("WitNode::RecordValue").field(e).finish()
            }
            WitNode::VariantValue(e) => {
              f.debug_tuple("WitNode::VariantValue").field(e).finish()
            }
            WitNode::EnumValue(e) => {
              f.debug_tuple("WitNode::EnumValue").field(e).finish()
            }
            WitNode::FlagsValue(e) => {
              f.debug_tuple("WitNode::FlagsValue").field(e).finish()
            }
            WitNode::TupleValue(e) => {
              f.debug_tuple("WitNode::TupleValue").field(e).finish()
            }
            WitNode::ListValue(e) => {
              f.debug_tuple("WitNode::ListValue").field(e).finish()
            }
            WitNode::OptionValue(e) => {
              f.debug_tuple("WitNode::OptionValue").field(e).finish()
            }
            WitNode::ResultValue(e) => {
              f.debug_tuple("WitNode::ResultValue").field(e).finish()
            }
            WitNode::PrimU8(e) => {
              f.debug_tuple("WitNode::PrimU8").field(e).finish()
            }
            WitNode::PrimU16(e) => {
              f.debug_tuple("WitNode::PrimU16").field(e).finish()
            }
            WitNode::PrimU32(e) => {
              f.debug_tuple("WitNode::PrimU32").field(e).finish()
            }
            WitNode::PrimU64(e) => {
              f.debug_tuple("WitNode::PrimU64").field(e).finish()
            }
            WitNode::PrimS8(e) => {
              f.debug_tuple("WitNode::PrimS8").field(e).finish()
            }
            WitNode::PrimS16(e) => {
              f.debug_tuple("WitNode::PrimS16").field(e).finish()
            }
            WitNode::PrimS32(e) => {
              f.debug_tuple("WitNode::PrimS32").field(e).finish()
            }
            WitNode::PrimS64(e) => {
              f.debug_tuple("WitNode::PrimS64").field(e).finish()
            }
            WitNode::PrimFloat32(e) => {
              f.debug_tuple("WitNode::PrimFloat32").field(e).finish()
            }
            WitNode::PrimFloat64(e) => {
              f.debug_tuple("WitNode::PrimFloat64").field(e).finish()
            }
            WitNode::PrimChar(e) => {
              f.debug_tuple("WitNode::PrimChar").field(e).finish()
            }
            WitNode::PrimBool(e) => {
              f.debug_tuple("WitNode::PrimBool").field(e).finish()
            }
            WitNode::PrimString(e) => {
              f.debug_tuple("WitNode::PrimString").field(e).finish()
            }
            WitNode::Handle(e) => {
              f.debug_tuple("WitNode::Handle").field(e).finish()
            }
          }
        }
      }
      /// Describes an arbitrary value
      #[derive(Clone)]
      pub struct WitValue {
        /// The list of `wit-node` values that make up the value. The list is always non-empty,
        /// and the first element is the root node describing the value. Because WIT does not support
        /// recursive types, further nodes are pushed into this list, and referenced by index from their parent node.
        pub nodes: _rt::Vec::<WitNode>,
      }
      impl ::core::fmt::Debug for WitValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("WitValue").field("nodes", &self.nodes).finish()
        }
      }
      /// A value and its type
      #[derive(Clone)]
      pub struct ValueAndType {
        /// Value
        pub value: WitValue,
        /// Type of `value`
        pub typ: WitType,
      }
      impl ::core::fmt::Debug for ValueAndType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ValueAndType").field("value", &self.value).field("typ", &self.typ).finish()
        }
      }
      /// URL alias
      pub type Url = _rt::String;
      /// Text type descriptor
      #[derive(Clone)]
      pub struct TextType {
        pub language_code: _rt::String,
      }
      impl ::core::fmt::Debug for TextType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("TextType").field("language-code", &self.language_code).finish()
        }
      }
      /// Inline text source
      #[derive(Clone)]
      pub struct TextSource {
        pub data: _rt::String,
        pub text_type: Option<TextType>,
      }
      impl ::core::fmt::Debug for TextSource {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("TextSource").field("data", &self.data).field("text-type", &self.text_type).finish()
        }
      }
      /// Reference to a text value
      #[derive(Clone)]
      pub enum TextReference {
        Url(_rt::String),
        Inline(TextSource),
      }
      impl ::core::fmt::Debug for TextReference {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            TextReference::Url(e) => {
              f.debug_tuple("TextReference::Url").field(e).finish()
            }
            TextReference::Inline(e) => {
              f.debug_tuple("TextReference::Inline").field(e).finish()
            }
          }
        }
      }
      /// Binary type descriptor
      #[derive(Clone)]
      pub struct BinaryType {
        pub mime_type: _rt::String,
      }
      impl ::core::fmt::Debug for BinaryType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("BinaryType").field("mime-type", &self.mime_type).finish()
        }
      }
      /// Inline binary source
      #[derive(Clone)]
      pub struct BinarySource {
        pub data: _rt::Vec::<u8>,
        pub binary_type: BinaryType,
      }
      impl ::core::fmt::Debug for BinarySource {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("BinarySource").field("data", &self.data).field("binary-type", &self.binary_type).finish()
        }
      }
      /// Reference to a binary value
      #[derive(Clone)]
      pub enum BinaryReference {
        Url(Url),
        Inline(BinarySource),
      }
      impl ::core::fmt::Debug for BinaryReference {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            BinaryReference::Url(e) => {
              f.debug_tuple("BinaryReference::Url").field(e).finish()
            }
            BinaryReference::Inline(e) => {
              f.debug_tuple("BinaryReference::Inline").field(e).finish()
            }
          }
        }
      }
      /// An untyped element value, representing one element of an untyped data value
      #[derive(Clone)]
      pub enum UntypedElementValue {
        ComponentModel(WitValue),
        UnstructuredText(TextReference),
        UnstructuredBinary(BinaryReference),
      }
      impl ::core::fmt::Debug for UntypedElementValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UntypedElementValue::ComponentModel(e) => {
              f.debug_tuple("UntypedElementValue::ComponentModel").field(e).finish()
            }
            UntypedElementValue::UnstructuredText(e) => {
              f.debug_tuple("UntypedElementValue::UnstructuredText").field(e).finish()
            }
            UntypedElementValue::UnstructuredBinary(e) => {
              f.debug_tuple("UntypedElementValue::UnstructuredBinary").field(e).finish()
            }
          }
        }
      }
      /// A named untyped element value, used in multimodal data values
      #[derive(Clone)]
      pub struct UntypedNamedElementValue {
        pub name: _rt::String,
        pub value: UntypedElementValue,
      }
      impl ::core::fmt::Debug for UntypedNamedElementValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("UntypedNamedElementValue").field("name", &self.name).field("value", &self.value).finish()
        }
      }
      /// An untyped data value, representing either a tuple of elements or a multimodal set of named elements
      #[derive(Clone)]
      pub enum UntypedDataValue {
        Tuple(_rt::Vec::<UntypedElementValue>),
        Multimodal(_rt::Vec::<UntypedNamedElementValue>),
      }
      impl ::core::fmt::Debug for UntypedDataValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UntypedDataValue::Tuple(e) => {
              f.debug_tuple("UntypedDataValue::Tuple").field(e).finish()
            }
            UntypedDataValue::Multimodal(e) => {
              f.debug_tuple("UntypedDataValue::Multimodal").field(e).finish()
            }
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Parses a UUID from a string
      #[allow(async_fn_in_trait)]
      pub fn parse_uuid(uuid: &str,) -> Result<Uuid,_rt::String>{
        unsafe {

          #[repr(align(8))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
          let vec0 = uuid;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "golem:core/types@1.5.0")]
          unsafe extern "C" {
            #[link_name = "parse-uuid"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import2(ptr0.cast_mut(), len0, ptr1);
          let l3 = i32::from(*ptr1.add(0).cast::<u8>());
          let result9 = match l3 {
            0 => {
              let e = {
                let l4 = *ptr1.add(8).cast::<i64>();
                let l5 = *ptr1.add(16).cast::<i64>();

                Uuid{
                  high_bits: l4 as u64,
                  low_bits: l5 as u64,
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l6 = *ptr1.add(8).cast::<*mut u8>();
                let l7 = *ptr1.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len8 = l7;
                let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);

                _rt::string_lift(bytes8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result9
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Converts a UUID to a string
      #[allow(async_fn_in_trait)]
      pub fn uuid_to_string(uuid: Uuid,) -> _rt::String{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let Uuid{ high_bits:high_bits0, low_bits:low_bits0, } = uuid;
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "golem:core/types@1.5.0")]
          unsafe extern "C" {
            #[link_name = "uuid-to-string"]
            fn wit_import2(_: i64, _: i64, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: i64, _: i64, _: *mut u8, ){ unreachable!() }
          wit_import2(_rt::as_i64(high_bits0), _rt::as_i64(low_bits0), ptr1);
          let l3 = *ptr1.add(0).cast::<*mut u8>();
          let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let len5 = l4;
          let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
          let result6 = _rt::string_lift(bytes5);
          result6
        }
      }

    }

  }
}
mod _rt {
  #![allow(dead_code, clippy::all)]
  pub use alloc_crate::string::String;
  pub use alloc_crate::vec::Vec;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      unsafe { String::from_utf8_unchecked(bytes) }
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      unsafe { core::hint::unreachable_unchecked() }
    }
  }
  
  pub fn as_i64<T: AsI64>(t: T) -> i64 {
    t.as_i64()
  }

  pub trait AsI64 {
    fn as_i64(self) -> i64;
  }

  impl<'a, T: Copy + AsI64> AsI64 for &'a T {
    fn as_i64(self) -> i64 {
      (*self).as_i64()
    }
  }
  
  impl AsI64 for i64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  impl AsI64 for u64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  extern crate alloc as alloc_crate;
}

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.42.1:golem:rpc:wasm-rpc:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 2091] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xac\x0f\x01A\x02\x01\
A\x06\x01BM\x01r\x02\x09high-bitsw\x08low-bitsw\x04\0\x04uuid\x03\0\0\x01r\x01\x04\
uuid\x01\x04\0\x0ccomponent-id\x03\0\x02\x01r\x02\x0ccomponent-id\x03\x08agent-i\
ds\x04\0\x08agent-id\x03\0\x04\x01r\x01\x04uuid\x01\x04\0\x0aaccount-id\x03\0\x06\
\x01w\x04\0\x0boplog-index\x03\0\x08\x01r\x02\x08agent-id\x05\x09oplog-idx\x09\x04\
\0\x0apromise-id\x03\0\x0a\x01z\x04\0\x0anode-index\x03\0\x0c\x01w\x04\0\x0breso\
urce-id\x03\0\x0e\x01m\x02\x05owned\x08borrowed\x04\0\x0dresource-mode\x03\0\x10\
\x01o\x02s\x0d\x01p\x12\x01k\x0d\x01o\x02s\x14\x01p\x15\x01ps\x01p\x0d\x01o\x02\x14\
\x14\x01o\x02\x0f\x11\x01q\x16\x0brecord-type\x01\x13\0\x0cvariant-type\x01\x16\0\
\x09enum-type\x01\x17\0\x0aflags-type\x01\x17\0\x0atuple-type\x01\x18\0\x09list-\
type\x01\x0d\0\x0boption-type\x01\x0d\0\x0bresult-type\x01\x19\0\x0cprim-u8-type\
\0\0\x0dprim-u16-type\0\0\x0dprim-u32-type\0\0\x0dprim-u64-type\0\0\x0cprim-s8-t\
ype\0\0\x0dprim-s16-type\0\0\x0dprim-s32-type\0\0\x0dprim-s64-type\0\0\x0dprim-f\
32-type\0\0\x0dprim-f64-type\0\0\x0eprim-char-type\0\0\x0eprim-bool-type\0\0\x10\
prim-string-type\0\0\x0bhandle-type\x01\x1a\0\x04\0\x0dwit-type-node\x03\0\x1b\x01\
ks\x01r\x03\x04name\x1d\x05owner\x1d\x04type\x1c\x04\0\x13named-wit-type-node\x03\
\0\x1e\x01p\x1f\x01r\x01\x05nodes\x20\x04\0\x08wit-type\x03\0!\x01r\x01\x05value\
s\x04\0\x03uri\x03\0#\x01o\x02y\x14\x01p\x7f\x01j\x01\x14\x01\x14\x01o\x02$w\x01\
q\x16\x0crecord-value\x01\x18\0\x0dvariant-value\x01%\0\x0aenum-value\x01y\0\x0b\
flags-value\x01&\0\x0btuple-value\x01\x18\0\x0alist-value\x01\x18\0\x0coption-va\
lue\x01\x14\0\x0cresult-value\x01'\0\x07prim-u8\x01}\0\x08prim-u16\x01{\0\x08pri\
m-u32\x01y\0\x08prim-u64\x01w\0\x07prim-s8\x01~\0\x08prim-s16\x01|\0\x08prim-s32\
\x01z\0\x08prim-s64\x01x\0\x0cprim-float32\x01v\0\x0cprim-float64\x01u\0\x09prim\
-char\x01t\0\x09prim-bool\x01\x7f\0\x0bprim-string\x01s\0\x06handle\x01(\0\x04\0\
\x08wit-node\x03\0)\x01p*\x01r\x01\x05nodes+\x04\0\x09wit-value\x03\0,\x01r\x02\x05\
value-\x03typ\"\x04\0\x0evalue-and-type\x03\0.\x01s\x04\0\x03url\x03\00\x01r\x01\
\x0dlanguage-codes\x04\0\x09text-type\x03\02\x01k3\x01r\x02\x04datas\x09text-typ\
e4\x04\0\x0btext-source\x03\05\x01q\x02\x03url\x01s\0\x06inline\x016\0\x04\0\x0e\
text-reference\x03\07\x01r\x01\x09mime-types\x04\0\x0bbinary-type\x03\09\x01p}\x01\
r\x02\x04data;\x0bbinary-type:\x04\0\x0dbinary-source\x03\0<\x01q\x02\x03url\x01\
1\0\x06inline\x01=\0\x04\0\x10binary-reference\x03\0>\x01q\x03\x0fcomponent-mode\
l\x01-\0\x11unstructured-text\x018\0\x13unstructured-binary\x01?\0\x04\0\x15unty\
ped-element-value\x03\0@\x01r\x02\x04names\x05value\xc1\0\x04\0\x1buntyped-named\
-element-value\x03\0B\x01p\xc1\0\x01p\xc3\0\x01q\x02\x05tuple\x01\xc4\0\0\x0amul\
timodal\x01\xc5\0\0\x04\0\x12untyped-data-value\x03\0F\x01j\x01\x01\x01s\x01@\x01\
\x04uuids\0\xc8\0\x04\0\x0aparse-uuid\x01I\x01@\x01\x04uuid\x01\0s\x04\0\x0euuid\
-to-string\x01J\x03\0\x16golem:core/types@1.5.0\x05\0\x01B\x05\x01r\x02\x07secon\
dsw\x0bnanosecondsy\x04\0\x08datetime\x03\0\0\x01@\0\0\x01\x04\0\x03now\x01\x02\x04\
\0\x0aresolution\x01\x02\x03\0\x1cwasi:clocks/wall-clock@0.2.3\x05\x01\x01B\x0a\x04\
\0\x08pollable\x03\x01\x01h\0\x01@\x01\x04self\x01\0\x7f\x04\0\x16[method]pollab\
le.ready\x01\x02\x01@\x01\x04self\x01\x01\0\x04\0\x16[method]pollable.block\x01\x03\
\x01p\x01\x01py\x01@\x01\x02in\x04\0\x05\x04\0\x04poll\x01\x06\x03\0\x12wasi:io/\
poll@0.2.3\x05\x02\x04\0\x12golem:rpc/wasm-rpc\x04\0\x0b\x0e\x01\0\x08wasm-rpc\x03\
\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.230.0\x10wit-\
bindgen-rust\x060.42.1";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen_rt::maybe_link_cabi_realloc();
}


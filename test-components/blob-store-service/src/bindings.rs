// Generated by `wit-bindgen` 0.16.0. DO NOT EDIT!
pub mod wasi {
  pub mod blobstore {
    
    #[allow(clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type InputStream = super::super::super::wasi::io::streams::InputStream;
      pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
      /// name of a container, a collection of objects.
      /// The container name may be any valid UTF-8 string.
      pub type ContainerName = wit_bindgen::rt::string::String;
      /// name of an object within a container
      /// The object name may be any valid UTF-8 string.
      pub type ObjectName = wit_bindgen::rt::string::String;
      /// TODO: define timestamp to include seconds since
      /// Unix epoch and nanoseconds
      /// https://github.com/WebAssembly/wasi-blob-store/issues/7
      pub type Timestamp = u64;
      /// size of an object, in bytes
      pub type ObjectSize = u64;
      pub type Error = wit_bindgen::rt::string::String;
      /// information about a container
      #[derive(Clone)]
      pub struct ContainerMetadata {
        /// the container's name
        pub name: ContainerName,
        /// date and time container was created
        pub created_at: Timestamp,
      }
      impl ::core::fmt::Debug for ContainerMetadata {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ContainerMetadata").field("name", &self.name).field("created-at", &self.created_at).finish()
        }
      }
      /// information about an object
      #[derive(Clone)]
      pub struct ObjectMetadata {
        /// the object's name
        pub name: ObjectName,
        /// the object's parent container
        pub container: ContainerName,
        /// date and time the object was created
        pub created_at: Timestamp,
        /// size of the object, in bytes
        pub size: ObjectSize,
      }
      impl ::core::fmt::Debug for ObjectMetadata {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ObjectMetadata").field("name", &self.name).field("container", &self.container).field("created-at", &self.created_at).field("size", &self.size).finish()
        }
      }
      /// identifier for an object that includes its container name
      #[derive(Clone)]
      pub struct ObjectId {
        pub container: ContainerName,
        pub object: ObjectName,
      }
      impl ::core::fmt::Debug for ObjectId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ObjectId").field("container", &self.container).field("object", &self.object).finish()
        }
      }
      /// A data is the data stored in a data blob. The value can be of any type
      /// that can be represented in a byte array. It provides a way to write the value
      /// to the output-stream defined in the `wasi-io` interface.
      /// Soon: switch to `resource value { ... }`
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct OutgoingValue{
        handle: wit_bindgen::rt::Resource<OutgoingValue>,
      }
      
      impl OutgoingValue{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for OutgoingValue{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:blobstore/types")]
            extern "C" {
              #[link_name = "[resource-drop]outgoing-value"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      /// A incoming-value is a wrapper around a value. It provides a way to read the value
      /// from the input-stream defined in the `wasi-io` interface.
      /// 
      /// The incoming-value provides two ways to consume the value:
      /// 1. `incoming-value-consume-sync` consumes the value synchronously and returns the
      /// value as a list of bytes.
      /// 2. `incoming-value-consume-async` consumes the value asynchronously and returns the
      /// value as an input-stream.
      /// Soon: switch to `resource incoming-value { ... }`
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct IncomingValue{
        handle: wit_bindgen::rt::Resource<IncomingValue>,
      }
      
      impl IncomingValue{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for IncomingValue{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:blobstore/types")]
            extern "C" {
              #[link_name = "[resource-drop]incoming-value"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      pub type IncomingValueAsyncBody = InputStream;
      pub type IncomingValueSyncBody = wit_bindgen::rt::vec::Vec::<u8>;
      impl OutgoingValue {
        #[allow(unused_unsafe, clippy::all)]
        pub fn new_outgoing_value() -> OutgoingValue{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/types")]
            extern "C" {
              #[link_name = "[static]outgoing-value.new-outgoing-value"]
              fn wit_import() -> i32;
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import() -> i32{ unreachable!() }
            let ret = wit_import();
            OutgoingValue::from_handle(ret as u32)
          }
        }
      }
      impl OutgoingValue {
        #[allow(unused_unsafe, clippy::all)]
        pub fn outgoing_value_write_body(&self,) -> Result<OutputStream,()>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 8]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/types")]
            extern "C" {
              #[link_name = "[method]outgoing-value.outgoing-value-write-body"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  
                  super::super::super::wasi::io::streams::OutputStream::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = ();
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl IncomingValue {
        #[allow(unused_unsafe, clippy::all)]
        pub fn incoming_value_consume_sync(&self,) -> Result<IncomingValueSyncBody,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/types")]
            extern "C" {
              #[link_name = "[method]incoming-value.incoming-value-consume-sync"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  let l3 = *((ptr0 + 8) as *const i32);
                  let len4 = l3 as usize;
                  
                  Vec::from_raw_parts(l2 as *mut _, len4, len4)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = *((ptr0 + 4) as *const i32);
                  let l6 = *((ptr0 + 8) as *const i32);
                  let len7 = l6 as usize;
                  let bytes7 = Vec::from_raw_parts(l5 as *mut _, len7, len7);
                  
                  wit_bindgen::rt::string_lift(bytes7)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl IncomingValue {
        #[allow(unused_unsafe, clippy::all)]
        pub fn incoming_value_consume_async(&self,) -> Result<IncomingValueAsyncBody,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/types")]
            extern "C" {
              #[link_name = "[method]incoming-value.incoming-value-consume-async"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  
                  super::super::super::wasi::io::streams::InputStream::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = *((ptr0 + 4) as *const i32);
                  let l4 = *((ptr0 + 8) as *const i32);
                  let len5 = l4 as usize;
                  let bytes5 = Vec::from_raw_parts(l3 as *mut _, len5, len5);
                  
                  wit_bindgen::rt::string_lift(bytes5)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl IncomingValue {
        #[allow(unused_unsafe, clippy::all)]
        pub fn size(&self,) -> u64{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/types")]
            extern "C" {
              #[link_name = "[method]incoming-value.size"]
              fn wit_import(_: i32, ) -> i64;
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i64{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            ret as u64
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod container {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type ContainerMetadata = super::super::super::wasi::blobstore::types::ContainerMetadata;
      pub type Error = super::super::super::wasi::blobstore::types::Error;
      pub type IncomingValue = super::super::super::wasi::blobstore::types::IncomingValue;
      pub type ObjectMetadata = super::super::super::wasi::blobstore::types::ObjectMetadata;
      pub type ObjectName = super::super::super::wasi::blobstore::types::ObjectName;
      pub type OutgoingValue = super::super::super::wasi::blobstore::types::OutgoingValue;
      /// this defines the `container` resource
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Container{
        handle: wit_bindgen::rt::Resource<Container>,
      }
      
      impl Container{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for Container{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[resource-drop]container"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      /// this defines the `stream-object-names` resource which is a representation of stream<object-name>
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct StreamObjectNames{
        handle: wit_bindgen::rt::Resource<StreamObjectNames>,
      }
      
      impl StreamObjectNames{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for StreamObjectNames{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[resource-drop]stream-object-names"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      impl Container {
        #[allow(unused_unsafe, clippy::all)]
        /// returns container name
        pub fn name(&self,) -> Result<wit_bindgen::rt::string::String,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]container.name"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  let l3 = *((ptr0 + 8) as *const i32);
                  let len4 = l3 as usize;
                  let bytes4 = Vec::from_raw_parts(l2 as *mut _, len4, len4);
                  
                  wit_bindgen::rt::string_lift(bytes4)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = *((ptr0 + 4) as *const i32);
                  let l6 = *((ptr0 + 8) as *const i32);
                  let len7 = l6 as usize;
                  let bytes7 = Vec::from_raw_parts(l5 as *mut _, len7, len7);
                  
                  wit_bindgen::rt::string_lift(bytes7)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Container {
        #[allow(unused_unsafe, clippy::all)]
        /// returns container metadata
        pub fn info(&self,) -> Result<ContainerMetadata,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 24]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]container.info"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i32);
                  let l3 = *((ptr0 + 12) as *const i32);
                  let len4 = l3 as usize;
                  let bytes4 = Vec::from_raw_parts(l2 as *mut _, len4, len4);
                  let l5 = *((ptr0 + 16) as *const i64);
                  
                  super::super::super::wasi::blobstore::types::ContainerMetadata{
                    name: wit_bindgen::rt::string_lift(bytes4),
                    created_at: l5 as u64,
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = *((ptr0 + 8) as *const i32);
                  let l7 = *((ptr0 + 12) as *const i32);
                  let len8 = l7 as usize;
                  let bytes8 = Vec::from_raw_parts(l6 as *mut _, len8, len8);
                  
                  wit_bindgen::rt::string_lift(bytes8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Container {
        #[allow(unused_unsafe, clippy::all)]
        /// retrieves an object or portion of an object, as a resource.
        /// Start and end offsets are inclusive.
        /// Once a data-blob resource has been created, the underlying bytes are held by the blobstore service for the lifetime
        /// of the data-blob resource, even if the object they came from is later deleted.
        pub fn get_data(&self,name: &ObjectName,start: u64,end: u64,) -> Result<IncomingValue,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = name;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]container.get-data"]
              fn wit_import(_: i32, _: i32, _: i32, _: i64, _: i64, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i64, _: i64, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, wit_bindgen::rt::as_i64(start), wit_bindgen::rt::as_i64(end), ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = {
                  let l3 = *((ptr1 + 4) as *const i32);
                  
                  super::super::super::wasi::blobstore::types::IncomingValue::from_handle(l3 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = *((ptr1 + 4) as *const i32);
                  let l5 = *((ptr1 + 8) as *const i32);
                  let len6 = l5 as usize;
                  let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                  
                  wit_bindgen::rt::string_lift(bytes6)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Container {
        #[allow(unused_unsafe, clippy::all)]
        /// creates or replaces an object with the data blob.
        pub fn write_data(&self,name: &ObjectName,data: &OutgoingValue,) -> Result<(),Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = name;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]container.write-data"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, (data).handle() as i32, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = *((ptr1 + 4) as *const i32);
                  let l4 = *((ptr1 + 8) as *const i32);
                  let len5 = l4 as usize;
                  let bytes5 = Vec::from_raw_parts(l3 as *mut _, len5, len5);
                  
                  wit_bindgen::rt::string_lift(bytes5)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Container {
        #[allow(unused_unsafe, clippy::all)]
        /// returns list of objects in the container. Order is undefined.
        pub fn list_objects(&self,) -> Result<StreamObjectNames,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]container.list-objects"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  
                  StreamObjectNames::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = *((ptr0 + 4) as *const i32);
                  let l4 = *((ptr0 + 8) as *const i32);
                  let len5 = l4 as usize;
                  let bytes5 = Vec::from_raw_parts(l3 as *mut _, len5, len5);
                  
                  wit_bindgen::rt::string_lift(bytes5)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Container {
        #[allow(unused_unsafe, clippy::all)]
        /// deletes object.
        /// does not return error if object did not exist.
        pub fn delete_object(&self,name: &ObjectName,) -> Result<(),Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = name;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]container.delete-object"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = *((ptr1 + 4) as *const i32);
                  let l4 = *((ptr1 + 8) as *const i32);
                  let len5 = l4 as usize;
                  let bytes5 = Vec::from_raw_parts(l3 as *mut _, len5, len5);
                  
                  wit_bindgen::rt::string_lift(bytes5)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Container {
        #[allow(unused_unsafe, clippy::all)]
        /// deletes multiple objects in the container
        pub fn delete_objects(&self,names: &[ObjectName],) -> Result<(),Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec1 = names;
            let len1 = vec1.len() as i32;
            let layout1 = alloc::Layout::from_size_align_unchecked(vec1.len() * 8, 4);
            let result1 = if layout1.size() != 0
            {
              let ptr = alloc::alloc(layout1);
              if ptr.is_null()
              {
                alloc::handle_alloc_error(layout1);
              }
              ptr
            }else {{
              ::core::ptr::null_mut()
            }};
            for (i, e) in vec1.into_iter().enumerate() {
              let base = result1 as i32 + (i as i32) * 8;
              {
                let vec0 = e;
                let ptr0 = vec0.as_ptr() as i32;
                let len0 = vec0.len() as i32;
                *((base + 4) as *mut i32) = len0;
                *((base + 0) as *mut i32) = ptr0;
              }
            }
            let ptr2 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]container.delete-objects"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, result1 as i32, len1, ptr2);
            let l3 = i32::from(*((ptr2 + 0) as *const u8));
            if layout1.size() != 0 {
              alloc::dealloc(result1, layout1);
            }
            match l3 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = *((ptr2 + 4) as *const i32);
                  let l5 = *((ptr2 + 8) as *const i32);
                  let len6 = l5 as usize;
                  let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                  
                  wit_bindgen::rt::string_lift(bytes6)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Container {
        #[allow(unused_unsafe, clippy::all)]
        /// returns true if the object exists in this container
        pub fn has_object(&self,name: &ObjectName,) -> Result<bool,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = name;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]container.has-object"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = {
                  let l3 = i32::from(*((ptr1 + 4) as *const u8));
                  
                  wit_bindgen::rt::bool_lift(l3 as u8)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = *((ptr1 + 4) as *const i32);
                  let l5 = *((ptr1 + 8) as *const i32);
                  let len6 = l5 as usize;
                  let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                  
                  wit_bindgen::rt::string_lift(bytes6)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Container {
        #[allow(unused_unsafe, clippy::all)]
        /// returns metadata for the object
        pub fn object_info(&self,name: &ObjectName,) -> Result<ObjectMetadata,Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 40]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = name;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]container.object-info"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = {
                  let l3 = *((ptr1 + 8) as *const i32);
                  let l4 = *((ptr1 + 12) as *const i32);
                  let len5 = l4 as usize;
                  let bytes5 = Vec::from_raw_parts(l3 as *mut _, len5, len5);
                  let l6 = *((ptr1 + 16) as *const i32);
                  let l7 = *((ptr1 + 20) as *const i32);
                  let len8 = l7 as usize;
                  let bytes8 = Vec::from_raw_parts(l6 as *mut _, len8, len8);
                  let l9 = *((ptr1 + 24) as *const i64);
                  let l10 = *((ptr1 + 32) as *const i64);
                  
                  super::super::super::wasi::blobstore::types::ObjectMetadata{
                    name: wit_bindgen::rt::string_lift(bytes5),
                    container: wit_bindgen::rt::string_lift(bytes8),
                    created_at: l9 as u64,
                    size: l10 as u64,
                  }
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l11 = *((ptr1 + 8) as *const i32);
                  let l12 = *((ptr1 + 12) as *const i32);
                  let len13 = l12 as usize;
                  let bytes13 = Vec::from_raw_parts(l11 as *mut _, len13, len13);
                  
                  wit_bindgen::rt::string_lift(bytes13)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl Container {
        #[allow(unused_unsafe, clippy::all)]
        /// removes all objects within the container, leaving the container empty.
        pub fn clear(&self,) -> Result<(),Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]container.clear"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  let l3 = *((ptr0 + 8) as *const i32);
                  let len4 = l3 as usize;
                  let bytes4 = Vec::from_raw_parts(l2 as *mut _, len4, len4);
                  
                  wit_bindgen::rt::string_lift(bytes4)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl StreamObjectNames {
        #[allow(unused_unsafe, clippy::all)]
        /// reads the next number of objects from the stream
        /// 
        /// This function returns the list of objects read, and a boolean indicating if the end of the stream was reached.
        pub fn read_stream_object_names(&self,len: u64,) -> Result<(wit_bindgen::rt::vec::Vec::<ObjectName>,bool,),Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]stream-object-names.read-stream-object-names"]
              fn wit_import(_: i32, _: i64, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  let l3 = *((ptr0 + 8) as *const i32);
                  let base7 = l2;
                  let len7 = l3;
                  let mut result7 = Vec::with_capacity(len7 as usize);
                  for i in 0..len7 {
                    let base = base7 + i * 8;
                    let e7 = {
                      let l4 = *((base + 0) as *const i32);
                      let l5 = *((base + 4) as *const i32);
                      let len6 = l5 as usize;
                      let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                      
                      wit_bindgen::rt::string_lift(bytes6)
                    };
                    result7.push(e7);
                  }
                  wit_bindgen::rt::dealloc(base7, (len7 as usize) * 8, 4);
                  let l8 = i32::from(*((ptr0 + 12) as *const u8));
                  
                  (result7, wit_bindgen::rt::bool_lift(l8 as u8))
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l9 = *((ptr0 + 4) as *const i32);
                  let l10 = *((ptr0 + 8) as *const i32);
                  let len11 = l10 as usize;
                  let bytes11 = Vec::from_raw_parts(l9 as *mut _, len11, len11);
                  
                  wit_bindgen::rt::string_lift(bytes11)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl StreamObjectNames {
        #[allow(unused_unsafe, clippy::all)]
        /// skip the next number of objects in the stream
        /// 
        /// This function returns the number of objects skipped, and a boolean indicating if the end of the stream was reached.
        pub fn skip_stream_object_names(&self,num: u64,) -> Result<(u64,bool,),Error>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 24]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:blobstore/container")]
            extern "C" {
              #[link_name = "[method]stream-object-names.skip-stream-object-names"]
              fn wit_import(_: i32, _: i64, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(num), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i64);
                  let l3 = i32::from(*((ptr0 + 16) as *const u8));
                  
                  (l2 as u64, wit_bindgen::rt::bool_lift(l3 as u8))
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = *((ptr0 + 8) as *const i32);
                  let l5 = *((ptr0 + 12) as *const i32);
                  let len6 = l5 as usize;
                  let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                  
                  wit_bindgen::rt::string_lift(bytes6)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod blobstore {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type Container = super::super::super::wasi::blobstore::container::Container;
      pub type Error = super::super::super::wasi::blobstore::types::Error;
      pub type ContainerName = super::super::super::wasi::blobstore::types::ContainerName;
      pub type ObjectId = super::super::super::wasi::blobstore::types::ObjectId;
      #[allow(unused_unsafe, clippy::all)]
      /// creates a new empty container
      pub fn create_container(name: &ContainerName,) -> Result<Container,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 12]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = name;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let ptr1 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:blobstore/blobstore")]
          extern "C" {
            #[link_name = "create-container"]
            fn wit_import(_: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1);
          let l2 = i32::from(*((ptr1 + 0) as *const u8));
          match l2 {
            0 => {
              let e = {
                let l3 = *((ptr1 + 4) as *const i32);
                
                super::super::super::wasi::blobstore::container::Container::from_handle(l3 as u32)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = *((ptr1 + 4) as *const i32);
                let l5 = *((ptr1 + 8) as *const i32);
                let len6 = l5 as usize;
                let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                
                wit_bindgen::rt::string_lift(bytes6)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// retrieves a container by name
      pub fn get_container(name: &ContainerName,) -> Result<Container,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 12]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = name;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let ptr1 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:blobstore/blobstore")]
          extern "C" {
            #[link_name = "get-container"]
            fn wit_import(_: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1);
          let l2 = i32::from(*((ptr1 + 0) as *const u8));
          match l2 {
            0 => {
              let e = {
                let l3 = *((ptr1 + 4) as *const i32);
                
                super::super::super::wasi::blobstore::container::Container::from_handle(l3 as u32)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = *((ptr1 + 4) as *const i32);
                let l5 = *((ptr1 + 8) as *const i32);
                let len6 = l5 as usize;
                let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                
                wit_bindgen::rt::string_lift(bytes6)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// deletes a container and all objects within it
      pub fn delete_container(name: &ContainerName,) -> Result<(),Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 12]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = name;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let ptr1 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:blobstore/blobstore")]
          extern "C" {
            #[link_name = "delete-container"]
            fn wit_import(_: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1);
          let l2 = i32::from(*((ptr1 + 0) as *const u8));
          match l2 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l3 = *((ptr1 + 4) as *const i32);
                let l4 = *((ptr1 + 8) as *const i32);
                let len5 = l4 as usize;
                let bytes5 = Vec::from_raw_parts(l3 as *mut _, len5, len5);
                
                wit_bindgen::rt::string_lift(bytes5)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// returns true if the container exists
      pub fn container_exists(name: &ContainerName,) -> Result<bool,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 12]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = name;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let ptr1 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:blobstore/blobstore")]
          extern "C" {
            #[link_name = "container-exists"]
            fn wit_import(_: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr0, len0, ptr1);
          let l2 = i32::from(*((ptr1 + 0) as *const u8));
          match l2 {
            0 => {
              let e = {
                let l3 = i32::from(*((ptr1 + 4) as *const u8));
                
                wit_bindgen::rt::bool_lift(l3 as u8)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = *((ptr1 + 4) as *const i32);
                let l5 = *((ptr1 + 8) as *const i32);
                let len6 = l5 as usize;
                let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                
                wit_bindgen::rt::string_lift(bytes6)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// copies (duplicates) an object, to the same or a different container.
      /// returns an error if the target container does not exist.
      /// overwrites destination object if it already existed.
      pub fn copy_object(src: &ObjectId,dest: &ObjectId,) -> Result<(),Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 12]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let super::super::super::wasi::blobstore::types::ObjectId{ container:container0, object:object0, } = src;
          let vec1 = container0;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec2 = object0;
          let ptr2 = vec2.as_ptr() as i32;
          let len2 = vec2.len() as i32;
          let super::super::super::wasi::blobstore::types::ObjectId{ container:container3, object:object3, } = dest;
          let vec4 = container3;
          let ptr4 = vec4.as_ptr() as i32;
          let len4 = vec4.len() as i32;
          let vec5 = object3;
          let ptr5 = vec5.as_ptr() as i32;
          let len5 = vec5.len() as i32;
          let ptr6 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:blobstore/blobstore")]
          extern "C" {
            #[link_name = "copy-object"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr1, len1, ptr2, len2, ptr4, len4, ptr5, len5, ptr6);
          let l7 = i32::from(*((ptr6 + 0) as *const u8));
          match l7 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l8 = *((ptr6 + 4) as *const i32);
                let l9 = *((ptr6 + 8) as *const i32);
                let len10 = l9 as usize;
                let bytes10 = Vec::from_raw_parts(l8 as *mut _, len10, len10);
                
                wit_bindgen::rt::string_lift(bytes10)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// moves or renames an object, to the same or a different container
      /// returns an error if the destination container does not exist.
      /// overwrites destination object if it already existed.
      pub fn move_object(src: &ObjectId,dest: &ObjectId,) -> Result<(),Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 12]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let super::super::super::wasi::blobstore::types::ObjectId{ container:container0, object:object0, } = src;
          let vec1 = container0;
          let ptr1 = vec1.as_ptr() as i32;
          let len1 = vec1.len() as i32;
          let vec2 = object0;
          let ptr2 = vec2.as_ptr() as i32;
          let len2 = vec2.len() as i32;
          let super::super::super::wasi::blobstore::types::ObjectId{ container:container3, object:object3, } = dest;
          let vec4 = container3;
          let ptr4 = vec4.as_ptr() as i32;
          let len4 = vec4.len() as i32;
          let vec5 = object3;
          let ptr5 = vec5.as_ptr() as i32;
          let len5 = vec5.len() as i32;
          let ptr6 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:blobstore/blobstore")]
          extern "C" {
            #[link_name = "move-object"]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(ptr1, len1, ptr2, len2, ptr4, len4, ptr5, len5, ptr6);
          let l7 = i32::from(*((ptr6 + 0) as *const u8));
          match l7 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l8 = *((ptr6 + 4) as *const i32);
                let l9 = *((ptr6 + 8) as *const i32);
                let len10 = l9 as usize;
                let bytes10 = Vec::from_raw_parts(l8 as *mut _, len10, len10);
                
                wit_bindgen::rt::string_lift(bytes10)
              };
              Err(e)
            }
            _ => wit_bindgen::rt::invalid_enum_discriminant(),
          }
        }
      }
      
    }
    
  }
  pub mod io {
    
    #[allow(clippy::all)]
    pub mod error {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      /// A resource which represents some error information.
      /// 
      /// The only method provided by this resource is `to-debug-string`,
      /// which provides some human-readable information about the error.
      /// 
      /// In the `wasi:io` package, this resource is returned through the
      /// `wasi:io/streams/stream-error` type.
      /// 
      /// To provide more specific error information, other interfaces may
      /// provide functions to further "downcast" this error into more specific
      /// error information. For example, `error`s returned in streams derived
      /// from filesystem types to be described using the filesystem's own
      /// error-code type, using the function
      /// `wasi:filesystem/types/filesystem-error-code`, which takes a parameter
      /// `borrow<error>` and returns
      /// `option<wasi:filesystem/types/error-code>`.
      /// 
      /// The set of functions which can "downcast" an `error` into a more
      /// concrete type is open.
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Error{
        handle: wit_bindgen::rt::Resource<Error>,
      }
      
      impl Error{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for Error{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:io/error@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]error"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      impl Error {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns a string that is suitable to assist humans in debugging
        /// this error.
        /// 
        /// WARNING: The returned string should not be consumed mechanically!
        /// It may change across platforms, hosts, or other implementation
        /// details. Parsing this string is a major platform-compatibility
        /// hazard.
        pub fn to_debug_string(&self,) -> wit_bindgen::rt::string::String{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 8]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/error@0.2.0")]
            extern "C" {
              #[link_name = "[method]error.to-debug-string"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = *((ptr0 + 0) as *const i32);
            let l2 = *((ptr0 + 4) as *const i32);
            let len3 = l2 as usize;
            let bytes3 = Vec::from_raw_parts(l1 as *mut _, len3, len3);
            wit_bindgen::rt::string_lift(bytes3)
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod poll {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      /// `pollable` epresents a single I/O event which may be ready, or not.
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Pollable{
        handle: wit_bindgen::rt::Resource<Pollable>,
      }
      
      impl Pollable{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for Pollable{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]pollable"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      impl Pollable {
        #[allow(unused_unsafe, clippy::all)]
        /// Return the readiness of a pollable. This function never blocks.
        /// 
        /// Returns `true` when the pollable is ready, and `false` otherwise.
        pub fn ready(&self,) -> bool{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
            extern "C" {
              #[link_name = "[method]pollable.ready"]
              fn wit_import(_: i32, ) -> i32;
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            wit_bindgen::rt::bool_lift(ret as u8)
          }
        }
      }
      impl Pollable {
        #[allow(unused_unsafe, clippy::all)]
        /// `block` returns immediately if the pollable is ready, and otherwise
        /// blocks until ready.
        /// 
        /// This function is equivalent to calling `poll.poll` on a list
        /// containing only this pollable.
        pub fn block(&self,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
            extern "C" {
              #[link_name = "[method]pollable.block"]
              fn wit_import(_: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ){ unreachable!() }
            wit_import((self).handle() as i32);
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Poll for completion on a set of pollables.
      /// 
      /// This function takes a list of pollables, which identify I/O sources of
      /// interest, and waits until one or more of the events is ready for I/O.
      /// 
      /// The result `list<u32>` contains one or more indices of handles in the
      /// argument list that is ready for I/O.
      /// 
      /// If the list contains more elements than can be indexed with a `u32`
      /// value, this function traps.
      /// 
      /// A timeout can be implemented by adding a pollable from the
      /// wasi-clocks API to the list.
      /// 
      /// This function does not return a `result`; polling in itself does not
      /// do any I/O so it doesn't fail. If any of the I/O sources identified by
      /// the pollables has an error, it is indicated by marking the source as
      /// being reaedy for I/O.
      pub fn poll(in_: &[&Pollable],) -> wit_bindgen::rt::vec::Vec::<u32>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 8]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = in_;
          let len0 = vec0.len() as i32;
          let layout0 = alloc::Layout::from_size_align_unchecked(vec0.len() * 4, 4);
          let result0 = if layout0.size() != 0
          {
            let ptr = alloc::alloc(layout0);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout0);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec0.into_iter().enumerate() {
            let base = result0 as i32 + (i as i32) * 4;
            {
              *((base + 0) as *mut i32) = (e).handle() as i32;
            }
          }
          let ptr1 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
          extern "C" {
            #[link_name = "poll"]
            fn wit_import(_: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(result0 as i32, len0, ptr1);
          let l2 = *((ptr1 + 0) as *const i32);
          let l3 = *((ptr1 + 4) as *const i32);
          let len4 = l3 as usize;
          if layout0.size() != 0 {
            alloc::dealloc(result0, layout0);
          }
          Vec::from_raw_parts(l2 as *mut _, len4, len4)
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod streams {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type Error = super::super::super::wasi::io::error::Error;
      pub type Pollable = super::super::super::wasi::io::poll::Pollable;
      /// An error for input-stream and output-stream operations.
      pub enum StreamError{
        /// The last operation (a write or flush) failed before completion.
        /// 
        /// More information is available in the `error` payload.
        LastOperationFailed(Error),
        /// The stream is closed: no more input will be accepted by the
        /// stream. A closed output-stream will return this error on all
        /// future operations.
        Closed,
      }
      impl ::core::fmt::Debug for StreamError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            StreamError::LastOperationFailed(e) => {
              f.debug_tuple("StreamError::LastOperationFailed").field(e).finish()
            }
            StreamError::Closed => {
              f.debug_tuple("StreamError::Closed").finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for StreamError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      
      impl std::error::Error for StreamError {}
      /// An input bytestream.
      /// 
      /// `input-stream`s are *non-blocking* to the extent practical on underlying
      /// platforms. I/O operations always return promptly; if fewer bytes are
      /// promptly available than requested, they return the number of bytes promptly
      /// available, which could even be zero. To wait for data to be available,
      /// use the `subscribe` function to obtain a `pollable` which can be polled
      /// for using `wasi:io/poll`.
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct InputStream{
        handle: wit_bindgen::rt::Resource<InputStream>,
      }
      
      impl InputStream{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for InputStream{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]input-stream"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      /// An output bytestream.
      /// 
      /// `output-stream`s are *non-blocking* to the extent practical on
      /// underlying platforms. Except where specified otherwise, I/O operations also
      /// always return promptly, after the number of bytes that can be written
      /// promptly, which could even be zero. To wait for the stream to be ready to
      /// accept data, the `subscribe` function to obtain a `pollable` which can be
      /// polled for using `wasi:io/poll`.
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct OutputStream{
        handle: wit_bindgen::rt::Resource<OutputStream>,
      }
      
      impl OutputStream{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for OutputStream{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]output-stream"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Perform a non-blocking read from the stream.
        /// 
        /// This function returns a list of bytes containing the read data,
        /// when successful. The returned list will contain up to `len` bytes;
        /// it may return fewer than requested, but not more. The list is
        /// empty when no bytes are available for reading at this time. The
        /// pollable given by `subscribe` will be ready when more bytes are
        /// available.
        /// 
        /// This function fails with a `stream-error` when the operation
        /// encounters an error, giving `last-operation-failed`, or when the
        /// stream is closed, giving `closed`.
        /// 
        /// When the caller gives a `len` of 0, it represents a request to
        /// read 0 bytes. If the stream is still open, this call should
        /// succeed and return an empty list, or otherwise fail with `closed`.
        /// 
        /// The `len` parameter is a `u64`, which could represent a list of u8 which
        /// is not possible to allocate in wasm32, or not desirable to allocate as
        /// as a return value by the callee. The callee may return a list of bytes
        /// less than `len` in size while more bytes are available for reading.
        pub fn read(&self,len: u64,) -> Result<wit_bindgen::rt::vec::Vec::<u8>,StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.read"]
              fn wit_import(_: i32, _: i64, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  let l3 = *((ptr0 + 8) as *const i32);
                  let len4 = l3 as usize;
                  
                  Vec::from_raw_parts(l2 as *mut _, len4, len4)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*((ptr0 + 4) as *const u8));
                  let v7 = match l5 {
                    0 => {
                      let e7 = {
                        let l6 = *((ptr0 + 8) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l6 as u32)
                      };
                      StreamError::LastOperationFailed(e7)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v7
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Read bytes from a stream, after blocking until at least one byte can
        /// be read. Except for blocking, behavior is identical to `read`.
        pub fn blocking_read(&self,len: u64,) -> Result<wit_bindgen::rt::vec::Vec::<u8>,StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.blocking-read"]
              fn wit_import(_: i32, _: i64, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  let l3 = *((ptr0 + 8) as *const i32);
                  let len4 = l3 as usize;
                  
                  Vec::from_raw_parts(l2 as *mut _, len4, len4)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*((ptr0 + 4) as *const u8));
                  let v7 = match l5 {
                    0 => {
                      let e7 = {
                        let l6 = *((ptr0 + 8) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l6 as u32)
                      };
                      StreamError::LastOperationFailed(e7)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v7
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Skip bytes from a stream. Returns number of bytes skipped.
        /// 
        /// Behaves identical to `read`, except instead of returning a list
        /// of bytes, returns the number of bytes consumed from the stream.
        pub fn skip(&self,len: u64,) -> Result<u64,StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.skip"]
              fn wit_import(_: i32, _: i64, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i64);
                  
                  l2 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*((ptr0 + 8) as *const u8));
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *((ptr0 + 12) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v5
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Skip bytes from a stream, after blocking until at least one byte
        /// can be skipped. Except for blocking behavior, identical to `skip`.
        pub fn blocking_skip(&self,len: u64,) -> Result<u64,StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.blocking-skip"]
              fn wit_import(_: i32, _: i64, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i64);
                  
                  l2 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*((ptr0 + 8) as *const u8));
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *((ptr0 + 12) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v5
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a `pollable` which will resolve once either the specified stream
        /// has bytes available to read or the other end of the stream has been
        /// closed.
        /// The created `pollable` is a child resource of the `input-stream`.
        /// Implementations may trap if the `input-stream` is dropped before
        /// all derived `pollable`s created with this function are dropped.
        pub fn subscribe(&self,) -> Pollable{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.subscribe"]
              fn wit_import(_: i32, ) -> i32;
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            super::super::super::wasi::io::poll::Pollable::from_handle(ret as u32)
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Check readiness for writing. This function never blocks.
        /// 
        /// Returns the number of bytes permitted for the next call to `write`,
        /// or an error. Calling `write` with more bytes than this function has
        /// permitted will trap.
        /// 
        /// When this function returns 0 bytes, the `subscribe` pollable will
        /// become ready when this function will report at least 1 byte, or an
        /// error.
        pub fn check_write(&self,) -> Result<u64,StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.check-write"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i64);
                  
                  l2 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*((ptr0 + 8) as *const u8));
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *((ptr0 + 12) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v5
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Perform a write. This function never blocks.
        /// 
        /// Precondition: check-write gave permit of Ok(n) and contents has a
        /// length of less than or equal to n. Otherwise, this function will trap.
        /// 
        /// returns Err(closed) without writing if the stream has closed since
        /// the last call to check-write provided a permit.
        pub fn write(&self,contents: &[u8],) -> Result<(),StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = contents;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.write"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*((ptr1 + 4) as *const u8));
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *((ptr1 + 8) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v5
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Perform a write of up to 4096 bytes, and then flush the stream. Block
        /// until all of these operations are complete, or an error occurs.
        /// 
        /// This is a convenience wrapper around the use of `check-write`,
        /// `subscribe`, `write`, and `flush`, and is implemented with the
        /// following pseudo-code:
        /// 
        /// ```text
        /// let pollable = this.subscribe();
        /// while !contents.is_empty() {
          /// // Wait for the stream to become writable
          /// poll-one(pollable);
          /// let Ok(n) = this.check-write(); // eliding error handling
          /// let len = min(n, contents.len());
          /// let (chunk, rest) = contents.split_at(len);
          /// this.write(chunk  );            // eliding error handling
          /// contents = rest;
          /// }
          /// this.flush();
          /// // Wait for completion of `flush`
          /// poll-one(pollable);
          /// // Check for any errors that arose during `flush`
          /// let _ = this.check-write();         // eliding error handling
          /// ```
          pub fn blocking_write_and_flush(&self,contents: &[u8],) -> Result<(),StreamError>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let vec0 = contents;
              let ptr0 = vec0.as_ptr() as i32;
              let len0 = vec0.len() as i32;
              let ptr1 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
              extern "C" {
                #[link_name = "[method]output-stream.blocking-write-and-flush"]
                fn wit_import(_: i32, _: i32, _: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
              wit_import((self).handle() as i32, ptr0, len0, ptr1);
              let l2 = i32::from(*((ptr1 + 0) as *const u8));
              match l2 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l3 = i32::from(*((ptr1 + 4) as *const u8));
                    let v5 = match l3 {
                      0 => {
                        let e5 = {
                          let l4 = *((ptr1 + 8) as *const i32);
                          
                          super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                        };
                        StreamError::LastOperationFailed(e5)
                      }
                      n => {
                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                        StreamError::Closed
                      }
                    };
                    
                    v5
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
        }
        impl OutputStream {
          #[allow(unused_unsafe, clippy::all)]
          /// Request to flush buffered output. This function never blocks.
          /// 
          /// This tells the output-stream that the caller intends any buffered
          /// output to be flushed. the output which is expected to be flushed
          /// is all that has been passed to `write` prior to this call.
          /// 
          /// Upon calling this function, the `output-stream` will not accept any
          /// writes (`check-write` will return `ok(0)`) until the flush has
          /// completed. The `subscribe` pollable will become ready when the
          /// flush has completed and the stream can accept more writes.
          pub fn flush(&self,) -> Result<(),StreamError>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let ptr0 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
              extern "C" {
                #[link_name = "[method]output-stream.flush"]
                fn wit_import(_: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, ){ unreachable!() }
              wit_import((self).handle() as i32, ptr0);
              let l1 = i32::from(*((ptr0 + 0) as *const u8));
              match l1 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l2 = i32::from(*((ptr0 + 4) as *const u8));
                    let v4 = match l2 {
                      0 => {
                        let e4 = {
                          let l3 = *((ptr0 + 8) as *const i32);
                          
                          super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                        };
                        StreamError::LastOperationFailed(e4)
                      }
                      n => {
                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                        StreamError::Closed
                      }
                    };
                    
                    v4
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
        }
        impl OutputStream {
          #[allow(unused_unsafe, clippy::all)]
          /// Request to flush buffered output, and block until flush completes
          /// and stream is ready for writing again.
          pub fn blocking_flush(&self,) -> Result<(),StreamError>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let ptr0 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
              extern "C" {
                #[link_name = "[method]output-stream.blocking-flush"]
                fn wit_import(_: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, ){ unreachable!() }
              wit_import((self).handle() as i32, ptr0);
              let l1 = i32::from(*((ptr0 + 0) as *const u8));
              match l1 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l2 = i32::from(*((ptr0 + 4) as *const u8));
                    let v4 = match l2 {
                      0 => {
                        let e4 = {
                          let l3 = *((ptr0 + 8) as *const i32);
                          
                          super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                        };
                        StreamError::LastOperationFailed(e4)
                      }
                      n => {
                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                        StreamError::Closed
                      }
                    };
                    
                    v4
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
        }
        impl OutputStream {
          #[allow(unused_unsafe, clippy::all)]
          /// Create a `pollable` which will resolve once the output-stream
          /// is ready for more writing, or an error has occured. When this
          /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
          /// error.
          /// 
          /// If the stream is closed, this pollable is always ready immediately.
          /// 
          /// The created `pollable` is a child resource of the `output-stream`.
          /// Implementations may trap if the `output-stream` is dropped before
          /// all derived `pollable`s created with this function are dropped.
          pub fn subscribe(&self,) -> Pollable{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
              extern "C" {
                #[link_name = "[method]output-stream.subscribe"]
                fn wit_import(_: i32, ) -> i32;
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, ) -> i32{ unreachable!() }
              let ret = wit_import((self).handle() as i32);
              super::super::super::wasi::io::poll::Pollable::from_handle(ret as u32)
            }
          }
        }
        impl OutputStream {
          #[allow(unused_unsafe, clippy::all)]
          /// Write zeroes to a stream.
          /// 
          /// this should be used precisely like `write` with the exact same
          /// preconditions (must use check-write first), but instead of
          /// passing a list of bytes, you simply pass the number of zero-bytes
          /// that should be written.
          pub fn write_zeroes(&self,len: u64,) -> Result<(),StreamError>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let ptr0 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
              extern "C" {
                #[link_name = "[method]output-stream.write-zeroes"]
                fn wit_import(_: i32, _: i64, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
              wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
              let l1 = i32::from(*((ptr0 + 0) as *const u8));
              match l1 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l2 = i32::from(*((ptr0 + 4) as *const u8));
                    let v4 = match l2 {
                      0 => {
                        let e4 = {
                          let l3 = *((ptr0 + 8) as *const i32);
                          
                          super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                        };
                        StreamError::LastOperationFailed(e4)
                      }
                      n => {
                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                        StreamError::Closed
                      }
                    };
                    
                    v4
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
        }
        impl OutputStream {
          #[allow(unused_unsafe, clippy::all)]
          /// Perform a write of up to 4096 zeroes, and then flush the stream.
          /// Block until all of these operations are complete, or an error
          /// occurs.
          /// 
          /// This is a convenience wrapper around the use of `check-write`,
          /// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
          /// the following pseudo-code:
          /// 
          /// ```text
          /// let pollable = this.subscribe();
          /// while num_zeroes != 0 {
            /// // Wait for the stream to become writable
            /// poll-one(pollable);
            /// let Ok(n) = this.check-write(); // eliding error handling
            /// let len = min(n, num_zeroes);
            /// this.write-zeroes(len);         // eliding error handling
            /// num_zeroes -= len;
            /// }
            /// this.flush();
            /// // Wait for completion of `flush`
            /// poll-one(pollable);
            /// // Check for any errors that arose during `flush`
            /// let _ = this.check-write();         // eliding error handling
            /// ```
            pub fn blocking_write_zeroes_and_flush(&self,len: u64,) -> Result<(),StreamError>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(4))]
                struct RetArea([u8; 12]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                extern "C" {
                  #[link_name = "[method]output-stream.blocking-write-zeroes-and-flush"]
                  fn wit_import(_: i32, _: i64, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
                let l1 = i32::from(*((ptr0 + 0) as *const u8));
                match l1 {
                  0 => {
                    let e = ();
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l2 = i32::from(*((ptr0 + 4) as *const u8));
                      let v4 = match l2 {
                        0 => {
                          let e4 = {
                            let l3 = *((ptr0 + 8) as *const i32);
                            
                            super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                          };
                          StreamError::LastOperationFailed(e4)
                        }
                        n => {
                          debug_assert_eq!(n, 1, "invalid enum discriminant");
                          StreamError::Closed
                        }
                      };
                      
                      v4
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          impl OutputStream {
            #[allow(unused_unsafe, clippy::all)]
            /// Read from one stream and write to another.
            /// 
            /// The behavior of splice is equivelant to:
            /// 1. calling `check-write` on the `output-stream`
            /// 2. calling `read` on the `input-stream` with the smaller of the
            /// `check-write` permitted length and the `len` provided to `splice`
            /// 3. calling `write` on the `output-stream` with that read data.
            /// 
            /// Any error reported by the call to `check-write`, `read`, or
            /// `write` ends the splice and reports that error.
            /// 
            /// This function returns the number of bytes transferred; it may be less
            /// than `len`.
            pub fn splice(&self,src: &InputStream,len: u64,) -> Result<u64,StreamError>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(8))]
                struct RetArea([u8; 16]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                extern "C" {
                  #[link_name = "[method]output-stream.splice"]
                  fn wit_import(_: i32, _: i32, _: i64, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i32, _: i64, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, (src).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
                let l1 = i32::from(*((ptr0 + 0) as *const u8));
                match l1 {
                  0 => {
                    let e = {
                      let l2 = *((ptr0 + 8) as *const i64);
                      
                      l2 as u64
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l3 = i32::from(*((ptr0 + 8) as *const u8));
                      let v5 = match l3 {
                        0 => {
                          let e5 = {
                            let l4 = *((ptr0 + 12) as *const i32);
                            
                            super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                          };
                          StreamError::LastOperationFailed(e5)
                        }
                        n => {
                          debug_assert_eq!(n, 1, "invalid enum discriminant");
                          StreamError::Closed
                        }
                      };
                      
                      v5
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          impl OutputStream {
            #[allow(unused_unsafe, clippy::all)]
            /// Read from one stream and write to another, with blocking.
            /// 
            /// This is similar to `splice`, except that it blocks until the
            /// `output-stream` is ready for writing, and the `input-stream`
            /// is ready for reading, before performing the `splice`.
            pub fn blocking_splice(&self,src: &InputStream,len: u64,) -> Result<u64,StreamError>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(8))]
                struct RetArea([u8; 16]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                extern "C" {
                  #[link_name = "[method]output-stream.blocking-splice"]
                  fn wit_import(_: i32, _: i32, _: i64, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i32, _: i64, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, (src).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
                let l1 = i32::from(*((ptr0 + 0) as *const u8));
                match l1 {
                  0 => {
                    let e = {
                      let l2 = *((ptr0 + 8) as *const i64);
                      
                      l2 as u64
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l3 = i32::from(*((ptr0 + 8) as *const u8));
                      let v5 = match l3 {
                        0 => {
                          let e5 = {
                            let l4 = *((ptr0 + 12) as *const i32);
                            
                            super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                          };
                          StreamError::LastOperationFailed(e5)
                        }
                        n => {
                          debug_assert_eq!(n, 1, "invalid enum discriminant");
                          StreamError::Closed
                        }
                      };
                      
                      v5
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          
        }
        
      }
    }
    pub mod exports {
      pub mod golem {
        pub mod it {
          
          #[allow(clippy::all)]
          pub mod api {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_section;
            const _: () = {
              
              #[doc(hidden)]
              #[export_name = "golem:it/api#create-container"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_create_container(arg0: i32,arg1: i32,) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                
                // Before executing any other code, use this function to run all static
                // constructors, if they have not yet been run. This is a hack required
                // to work around wasi-libc ctors calling import functions to initialize
                // the environment.
                //
                // This functionality will be removed once rust 1.69.0 is stable, at which
                // point wasi-libc will no longer have this behavior.
                //
                // See
                // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                // for more details.
                #[cfg(target_arch="wasm32")]
                wit_bindgen::rt::run_ctors_once();
                
                let len0 = arg1 as usize;
                let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
                <_GuestImpl as Guest>::create_container(wit_bindgen::rt::string_lift(bytes0));
              }
            };
            const _: () = {
              
              #[doc(hidden)]
              #[export_name = "golem:it/api#container-exists"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_container_exists(arg0: i32,arg1: i32,) -> i32 {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                
                // Before executing any other code, use this function to run all static
                // constructors, if they have not yet been run. This is a hack required
                // to work around wasi-libc ctors calling import functions to initialize
                // the environment.
                //
                // This functionality will be removed once rust 1.69.0 is stable, at which
                // point wasi-libc will no longer have this behavior.
                //
                // See
                // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                // for more details.
                #[cfg(target_arch="wasm32")]
                wit_bindgen::rt::run_ctors_once();
                
                let len0 = arg1 as usize;
                let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
                let result1 = <_GuestImpl as Guest>::container_exists(wit_bindgen::rt::string_lift(bytes0));
                match result1 { true => 1, false => 0 }
              }
            };
            use super::super::super::super::super::Component as _GuestImpl;
            pub trait Guest {
              fn create_container(container_name: wit_bindgen::rt::string::String,);
              fn container_exists(container_name: wit_bindgen::rt::string::String,) -> bool;
            }
            
          }
          
        }
      }
    }
    
    #[cfg(target_arch = "wasm32")]
    #[link_section = "component-type:blob-store-service"]
    #[doc(hidden)]
    pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 3743] = [3, 0, 18, 98, 108, 111, 98, 45, 115, 116, 111, 114, 101, 45, 115, 101, 114, 118, 105, 99, 101, 0, 97, 115, 109, 13, 0, 1, 0, 7, 107, 1, 65, 2, 1, 66, 4, 1, 64, 1, 14, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 110, 97, 109, 101, 115, 1, 0, 4, 0, 16, 99, 114, 101, 97, 116, 101, 45, 99, 111, 110, 116, 97, 105, 110, 101, 114, 1, 0, 1, 64, 1, 14, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 110, 97, 109, 101, 115, 0, 127, 4, 0, 16, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 101, 120, 105, 115, 116, 115, 1, 1, 4, 1, 12, 103, 111, 108, 101, 109, 58, 105, 116, 47, 97, 112, 105, 5, 0, 11, 9, 1, 0, 3, 97, 112, 105, 3, 0, 0, 7, 147, 27, 1, 65, 2, 1, 65, 27, 1, 66, 4, 4, 0, 5, 101, 114, 114, 111, 114, 3, 1, 1, 104, 0, 1, 64, 1, 4, 115, 101, 108, 102, 1, 0, 115, 4, 0, 29, 91, 109, 101, 116, 104, 111, 100, 93, 101, 114, 114, 111, 114, 46, 116, 111, 45, 100, 101, 98, 117, 103, 45, 115, 116, 114, 105, 110, 103, 1, 2, 3, 1, 19, 119, 97, 115, 105, 58, 105, 111, 47, 101, 114, 114, 111, 114, 64, 48, 46, 50, 46, 48, 5, 0, 1, 66, 10, 4, 0, 8, 112, 111, 108, 108, 97, 98, 108, 101, 3, 1, 1, 104, 0, 1, 64, 1, 4, 115, 101, 108, 102, 1, 0, 127, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 112, 111, 108, 108, 97, 98, 108, 101, 46, 114, 101, 97, 100, 121, 1, 2, 1, 64, 1, 4, 115, 101, 108, 102, 1, 1, 0, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 112, 111, 108, 108, 97, 98, 108, 101, 46, 98, 108, 111, 99, 107, 1, 3, 1, 112, 1, 1, 112, 121, 1, 64, 1, 2, 105, 110, 4, 0, 5, 4, 0, 4, 112, 111, 108, 108, 1, 6, 3, 1, 18, 119, 97, 115, 105, 58, 105, 111, 47, 112, 111, 108, 108, 64, 48, 46, 50, 46, 48, 5, 1, 2, 3, 0, 0, 5, 101, 114, 114, 111, 114, 2, 3, 0, 1, 8, 112, 111, 108, 108, 97, 98, 108, 101, 1, 66, 40, 2, 3, 2, 1, 2, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 0, 2, 3, 2, 1, 3, 4, 0, 8, 112, 111, 108, 108, 97, 98, 108, 101, 3, 0, 2, 1, 105, 1, 1, 113, 2, 21, 108, 97, 115, 116, 45, 111, 112, 101, 114, 97, 116, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 4, 0, 6, 99, 108, 111, 115, 101, 100, 0, 0, 4, 0, 12, 115, 116, 114, 101, 97, 109, 45, 101, 114, 114, 111, 114, 3, 0, 5, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 1, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 1, 1, 104, 7, 1, 112, 125, 1, 106, 1, 10, 1, 6, 1, 64, 2, 4, 115, 101, 108, 102, 9, 3, 108, 101, 110, 119, 0, 11, 4, 0, 25, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 114, 101, 97, 100, 1, 12, 4, 0, 34, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 114, 101, 97, 100, 1, 12, 1, 106, 1, 119, 1, 6, 1, 64, 2, 4, 115, 101, 108, 102, 9, 3, 108, 101, 110, 119, 0, 13, 4, 0, 25, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 115, 107, 105, 112, 1, 14, 4, 0, 34, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 115, 107, 105, 112, 1, 14, 1, 105, 3, 1, 64, 1, 4, 115, 101, 108, 102, 9, 0, 15, 4, 0, 30, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 115, 117, 98, 115, 99, 114, 105, 98, 101, 1, 16, 1, 104, 8, 1, 64, 1, 4, 115, 101, 108, 102, 17, 0, 13, 4, 0, 33, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 99, 104, 101, 99, 107, 45, 119, 114, 105, 116, 101, 1, 18, 1, 106, 0, 1, 6, 1, 64, 2, 4, 115, 101, 108, 102, 17, 8, 99, 111, 110, 116, 101, 110, 116, 115, 10, 0, 19, 4, 0, 27, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 119, 114, 105, 116, 101, 1, 20, 4, 0, 46, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 119, 114, 105, 116, 101, 45, 97, 110, 100, 45, 102, 108, 117, 115, 104, 1, 20, 1, 64, 1, 4, 115, 101, 108, 102, 17, 0, 19, 4, 0, 27, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 102, 108, 117, 115, 104, 1, 21, 4, 0, 36, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 102, 108, 117, 115, 104, 1, 21, 1, 64, 1, 4, 115, 101, 108, 102, 17, 0, 15, 4, 0, 31, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 115, 117, 98, 115, 99, 114, 105, 98, 101, 1, 22, 1, 64, 2, 4, 115, 101, 108, 102, 17, 3, 108, 101, 110, 119, 0, 19, 4, 0, 34, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 119, 114, 105, 116, 101, 45, 122, 101, 114, 111, 101, 115, 1, 23, 4, 0, 53, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 119, 114, 105, 116, 101, 45, 122, 101, 114, 111, 101, 115, 45, 97, 110, 100, 45, 102, 108, 117, 115, 104, 1, 23, 1, 64, 3, 4, 115, 101, 108, 102, 17, 3, 115, 114, 99, 9, 3, 108, 101, 110, 119, 0, 13, 4, 0, 28, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 115, 112, 108, 105, 99, 101, 1, 24, 4, 0, 37, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 115, 112, 108, 105, 99, 101, 1, 24, 3, 1, 21, 119, 97, 115, 105, 58, 105, 111, 47, 115, 116, 114, 101, 97, 109, 115, 64, 48, 46, 50, 46, 48, 5, 4, 2, 3, 0, 2, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 2, 3, 0, 2, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 1, 66, 43, 2, 3, 2, 1, 5, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 2, 1, 115, 4, 0, 14, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 110, 97, 109, 101, 3, 0, 4, 1, 115, 4, 0, 11, 111, 98, 106, 101, 99, 116, 45, 110, 97, 109, 101, 3, 0, 6, 1, 119, 4, 0, 9, 116, 105, 109, 101, 115, 116, 97, 109, 112, 3, 0, 8, 1, 119, 4, 0, 11, 111, 98, 106, 101, 99, 116, 45, 115, 105, 122, 101, 3, 0, 10, 1, 115, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 12, 1, 114, 2, 4, 110, 97, 109, 101, 5, 10, 99, 114, 101, 97, 116, 101, 100, 45, 97, 116, 9, 4, 0, 18, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 109, 101, 116, 97, 100, 97, 116, 97, 3, 0, 14, 1, 114, 4, 4, 110, 97, 109, 101, 7, 9, 99, 111, 110, 116, 97, 105, 110, 101, 114, 5, 10, 99, 114, 101, 97, 116, 101, 100, 45, 97, 116, 9, 4, 115, 105, 122, 101, 11, 4, 0, 15, 111, 98, 106, 101, 99, 116, 45, 109, 101, 116, 97, 100, 97, 116, 97, 3, 0, 16, 1, 114, 2, 9, 99, 111, 110, 116, 97, 105, 110, 101, 114, 5, 6, 111, 98, 106, 101, 99, 116, 7, 4, 0, 9, 111, 98, 106, 101, 99, 116, 45, 105, 100, 3, 0, 18, 4, 0, 14, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 3, 1, 4, 0, 14, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 3, 1, 4, 0, 25, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 97, 115, 121, 110, 99, 45, 98, 111, 100, 121, 3, 0, 1, 1, 112, 125, 4, 0, 24, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 115, 121, 110, 99, 45, 98, 111, 100, 121, 3, 0, 23, 1, 105, 20, 1, 64, 0, 0, 25, 4, 0, 41, 91, 115, 116, 97, 116, 105, 99, 93, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 46, 110, 101, 119, 45, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 1, 26, 1, 104, 20, 1, 105, 3, 1, 106, 1, 28, 0, 1, 64, 1, 4, 115, 101, 108, 102, 27, 0, 29, 4, 0, 48, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 46, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 119, 114, 105, 116, 101, 45, 98, 111, 100, 121, 1, 30, 1, 104, 21, 1, 106, 1, 24, 1, 13, 1, 64, 1, 4, 115, 101, 108, 102, 31, 0, 32, 4, 0, 50, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 46, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 99, 111, 110, 115, 117, 109, 101, 45, 115, 121, 110, 99, 1, 33, 1, 105, 22, 1, 106, 1, 34, 1, 13, 1, 64, 1, 4, 115, 101, 108, 102, 31, 0, 35, 4, 0, 51, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 46, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 99, 111, 110, 115, 117, 109, 101, 45, 97, 115, 121, 110, 99, 1, 36, 1, 64, 1, 4, 115, 101, 108, 102, 31, 0, 119, 4, 0, 27, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 46, 115, 105, 122, 101, 1, 37, 3, 1, 20, 119, 97, 115, 105, 58, 98, 108, 111, 98, 115, 116, 111, 114, 101, 47, 116, 121, 112, 101, 115, 5, 7, 2, 3, 0, 3, 18, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 109, 101, 116, 97, 100, 97, 116, 97, 2, 3, 0, 3, 5, 101, 114, 114, 111, 114, 2, 3, 0, 3, 14, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 2, 3, 0, 3, 15, 111, 98, 106, 101, 99, 116, 45, 109, 101, 116, 97, 100, 97, 116, 97, 2, 3, 0, 3, 11, 111, 98, 106, 101, 99, 116, 45, 110, 97, 109, 101, 2, 3, 0, 3, 14, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 1, 66, 59, 2, 3, 2, 1, 5, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 2, 2, 3, 2, 1, 8, 4, 0, 18, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 109, 101, 116, 97, 100, 97, 116, 97, 3, 0, 4, 2, 3, 2, 1, 9, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 6, 2, 3, 2, 1, 10, 4, 0, 14, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 3, 0, 8, 2, 3, 2, 1, 11, 4, 0, 15, 111, 98, 106, 101, 99, 116, 45, 109, 101, 116, 97, 100, 97, 116, 97, 3, 0, 10, 2, 3, 2, 1, 12, 4, 0, 11, 111, 98, 106, 101, 99, 116, 45, 110, 97, 109, 101, 3, 0, 12, 2, 3, 2, 1, 13, 4, 0, 14, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 3, 0, 14, 4, 0, 9, 99, 111, 110, 116, 97, 105, 110, 101, 114, 3, 1, 4, 0, 19, 115, 116, 114, 101, 97, 109, 45, 111, 98, 106, 101, 99, 116, 45, 110, 97, 109, 101, 115, 3, 1, 1, 104, 16, 1, 106, 1, 115, 1, 7, 1, 64, 1, 4, 115, 101, 108, 102, 18, 0, 19, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 110, 97, 109, 101, 1, 20, 1, 106, 1, 5, 1, 7, 1, 64, 1, 4, 115, 101, 108, 102, 18, 0, 21, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 105, 110, 102, 111, 1, 22, 1, 105, 9, 1, 106, 1, 23, 1, 7, 1, 64, 4, 4, 115, 101, 108, 102, 18, 4, 110, 97, 109, 101, 13, 5, 115, 116, 97, 114, 116, 119, 3, 101, 110, 100, 119, 0, 24, 4, 0, 26, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 103, 101, 116, 45, 100, 97, 116, 97, 1, 25, 1, 104, 15, 1, 106, 0, 1, 7, 1, 64, 3, 4, 115, 101, 108, 102, 18, 4, 110, 97, 109, 101, 13, 4, 100, 97, 116, 97, 26, 0, 27, 4, 0, 28, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 119, 114, 105, 116, 101, 45, 100, 97, 116, 97, 1, 28, 1, 105, 17, 1, 106, 1, 29, 1, 7, 1, 64, 1, 4, 115, 101, 108, 102, 18, 0, 30, 4, 0, 30, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 108, 105, 115, 116, 45, 111, 98, 106, 101, 99, 116, 115, 1, 31, 1, 64, 2, 4, 115, 101, 108, 102, 18, 4, 110, 97, 109, 101, 13, 0, 27, 4, 0, 31, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 100, 101, 108, 101, 116, 101, 45, 111, 98, 106, 101, 99, 116, 1, 32, 1, 112, 13, 1, 64, 2, 4, 115, 101, 108, 102, 18, 5, 110, 97, 109, 101, 115, 33, 0, 27, 4, 0, 32, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 100, 101, 108, 101, 116, 101, 45, 111, 98, 106, 101, 99, 116, 115, 1, 34, 1, 106, 1, 127, 1, 7, 1, 64, 2, 4, 115, 101, 108, 102, 18, 4, 110, 97, 109, 101, 13, 0, 35, 4, 0, 28, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 104, 97, 115, 45, 111, 98, 106, 101, 99, 116, 1, 36, 1, 106, 1, 11, 1, 7, 1, 64, 2, 4, 115, 101, 108, 102, 18, 4, 110, 97, 109, 101, 13, 0, 37, 4, 0, 29, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 111, 98, 106, 101, 99, 116, 45, 105, 110, 102, 111, 1, 38, 1, 64, 1, 4, 115, 101, 108, 102, 18, 0, 27, 4, 0, 23, 91, 109, 101, 116, 104, 111, 100, 93, 99, 111, 110, 116, 97, 105, 110, 101, 114, 46, 99, 108, 101, 97, 114, 1, 39, 1, 104, 17, 1, 111, 2, 33, 127, 1, 106, 1, 41, 1, 7, 1, 64, 2, 4, 115, 101, 108, 102, 40, 3, 108, 101, 110, 119, 0, 42, 4, 0, 52, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 114, 101, 97, 109, 45, 111, 98, 106, 101, 99, 116, 45, 110, 97, 109, 101, 115, 46, 114, 101, 97, 100, 45, 115, 116, 114, 101, 97, 109, 45, 111, 98, 106, 101, 99, 116, 45, 110, 97, 109, 101, 115, 1, 43, 1, 111, 2, 119, 127, 1, 106, 1, 44, 1, 7, 1, 64, 2, 4, 115, 101, 108, 102, 40, 3, 110, 117, 109, 119, 0, 45, 4, 0, 52, 91, 109, 101, 116, 104, 111, 100, 93, 115, 116, 114, 101, 97, 109, 45, 111, 98, 106, 101, 99, 116, 45, 110, 97, 109, 101, 115, 46, 115, 107, 105, 112, 45, 115, 116, 114, 101, 97, 109, 45, 111, 98, 106, 101, 99, 116, 45, 110, 97, 109, 101, 115, 1, 46, 3, 1, 24, 119, 97, 115, 105, 58, 98, 108, 111, 98, 115, 116, 111, 114, 101, 47, 99, 111, 110, 116, 97, 105, 110, 101, 114, 5, 14, 2, 3, 0, 4, 9, 99, 111, 110, 116, 97, 105, 110, 101, 114, 2, 3, 0, 3, 14, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 110, 97, 109, 101, 2, 3, 0, 3, 9, 111, 98, 106, 101, 99, 116, 45, 105, 100, 1, 66, 22, 2, 3, 2, 1, 15, 4, 0, 9, 99, 111, 110, 116, 97, 105, 110, 101, 114, 3, 0, 0, 2, 3, 2, 1, 9, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 2, 2, 3, 2, 1, 16, 4, 0, 14, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 110, 97, 109, 101, 3, 0, 4, 2, 3, 2, 1, 17, 4, 0, 9, 111, 98, 106, 101, 99, 116, 45, 105, 100, 3, 0, 6, 1, 105, 1, 1, 106, 1, 8, 1, 3, 1, 64, 1, 4, 110, 97, 109, 101, 5, 0, 9, 4, 0, 16, 99, 114, 101, 97, 116, 101, 45, 99, 111, 110, 116, 97, 105, 110, 101, 114, 1, 10, 4, 0, 13, 103, 101, 116, 45, 99, 111, 110, 116, 97, 105, 110, 101, 114, 1, 10, 1, 106, 0, 1, 3, 1, 64, 1, 4, 110, 97, 109, 101, 5, 0, 11, 4, 0, 16, 100, 101, 108, 101, 116, 101, 45, 99, 111, 110, 116, 97, 105, 110, 101, 114, 1, 12, 1, 106, 1, 127, 1, 3, 1, 64, 1, 4, 110, 97, 109, 101, 5, 0, 13, 4, 0, 16, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 101, 120, 105, 115, 116, 115, 1, 14, 1, 64, 2, 3, 115, 114, 99, 7, 4, 100, 101, 115, 116, 7, 0, 11, 4, 0, 11, 99, 111, 112, 121, 45, 111, 98, 106, 101, 99, 116, 1, 15, 4, 0, 11, 109, 111, 118, 101, 45, 111, 98, 106, 101, 99, 116, 1, 15, 3, 1, 24, 119, 97, 115, 105, 58, 98, 108, 111, 98, 115, 116, 111, 114, 101, 47, 98, 108, 111, 98, 115, 116, 111, 114, 101, 5, 18, 1, 66, 4, 1, 64, 1, 14, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 110, 97, 109, 101, 115, 1, 0, 4, 0, 16, 99, 114, 101, 97, 116, 101, 45, 99, 111, 110, 116, 97, 105, 110, 101, 114, 1, 0, 1, 64, 1, 14, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 110, 97, 109, 101, 115, 0, 127, 4, 0, 16, 99, 111, 110, 116, 97, 105, 110, 101, 114, 45, 101, 120, 105, 115, 116, 115, 1, 1, 4, 1, 12, 103, 111, 108, 101, 109, 58, 105, 116, 47, 97, 112, 105, 5, 19, 4, 1, 27, 103, 111, 108, 101, 109, 58, 105, 116, 47, 98, 108, 111, 98, 45, 115, 116, 111, 114, 101, 45, 115, 101, 114, 118, 105, 99, 101, 4, 0, 11, 24, 1, 0, 18, 98, 108, 111, 98, 45, 115, 116, 111, 114, 101, 45, 115, 101, 114, 118, 105, 99, 101, 3, 2, 0, 0, 16, 12, 112, 97, 99, 107, 97, 103, 101, 45, 100, 111, 99, 115, 0, 123, 125, 0, 70, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 6, 48, 46, 49, 56, 46, 50, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 6, 48, 46, 49, 54, 46, 48];
    
    #[inline(never)]
    #[doc(hidden)]
    #[cfg(target_arch = "wasm32")]
    pub fn __link_section() {}
    
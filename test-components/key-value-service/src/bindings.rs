// Generated by `wit-bindgen` 0.16.0. DO NOT EDIT!
pub mod wasi {
  pub mod io {
    
    #[allow(clippy::all)]
    pub mod error {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      /// A resource which represents some error information.
      /// 
      /// The only method provided by this resource is `to-debug-string`,
      /// which provides some human-readable information about the error.
      /// 
      /// In the `wasi:io` package, this resource is returned through the
      /// `wasi:io/streams/stream-error` type.
      /// 
      /// To provide more specific error information, other interfaces may
      /// provide functions to further "downcast" this error into more specific
      /// error information. For example, `error`s returned in streams derived
      /// from filesystem types to be described using the filesystem's own
      /// error-code type, using the function
      /// `wasi:filesystem/types/filesystem-error-code`, which takes a parameter
      /// `borrow<error>` and returns
      /// `option<wasi:filesystem/types/error-code>`.
      /// 
      /// The set of functions which can "downcast" an `error` into a more
      /// concrete type is open.
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Error{
        handle: wit_bindgen::rt::Resource<Error>,
      }
      
      impl Error{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for Error{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:io/error@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]error"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      impl Error {
        #[allow(unused_unsafe, clippy::all)]
        /// Returns a string that is suitable to assist humans in debugging
        /// this error.
        /// 
        /// WARNING: The returned string should not be consumed mechanically!
        /// It may change across platforms, hosts, or other implementation
        /// details. Parsing this string is a major platform-compatibility
        /// hazard.
        pub fn to_debug_string(&self,) -> wit_bindgen::rt::string::String{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 8]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/error@0.2.0")]
            extern "C" {
              #[link_name = "[method]error.to-debug-string"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = *((ptr0 + 0) as *const i32);
            let l2 = *((ptr0 + 4) as *const i32);
            let len3 = l2 as usize;
            let bytes3 = Vec::from_raw_parts(l1 as *mut _, len3, len3);
            wit_bindgen::rt::string_lift(bytes3)
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod poll {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      /// `pollable` epresents a single I/O event which may be ready, or not.
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Pollable{
        handle: wit_bindgen::rt::Resource<Pollable>,
      }
      
      impl Pollable{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for Pollable{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]pollable"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      impl Pollable {
        #[allow(unused_unsafe, clippy::all)]
        /// Return the readiness of a pollable. This function never blocks.
        /// 
        /// Returns `true` when the pollable is ready, and `false` otherwise.
        pub fn ready(&self,) -> bool{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
            extern "C" {
              #[link_name = "[method]pollable.ready"]
              fn wit_import(_: i32, ) -> i32;
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            wit_bindgen::rt::bool_lift(ret as u8)
          }
        }
      }
      impl Pollable {
        #[allow(unused_unsafe, clippy::all)]
        /// `block` returns immediately if the pollable is ready, and otherwise
        /// blocks until ready.
        /// 
        /// This function is equivalent to calling `poll.poll` on a list
        /// containing only this pollable.
        pub fn block(&self,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
            extern "C" {
              #[link_name = "[method]pollable.block"]
              fn wit_import(_: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ){ unreachable!() }
            wit_import((self).handle() as i32);
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Poll for completion on a set of pollables.
      /// 
      /// This function takes a list of pollables, which identify I/O sources of
      /// interest, and waits until one or more of the events is ready for I/O.
      /// 
      /// The result `list<u32>` contains one or more indices of handles in the
      /// argument list that is ready for I/O.
      /// 
      /// If the list contains more elements than can be indexed with a `u32`
      /// value, this function traps.
      /// 
      /// A timeout can be implemented by adding a pollable from the
      /// wasi-clocks API to the list.
      /// 
      /// This function does not return a `result`; polling in itself does not
      /// do any I/O so it doesn't fail. If any of the I/O sources identified by
      /// the pollables has an error, it is indicated by marking the source as
      /// being reaedy for I/O.
      pub fn poll(in_: &[&Pollable],) -> wit_bindgen::rt::vec::Vec::<u32>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 8]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = in_;
          let len0 = vec0.len() as i32;
          let layout0 = alloc::Layout::from_size_align_unchecked(vec0.len() * 4, 4);
          let result0 = if layout0.size() != 0
          {
            let ptr = alloc::alloc(layout0);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout0);
            }
            ptr
          }else {{
            ::core::ptr::null_mut()
          }};
          for (i, e) in vec0.into_iter().enumerate() {
            let base = result0 as i32 + (i as i32) * 4;
            {
              *((base + 0) as *mut i32) = (e).handle() as i32;
            }
          }
          let ptr1 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
          extern "C" {
            #[link_name = "poll"]
            fn wit_import(_: i32, _: i32, _: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
          wit_import(result0 as i32, len0, ptr1);
          let l2 = *((ptr1 + 0) as *const i32);
          let l3 = *((ptr1 + 4) as *const i32);
          let len4 = l3 as usize;
          if layout0.size() != 0 {
            alloc::dealloc(result0, layout0);
          }
          Vec::from_raw_parts(l2 as *mut _, len4, len4)
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod streams {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type Error = super::super::super::wasi::io::error::Error;
      pub type Pollable = super::super::super::wasi::io::poll::Pollable;
      /// An error for input-stream and output-stream operations.
      pub enum StreamError{
        /// The last operation (a write or flush) failed before completion.
        /// 
        /// More information is available in the `error` payload.
        LastOperationFailed(Error),
        /// The stream is closed: no more input will be accepted by the
        /// stream. A closed output-stream will return this error on all
        /// future operations.
        Closed,
      }
      impl ::core::fmt::Debug for StreamError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            StreamError::LastOperationFailed(e) => {
              f.debug_tuple("StreamError::LastOperationFailed").field(e).finish()
            }
            StreamError::Closed => {
              f.debug_tuple("StreamError::Closed").finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for StreamError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      
      impl std::error::Error for StreamError {}
      /// An input bytestream.
      /// 
      /// `input-stream`s are *non-blocking* to the extent practical on underlying
      /// platforms. I/O operations always return promptly; if fewer bytes are
      /// promptly available than requested, they return the number of bytes promptly
      /// available, which could even be zero. To wait for data to be available,
      /// use the `subscribe` function to obtain a `pollable` which can be polled
      /// for using `wasi:io/poll`.
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct InputStream{
        handle: wit_bindgen::rt::Resource<InputStream>,
      }
      
      impl InputStream{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for InputStream{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]input-stream"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      /// An output bytestream.
      /// 
      /// `output-stream`s are *non-blocking* to the extent practical on
      /// underlying platforms. Except where specified otherwise, I/O operations also
      /// always return promptly, after the number of bytes that can be written
      /// promptly, which could even be zero. To wait for the stream to be ready to
      /// accept data, the `subscribe` function to obtain a `pollable` which can be
      /// polled for using `wasi:io/poll`.
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct OutputStream{
        handle: wit_bindgen::rt::Resource<OutputStream>,
      }
      
      impl OutputStream{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for OutputStream{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]output-stream"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Perform a non-blocking read from the stream.
        /// 
        /// This function returns a list of bytes containing the read data,
        /// when successful. The returned list will contain up to `len` bytes;
        /// it may return fewer than requested, but not more. The list is
        /// empty when no bytes are available for reading at this time. The
        /// pollable given by `subscribe` will be ready when more bytes are
        /// available.
        /// 
        /// This function fails with a `stream-error` when the operation
        /// encounters an error, giving `last-operation-failed`, or when the
        /// stream is closed, giving `closed`.
        /// 
        /// When the caller gives a `len` of 0, it represents a request to
        /// read 0 bytes. If the stream is still open, this call should
        /// succeed and return an empty list, or otherwise fail with `closed`.
        /// 
        /// The `len` parameter is a `u64`, which could represent a list of u8 which
        /// is not possible to allocate in wasm32, or not desirable to allocate as
        /// as a return value by the callee. The callee may return a list of bytes
        /// less than `len` in size while more bytes are available for reading.
        pub fn read(&self,len: u64,) -> Result<wit_bindgen::rt::vec::Vec::<u8>,StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.read"]
              fn wit_import(_: i32, _: i64, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  let l3 = *((ptr0 + 8) as *const i32);
                  let len4 = l3 as usize;
                  
                  Vec::from_raw_parts(l2 as *mut _, len4, len4)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*((ptr0 + 4) as *const u8));
                  let v7 = match l5 {
                    0 => {
                      let e7 = {
                        let l6 = *((ptr0 + 8) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l6 as u32)
                      };
                      StreamError::LastOperationFailed(e7)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v7
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Read bytes from a stream, after blocking until at least one byte can
        /// be read. Except for blocking, behavior is identical to `read`.
        pub fn blocking_read(&self,len: u64,) -> Result<wit_bindgen::rt::vec::Vec::<u8>,StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.blocking-read"]
              fn wit_import(_: i32, _: i64, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  let l3 = *((ptr0 + 8) as *const i32);
                  let len4 = l3 as usize;
                  
                  Vec::from_raw_parts(l2 as *mut _, len4, len4)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l5 = i32::from(*((ptr0 + 4) as *const u8));
                  let v7 = match l5 {
                    0 => {
                      let e7 = {
                        let l6 = *((ptr0 + 8) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l6 as u32)
                      };
                      StreamError::LastOperationFailed(e7)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v7
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Skip bytes from a stream. Returns number of bytes skipped.
        /// 
        /// Behaves identical to `read`, except instead of returning a list
        /// of bytes, returns the number of bytes consumed from the stream.
        pub fn skip(&self,len: u64,) -> Result<u64,StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.skip"]
              fn wit_import(_: i32, _: i64, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i64);
                  
                  l2 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*((ptr0 + 8) as *const u8));
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *((ptr0 + 12) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v5
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Skip bytes from a stream, after blocking until at least one byte
        /// can be skipped. Except for blocking behavior, identical to `skip`.
        pub fn blocking_skip(&self,len: u64,) -> Result<u64,StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.blocking-skip"]
              fn wit_import(_: i32, _: i64, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i64);
                  
                  l2 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*((ptr0 + 8) as *const u8));
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *((ptr0 + 12) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v5
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl InputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Create a `pollable` which will resolve once either the specified stream
        /// has bytes available to read or the other end of the stream has been
        /// closed.
        /// The created `pollable` is a child resource of the `input-stream`.
        /// Implementations may trap if the `input-stream` is dropped before
        /// all derived `pollable`s created with this function are dropped.
        pub fn subscribe(&self,) -> Pollable{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]input-stream.subscribe"]
              fn wit_import(_: i32, ) -> i32;
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ) -> i32{ unreachable!() }
            let ret = wit_import((self).handle() as i32);
            super::super::super::wasi::io::poll::Pollable::from_handle(ret as u32)
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Check readiness for writing. This function never blocks.
        /// 
        /// Returns the number of bytes permitted for the next call to `write`,
        /// or an error. Calling `write` with more bytes than this function has
        /// permitted will trap.
        /// 
        /// When this function returns 0 bytes, the `subscribe` pollable will
        /// become ready when this function will report at least 1 byte, or an
        /// error.
        pub fn check_write(&self,) -> Result<u64,StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.check-write"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i64);
                  
                  l2 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*((ptr0 + 8) as *const u8));
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *((ptr0 + 12) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v5
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Perform a write. This function never blocks.
        /// 
        /// Precondition: check-write gave permit of Ok(n) and contents has a
        /// length of less than or equal to n. Otherwise, this function will trap.
        /// 
        /// returns Err(closed) without writing if the stream has closed since
        /// the last call to check-write provided a permit.
        pub fn write(&self,contents: &[u8],) -> Result<(),StreamError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = contents;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
            extern "C" {
              #[link_name = "[method]output-stream.write"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*((ptr1 + 4) as *const u8));
                  let v5 = match l3 {
                    0 => {
                      let e5 = {
                        let l4 = *((ptr1 + 8) as *const i32);
                        
                        super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                      };
                      StreamError::LastOperationFailed(e5)
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      StreamError::Closed
                    }
                  };
                  
                  v5
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl OutputStream {
        #[allow(unused_unsafe, clippy::all)]
        /// Perform a write of up to 4096 bytes, and then flush the stream. Block
        /// until all of these operations are complete, or an error occurs.
        /// 
        /// This is a convenience wrapper around the use of `check-write`,
        /// `subscribe`, `write`, and `flush`, and is implemented with the
        /// following pseudo-code:
        /// 
        /// ```text
        /// let pollable = this.subscribe();
        /// while !contents.is_empty() {
          /// // Wait for the stream to become writable
          /// poll-one(pollable);
          /// let Ok(n) = this.check-write(); // eliding error handling
          /// let len = min(n, contents.len());
          /// let (chunk, rest) = contents.split_at(len);
          /// this.write(chunk  );            // eliding error handling
          /// contents = rest;
          /// }
          /// this.flush();
          /// // Wait for completion of `flush`
          /// poll-one(pollable);
          /// // Check for any errors that arose during `flush`
          /// let _ = this.check-write();         // eliding error handling
          /// ```
          pub fn blocking_write_and_flush(&self,contents: &[u8],) -> Result<(),StreamError>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let vec0 = contents;
              let ptr0 = vec0.as_ptr() as i32;
              let len0 = vec0.len() as i32;
              let ptr1 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
              extern "C" {
                #[link_name = "[method]output-stream.blocking-write-and-flush"]
                fn wit_import(_: i32, _: i32, _: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
              wit_import((self).handle() as i32, ptr0, len0, ptr1);
              let l2 = i32::from(*((ptr1 + 0) as *const u8));
              match l2 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l3 = i32::from(*((ptr1 + 4) as *const u8));
                    let v5 = match l3 {
                      0 => {
                        let e5 = {
                          let l4 = *((ptr1 + 8) as *const i32);
                          
                          super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                        };
                        StreamError::LastOperationFailed(e5)
                      }
                      n => {
                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                        StreamError::Closed
                      }
                    };
                    
                    v5
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
        }
        impl OutputStream {
          #[allow(unused_unsafe, clippy::all)]
          /// Request to flush buffered output. This function never blocks.
          /// 
          /// This tells the output-stream that the caller intends any buffered
          /// output to be flushed. the output which is expected to be flushed
          /// is all that has been passed to `write` prior to this call.
          /// 
          /// Upon calling this function, the `output-stream` will not accept any
          /// writes (`check-write` will return `ok(0)`) until the flush has
          /// completed. The `subscribe` pollable will become ready when the
          /// flush has completed and the stream can accept more writes.
          pub fn flush(&self,) -> Result<(),StreamError>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let ptr0 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
              extern "C" {
                #[link_name = "[method]output-stream.flush"]
                fn wit_import(_: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, ){ unreachable!() }
              wit_import((self).handle() as i32, ptr0);
              let l1 = i32::from(*((ptr0 + 0) as *const u8));
              match l1 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l2 = i32::from(*((ptr0 + 4) as *const u8));
                    let v4 = match l2 {
                      0 => {
                        let e4 = {
                          let l3 = *((ptr0 + 8) as *const i32);
                          
                          super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                        };
                        StreamError::LastOperationFailed(e4)
                      }
                      n => {
                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                        StreamError::Closed
                      }
                    };
                    
                    v4
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
        }
        impl OutputStream {
          #[allow(unused_unsafe, clippy::all)]
          /// Request to flush buffered output, and block until flush completes
          /// and stream is ready for writing again.
          pub fn blocking_flush(&self,) -> Result<(),StreamError>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let ptr0 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
              extern "C" {
                #[link_name = "[method]output-stream.blocking-flush"]
                fn wit_import(_: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, ){ unreachable!() }
              wit_import((self).handle() as i32, ptr0);
              let l1 = i32::from(*((ptr0 + 0) as *const u8));
              match l1 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l2 = i32::from(*((ptr0 + 4) as *const u8));
                    let v4 = match l2 {
                      0 => {
                        let e4 = {
                          let l3 = *((ptr0 + 8) as *const i32);
                          
                          super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                        };
                        StreamError::LastOperationFailed(e4)
                      }
                      n => {
                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                        StreamError::Closed
                      }
                    };
                    
                    v4
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
        }
        impl OutputStream {
          #[allow(unused_unsafe, clippy::all)]
          /// Create a `pollable` which will resolve once the output-stream
          /// is ready for more writing, or an error has occured. When this
          /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
          /// error.
          /// 
          /// If the stream is closed, this pollable is always ready immediately.
          /// 
          /// The created `pollable` is a child resource of the `output-stream`.
          /// Implementations may trap if the `output-stream` is dropped before
          /// all derived `pollable`s created with this function are dropped.
          pub fn subscribe(&self,) -> Pollable{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
              extern "C" {
                #[link_name = "[method]output-stream.subscribe"]
                fn wit_import(_: i32, ) -> i32;
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, ) -> i32{ unreachable!() }
              let ret = wit_import((self).handle() as i32);
              super::super::super::wasi::io::poll::Pollable::from_handle(ret as u32)
            }
          }
        }
        impl OutputStream {
          #[allow(unused_unsafe, clippy::all)]
          /// Write zeroes to a stream.
          /// 
          /// this should be used precisely like `write` with the exact same
          /// preconditions (must use check-write first), but instead of
          /// passing a list of bytes, you simply pass the number of zero-bytes
          /// that should be written.
          pub fn write_zeroes(&self,len: u64,) -> Result<(),StreamError>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let ptr0 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
              extern "C" {
                #[link_name = "[method]output-stream.write-zeroes"]
                fn wit_import(_: i32, _: i64, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
              wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
              let l1 = i32::from(*((ptr0 + 0) as *const u8));
              match l1 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l2 = i32::from(*((ptr0 + 4) as *const u8));
                    let v4 = match l2 {
                      0 => {
                        let e4 = {
                          let l3 = *((ptr0 + 8) as *const i32);
                          
                          super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                        };
                        StreamError::LastOperationFailed(e4)
                      }
                      n => {
                        debug_assert_eq!(n, 1, "invalid enum discriminant");
                        StreamError::Closed
                      }
                    };
                    
                    v4
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
        }
        impl OutputStream {
          #[allow(unused_unsafe, clippy::all)]
          /// Perform a write of up to 4096 zeroes, and then flush the stream.
          /// Block until all of these operations are complete, or an error
          /// occurs.
          /// 
          /// This is a convenience wrapper around the use of `check-write`,
          /// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
          /// the following pseudo-code:
          /// 
          /// ```text
          /// let pollable = this.subscribe();
          /// while num_zeroes != 0 {
            /// // Wait for the stream to become writable
            /// poll-one(pollable);
            /// let Ok(n) = this.check-write(); // eliding error handling
            /// let len = min(n, num_zeroes);
            /// this.write-zeroes(len);         // eliding error handling
            /// num_zeroes -= len;
            /// }
            /// this.flush();
            /// // Wait for completion of `flush`
            /// poll-one(pollable);
            /// // Check for any errors that arose during `flush`
            /// let _ = this.check-write();         // eliding error handling
            /// ```
            pub fn blocking_write_zeroes_and_flush(&self,len: u64,) -> Result<(),StreamError>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(4))]
                struct RetArea([u8; 12]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                extern "C" {
                  #[link_name = "[method]output-stream.blocking-write-zeroes-and-flush"]
                  fn wit_import(_: i32, _: i64, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i64, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
                let l1 = i32::from(*((ptr0 + 0) as *const u8));
                match l1 {
                  0 => {
                    let e = ();
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l2 = i32::from(*((ptr0 + 4) as *const u8));
                      let v4 = match l2 {
                        0 => {
                          let e4 = {
                            let l3 = *((ptr0 + 8) as *const i32);
                            
                            super::super::super::wasi::io::error::Error::from_handle(l3 as u32)
                          };
                          StreamError::LastOperationFailed(e4)
                        }
                        n => {
                          debug_assert_eq!(n, 1, "invalid enum discriminant");
                          StreamError::Closed
                        }
                      };
                      
                      v4
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          impl OutputStream {
            #[allow(unused_unsafe, clippy::all)]
            /// Read from one stream and write to another.
            /// 
            /// The behavior of splice is equivelant to:
            /// 1. calling `check-write` on the `output-stream`
            /// 2. calling `read` on the `input-stream` with the smaller of the
            /// `check-write` permitted length and the `len` provided to `splice`
            /// 3. calling `write` on the `output-stream` with that read data.
            /// 
            /// Any error reported by the call to `check-write`, `read`, or
            /// `write` ends the splice and reports that error.
            /// 
            /// This function returns the number of bytes transferred; it may be less
            /// than `len`.
            pub fn splice(&self,src: &InputStream,len: u64,) -> Result<u64,StreamError>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(8))]
                struct RetArea([u8; 16]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                extern "C" {
                  #[link_name = "[method]output-stream.splice"]
                  fn wit_import(_: i32, _: i32, _: i64, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i32, _: i64, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, (src).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
                let l1 = i32::from(*((ptr0 + 0) as *const u8));
                match l1 {
                  0 => {
                    let e = {
                      let l2 = *((ptr0 + 8) as *const i64);
                      
                      l2 as u64
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l3 = i32::from(*((ptr0 + 8) as *const u8));
                      let v5 = match l3 {
                        0 => {
                          let e5 = {
                            let l4 = *((ptr0 + 12) as *const i32);
                            
                            super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                          };
                          StreamError::LastOperationFailed(e5)
                        }
                        n => {
                          debug_assert_eq!(n, 1, "invalid enum discriminant");
                          StreamError::Closed
                        }
                      };
                      
                      v5
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          impl OutputStream {
            #[allow(unused_unsafe, clippy::all)]
            /// Read from one stream and write to another, with blocking.
            /// 
            /// This is similar to `splice`, except that it blocks until the
            /// `output-stream` is ready for writing, and the `input-stream`
            /// is ready for reading, before performing the `splice`.
            pub fn blocking_splice(&self,src: &InputStream,len: u64,) -> Result<u64,StreamError>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(8))]
                struct RetArea([u8; 16]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:io/streams@0.2.0")]
                extern "C" {
                  #[link_name = "[method]output-stream.blocking-splice"]
                  fn wit_import(_: i32, _: i32, _: i64, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i32, _: i64, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, (src).handle() as i32, wit_bindgen::rt::as_i64(len), ptr0);
                let l1 = i32::from(*((ptr0 + 0) as *const u8));
                match l1 {
                  0 => {
                    let e = {
                      let l2 = *((ptr0 + 8) as *const i64);
                      
                      l2 as u64
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l3 = i32::from(*((ptr0 + 8) as *const u8));
                      let v5 = match l3 {
                        0 => {
                          let e5 = {
                            let l4 = *((ptr0 + 12) as *const i32);
                            
                            super::super::super::wasi::io::error::Error::from_handle(l4 as u32)
                          };
                          StreamError::LastOperationFailed(e5)
                        }
                        n => {
                          debug_assert_eq!(n, 1, "invalid enum discriminant");
                          StreamError::Closed
                        }
                      };
                      
                      v5
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          
        }
        
      }
      pub mod keyvalue {
        
        #[allow(clippy::all)]
        pub mod wasi_keyvalue_error {
          #[used]
          #[doc(hidden)]
          #[cfg(target_arch = "wasm32")]
          static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
          /// An error resource type for keyvalue operations.
          /// 
          /// Common errors:
          /// - Connectivity errors (e.g. network errors): when the client cannot establish
          /// a connection to the keyvalue service.
          /// - Authentication and Authorization errors: when the client fails to authenticate
          /// or does not have the required permissions to perform the operation.
          /// - Data errors: when the client sends incompatible or corrupted data.
          /// - Resource errors: when the system runs out of resources (e.g. memory).
          /// - Internal errors: unexpected errors on the server side.
          /// 
          /// Currently, this provides only one function to return a string representation
          /// of the error. In the future, this will be extended to provide more information
          /// about the error.
          /// Soon: switch to `resource error { ... }`
          
          #[derive(Debug)]
          #[repr(transparent)]
          pub struct Error{
            handle: wit_bindgen::rt::Resource<Error>,
          }
          
          impl Error{
            #[doc(hidden)]
            pub unsafe fn from_handle(handle: u32) -> Self {
              Self {
                handle: wit_bindgen::rt::Resource::from_handle(handle),
              }
            }
            
            #[doc(hidden)]
            pub fn into_handle(self) -> u32 {
              wit_bindgen::rt::Resource::into_handle(self.handle)
            }
            
            #[doc(hidden)]
            pub fn handle(&self) -> u32 {
              wit_bindgen::rt::Resource::handle(&self.handle)
            }
          }
          
          
          unsafe impl wit_bindgen::rt::WasmResource for Error{
            #[inline]
            unsafe fn drop(_handle: u32) {
              #[cfg(not(target_arch = "wasm32"))]
              unreachable!();
              
              #[cfg(target_arch = "wasm32")]
              {
                #[link(wasm_import_module = "wasi:keyvalue/wasi-keyvalue-error@0.1.0")]
                extern "C" {
                  #[link_name = "[resource-drop]error"]
                  fn drop(_: u32);
                }
                
                drop(_handle);
              }
            }
          }
          
          impl Error {
            #[allow(unused_unsafe, clippy::all)]
            pub fn trace(&self,) -> wit_bindgen::rt::string::String{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(4))]
                struct RetArea([u8; 8]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:keyvalue/wasi-keyvalue-error@0.1.0")]
                extern "C" {
                  #[link_name = "[method]error.trace"]
                  fn wit_import(_: i32, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, ptr0);
                let l1 = *((ptr0 + 0) as *const i32);
                let l2 = *((ptr0 + 4) as *const i32);
                let len3 = l2 as usize;
                let bytes3 = Vec::from_raw_parts(l1 as *mut _, len3, len3);
                wit_bindgen::rt::string_lift(bytes3)
              }
            }
          }
          
        }
        
        
        #[allow(clippy::all)]
        pub mod types {
          #[used]
          #[doc(hidden)]
          #[cfg(target_arch = "wasm32")]
          static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
          pub type InputStream = super::super::super::wasi::io::streams::InputStream;
          pub type OutputStream = super::super::super::wasi::io::streams::OutputStream;
          pub type Error = super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error;
          /// A bucket is a collection of key-value pairs. Each key-value pair is stored
          /// as a entry in the bucket, and the bucket itself acts as a collection of all
          /// these entries.
          /// 
          /// It is worth noting that the exact terminology for bucket in key-value stores
          /// can very depending on the specific implementation. For example,
          /// 1. Amazon DynamoDB calls a collection of key-value pairs a table
          /// 2. Redis has hashes, sets, and sorted sets as different types of collections
          /// 3. Cassandra calls a collection of key-value pairs a column family
          /// 4. MongoDB calls a collection of key-value pairs a collection
          /// 5. Riak calls a collection of key-value pairs a bucket
          /// 6. Memcached calls a collection of key-value pairs a slab
          /// 7. Azure Cosmos DB calls a collection of key-value pairs a container
          /// 
          /// In this interface, we use the term `bucket` to refer to a collection of key-value
          /// Soon: switch to `resource bucket { ... }`
          
          #[derive(Debug)]
          #[repr(transparent)]
          pub struct Bucket{
            handle: wit_bindgen::rt::Resource<Bucket>,
          }
          
          impl Bucket{
            #[doc(hidden)]
            pub unsafe fn from_handle(handle: u32) -> Self {
              Self {
                handle: wit_bindgen::rt::Resource::from_handle(handle),
              }
            }
            
            #[doc(hidden)]
            pub fn into_handle(self) -> u32 {
              wit_bindgen::rt::Resource::into_handle(self.handle)
            }
            
            #[doc(hidden)]
            pub fn handle(&self) -> u32 {
              wit_bindgen::rt::Resource::handle(&self.handle)
            }
          }
          
          
          unsafe impl wit_bindgen::rt::WasmResource for Bucket{
            #[inline]
            unsafe fn drop(_handle: u32) {
              #[cfg(not(target_arch = "wasm32"))]
              unreachable!();
              
              #[cfg(target_arch = "wasm32")]
              {
                #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                extern "C" {
                  #[link_name = "[resource-drop]bucket"]
                  fn drop(_: u32);
                }
                
                drop(_handle);
              }
            }
          }
          
          /// A key is a unique identifier for a value in a bucket. The key is used to
          /// retrieve the value from the bucket.
          pub type Key = wit_bindgen::rt::string::String;
          /// A value is the data stored in a key-value pair. The value can be of any type
          /// that can be represented in a byte array. It provides a way to write the value
          /// to the output-stream defined in the `wasi-io` interface.
          /// Soon: switch to `resource value { ... }`
          
          #[derive(Debug)]
          #[repr(transparent)]
          pub struct OutgoingValue{
            handle: wit_bindgen::rt::Resource<OutgoingValue>,
          }
          
          impl OutgoingValue{
            #[doc(hidden)]
            pub unsafe fn from_handle(handle: u32) -> Self {
              Self {
                handle: wit_bindgen::rt::Resource::from_handle(handle),
              }
            }
            
            #[doc(hidden)]
            pub fn into_handle(self) -> u32 {
              wit_bindgen::rt::Resource::into_handle(self.handle)
            }
            
            #[doc(hidden)]
            pub fn handle(&self) -> u32 {
              wit_bindgen::rt::Resource::handle(&self.handle)
            }
          }
          
          
          unsafe impl wit_bindgen::rt::WasmResource for OutgoingValue{
            #[inline]
            unsafe fn drop(_handle: u32) {
              #[cfg(not(target_arch = "wasm32"))]
              unreachable!();
              
              #[cfg(target_arch = "wasm32")]
              {
                #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                extern "C" {
                  #[link_name = "[resource-drop]outgoing-value"]
                  fn drop(_: u32);
                }
                
                drop(_handle);
              }
            }
          }
          
          pub type OutgoingValueBodyAsync = OutputStream;
          pub type OutgoingValueBodySync = wit_bindgen::rt::vec::Vec::<u8>;
          /// A incoming-value is a wrapper around a value. It provides a way to read the value
          /// from the `input-stream` defined in the `wasi-io` interface.
          /// 
          /// The incoming-value provides two ways to consume the value:
          /// 1. `incoming-value-consume-sync` consumes the value synchronously and returns the
          /// value as a `list<u8>`.
          /// 2. `incoming-value-consume-async` consumes the value asynchronously and returns the
          /// value as an `input-stream`.
          /// In addition, it provides a `incoming-value-size` function to get the size of the value.
          /// This is useful when the value is large and the caller wants to allocate a buffer of
          /// the right size to consume the value.
          /// Soon: switch to `resource incoming-value { ... }`
          
          #[derive(Debug)]
          #[repr(transparent)]
          pub struct IncomingValue{
            handle: wit_bindgen::rt::Resource<IncomingValue>,
          }
          
          impl IncomingValue{
            #[doc(hidden)]
            pub unsafe fn from_handle(handle: u32) -> Self {
              Self {
                handle: wit_bindgen::rt::Resource::from_handle(handle),
              }
            }
            
            #[doc(hidden)]
            pub fn into_handle(self) -> u32 {
              wit_bindgen::rt::Resource::into_handle(self.handle)
            }
            
            #[doc(hidden)]
            pub fn handle(&self) -> u32 {
              wit_bindgen::rt::Resource::handle(&self.handle)
            }
          }
          
          
          unsafe impl wit_bindgen::rt::WasmResource for IncomingValue{
            #[inline]
            unsafe fn drop(_handle: u32) {
              #[cfg(not(target_arch = "wasm32"))]
              unreachable!();
              
              #[cfg(target_arch = "wasm32")]
              {
                #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                extern "C" {
                  #[link_name = "[resource-drop]incoming-value"]
                  fn drop(_: u32);
                }
                
                drop(_handle);
              }
            }
          }
          
          pub type IncomingValueAsyncBody = InputStream;
          pub type IncomingValueSyncBody = wit_bindgen::rt::vec::Vec::<u8>;
          impl Bucket {
            #[allow(unused_unsafe, clippy::all)]
            /// Opens a bucket with the given name.
            /// 
            /// If any error occurs, including if the bucket does not exist, it returns an `Err(error)`.
            pub fn open_bucket(name: &str,) -> Result<Bucket,Error>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(4))]
                struct RetArea([u8; 8]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let vec0 = name;
                let ptr0 = vec0.as_ptr() as i32;
                let len0 = vec0.len() as i32;
                let ptr1 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                extern "C" {
                  #[link_name = "[static]bucket.open-bucket"]
                  fn wit_import(_: i32, _: i32, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
                wit_import(ptr0, len0, ptr1);
                let l2 = i32::from(*((ptr1 + 0) as *const u8));
                match l2 {
                  0 => {
                    let e = {
                      let l3 = *((ptr1 + 4) as *const i32);
                      
                      Bucket::from_handle(l3 as u32)
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l4 = *((ptr1 + 4) as *const i32);
                      
                      super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l4 as u32)
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          impl OutgoingValue {
            #[allow(unused_unsafe, clippy::all)]
            pub fn new_outgoing_value() -> OutgoingValue{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                extern "C" {
                  #[link_name = "[static]outgoing-value.new-outgoing-value"]
                  fn wit_import() -> i32;
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import() -> i32{ unreachable!() }
                let ret = wit_import();
                OutgoingValue::from_handle(ret as u32)
              }
            }
          }
          impl OutgoingValue {
            #[allow(unused_unsafe, clippy::all)]
            /// Writes the value to the output-stream asynchronously.
            /// If any other error occurs, it returns an `Err(error)`.
            pub fn outgoing_value_write_body_async(&self,) -> Result<OutgoingValueBodyAsync,Error>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(4))]
                struct RetArea([u8; 8]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                extern "C" {
                  #[link_name = "[method]outgoing-value.outgoing-value-write-body-async"]
                  fn wit_import(_: i32, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, ptr0);
                let l1 = i32::from(*((ptr0 + 0) as *const u8));
                match l1 {
                  0 => {
                    let e = {
                      let l2 = *((ptr0 + 4) as *const i32);
                      
                      super::super::super::wasi::io::streams::OutputStream::from_handle(l2 as u32)
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l3 = *((ptr0 + 4) as *const i32);
                      
                      super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l3 as u32)
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          impl OutgoingValue {
            #[allow(unused_unsafe, clippy::all)]
            /// Writes the value to the output-stream synchronously.
            /// If any other error occurs, it returns an `Err(error)`.
            pub fn outgoing_value_write_body_sync(&self,value: &OutgoingValueBodySync,) -> Result<(),Error>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(4))]
                struct RetArea([u8; 8]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let vec0 = value;
                let ptr0 = vec0.as_ptr() as i32;
                let len0 = vec0.len() as i32;
                let ptr1 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                extern "C" {
                  #[link_name = "[method]outgoing-value.outgoing-value-write-body-sync"]
                  fn wit_import(_: i32, _: i32, _: i32, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, ptr0, len0, ptr1);
                let l2 = i32::from(*((ptr1 + 0) as *const u8));
                match l2 {
                  0 => {
                    let e = ();
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l3 = *((ptr1 + 4) as *const i32);
                      
                      super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l3 as u32)
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          impl IncomingValue {
            #[allow(unused_unsafe, clippy::all)]
            /// Consumes the value synchronously and returns the value as a list of bytes.
            /// If any other error occurs, it returns an `Err(error)`.
            pub fn incoming_value_consume_sync(&self,) -> Result<IncomingValueSyncBody,Error>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(4))]
                struct RetArea([u8; 12]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                extern "C" {
                  #[link_name = "[method]incoming-value.incoming-value-consume-sync"]
                  fn wit_import(_: i32, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, ptr0);
                let l1 = i32::from(*((ptr0 + 0) as *const u8));
                match l1 {
                  0 => {
                    let e = {
                      let l2 = *((ptr0 + 4) as *const i32);
                      let l3 = *((ptr0 + 8) as *const i32);
                      let len4 = l3 as usize;
                      
                      Vec::from_raw_parts(l2 as *mut _, len4, len4)
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l5 = *((ptr0 + 4) as *const i32);
                      
                      super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l5 as u32)
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          impl IncomingValue {
            #[allow(unused_unsafe, clippy::all)]
            /// Consumes the value asynchronously and returns the value as an `input-stream`.
            /// If any other error occurs, it returns an `Err(error)`.
            pub fn incoming_value_consume_async(&self,) -> Result<IncomingValueAsyncBody,Error>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(4))]
                struct RetArea([u8; 8]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                extern "C" {
                  #[link_name = "[method]incoming-value.incoming-value-consume-async"]
                  fn wit_import(_: i32, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, ptr0);
                let l1 = i32::from(*((ptr0 + 0) as *const u8));
                match l1 {
                  0 => {
                    let e = {
                      let l2 = *((ptr0 + 4) as *const i32);
                      
                      super::super::super::wasi::io::streams::InputStream::from_handle(l2 as u32)
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l3 = *((ptr0 + 4) as *const i32);
                      
                      super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l3 as u32)
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          impl IncomingValue {
            #[allow(unused_unsafe, clippy::all)]
            /// The size of the value in bytes.
            /// If the size is unknown or unavailable, this function returns an `Err(error)`.
            pub fn incoming_value_size(&self,) -> Result<u64,Error>{
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                
                #[repr(align(8))]
                struct RetArea([u8; 16]);
                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;
                #[cfg(target_arch = "wasm32")]
                #[link(wasm_import_module = "wasi:keyvalue/types@0.1.0")]
                extern "C" {
                  #[link_name = "[method]incoming-value.incoming-value-size"]
                  fn wit_import(_: i32, _: i32, );
                }
                
                #[cfg(not(target_arch = "wasm32"))]
                fn wit_import(_: i32, _: i32, ){ unreachable!() }
                wit_import((self).handle() as i32, ptr0);
                let l1 = i32::from(*((ptr0 + 0) as *const u8));
                match l1 {
                  0 => {
                    let e = {
                      let l2 = *((ptr0 + 8) as *const i64);
                      
                      l2 as u64
                    };
                    Ok(e)
                  }
                  1 => {
                    let e = {
                      let l3 = *((ptr0 + 8) as *const i32);
                      
                      super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l3 as u32)
                    };
                    Err(e)
                  }
                  _ => wit_bindgen::rt::invalid_enum_discriminant(),
                }
              }
            }
          }
          
        }
        
        
        #[allow(clippy::all)]
        pub mod eventual_batch {
          #[used]
          #[doc(hidden)]
          #[cfg(target_arch = "wasm32")]
          static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
          pub type Bucket = super::super::super::wasi::keyvalue::types::Bucket;
          pub type Error = super::super::super::wasi::keyvalue::types::Error;
          pub type Key = super::super::super::wasi::keyvalue::types::Key;
          pub type IncomingValue = super::super::super::wasi::keyvalue::types::IncomingValue;
          pub type OutgoingValue = super::super::super::wasi::keyvalue::types::OutgoingValue;
          #[allow(unused_unsafe, clippy::all)]
          /// Get the values associated with the keys in the bucket. It returns a list of
          /// incoming-value that can be consumed to get the value associated with the key.
          /// 
          /// If any of the keys do not exist in the bucket, it returns a `none` value for
          /// that key in the list.
          /// 
          /// Note that the key-value pairs are guaranteed to be returned in the same order
          /// 
          /// MAY show an out-of-date value if there are concurrent writes to the bucket.
          /// 
          /// If any other error occurs, it returns an `Err(error)`.
          pub fn get_many(bucket: &Bucket,keys: &[Key],) -> Result<wit_bindgen::rt::vec::Vec::<Option<IncomingValue>>,Error>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let vec1 = keys;
              let len1 = vec1.len() as i32;
              let layout1 = alloc::Layout::from_size_align_unchecked(vec1.len() * 8, 4);
              let result1 = if layout1.size() != 0
              {
                let ptr = alloc::alloc(layout1);
                if ptr.is_null()
                {
                  alloc::handle_alloc_error(layout1);
                }
                ptr
              }else {{
                ::core::ptr::null_mut()
              }};
              for (i, e) in vec1.into_iter().enumerate() {
                let base = result1 as i32 + (i as i32) * 8;
                {
                  let vec0 = e;
                  let ptr0 = vec0.as_ptr() as i32;
                  let len0 = vec0.len() as i32;
                  *((base + 4) as *mut i32) = len0;
                  *((base + 0) as *mut i32) = ptr0;
                }
              }
              let ptr2 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:keyvalue/eventual-batch@0.1.0")]
              extern "C" {
                #[link_name = "get-many"]
                fn wit_import(_: i32, _: i32, _: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
              wit_import((bucket).handle() as i32, result1 as i32, len1, ptr2);
              let l3 = i32::from(*((ptr2 + 0) as *const u8));
              if layout1.size() != 0 {
                alloc::dealloc(result1, layout1);
              }
              match l3 {
                0 => {
                  let e = {
                    let l4 = *((ptr2 + 4) as *const i32);
                    let l5 = *((ptr2 + 8) as *const i32);
                    let base8 = l4;
                    let len8 = l5;
                    let mut result8 = Vec::with_capacity(len8 as usize);
                    for i in 0..len8 {
                      let base = base8 + i * 8;
                      let e8 = {
                        let l6 = i32::from(*((base + 0) as *const u8));
                        
                        match l6 {
                          0 => None,
                          1 => {
                            let e = {
                              let l7 = *((base + 4) as *const i32);
                              
                              super::super::super::wasi::keyvalue::types::IncomingValue::from_handle(l7 as u32)
                            };
                            Some(e)
                          }
                          _ => wit_bindgen::rt::invalid_enum_discriminant(),
                        }
                      };
                      result8.push(e8);
                    }
                    wit_bindgen::rt::dealloc(base8, (len8 as usize) * 8, 4);
                    
                    result8
                  };
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l9 = *((ptr2 + 4) as *const i32);
                    
                    super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l9 as u32)
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
          #[allow(unused_unsafe, clippy::all)]
          /// Get all the keys in the bucket. It returns a list of keys.
          /// 
          /// Note that the keys are not guaranteed to be returned in any particular order.
          /// 
          /// If the bucket is empty, it returns an empty list.
          /// 
          /// MAY show an out-of-date list of keys if there are concurrent writes to the bucket.
          /// 
          /// If any error occurs, it returns an `Err(error)`.
          pub fn keys(bucket: &Bucket,) -> Result<wit_bindgen::rt::vec::Vec::<Key>,Error>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let ptr0 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:keyvalue/eventual-batch@0.1.0")]
              extern "C" {
                #[link_name = "keys"]
                fn wit_import(_: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, ){ unreachable!() }
              wit_import((bucket).handle() as i32, ptr0);
              let l1 = i32::from(*((ptr0 + 0) as *const u8));
              match l1 {
                0 => {
                  let e = {
                    let l2 = *((ptr0 + 4) as *const i32);
                    let l3 = *((ptr0 + 8) as *const i32);
                    let base7 = l2;
                    let len7 = l3;
                    let mut result7 = Vec::with_capacity(len7 as usize);
                    for i in 0..len7 {
                      let base = base7 + i * 8;
                      let e7 = {
                        let l4 = *((base + 0) as *const i32);
                        let l5 = *((base + 4) as *const i32);
                        let len6 = l5 as usize;
                        let bytes6 = Vec::from_raw_parts(l4 as *mut _, len6, len6);
                        
                        wit_bindgen::rt::string_lift(bytes6)
                      };
                      result7.push(e7);
                    }
                    wit_bindgen::rt::dealloc(base7, (len7 as usize) * 8, 4);
                    
                    result7
                  };
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l8 = *((ptr0 + 4) as *const i32);
                    
                    super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l8 as u32)
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
          #[allow(unused_unsafe, clippy::all)]
          /// Set the values associated with the keys in the bucket. If the key already
          /// exists in the bucket, it overwrites the value.
          /// 
          /// Note that the key-value pairs are not guaranteed to be set in the order
          /// they are provided.
          /// 
          /// If any of the keys do not exist in the bucket, it creates a new key-value pair.
          /// 
          /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it
          /// does not rollback the key-value pairs that were already set. Thus, this batch operation
          /// does not guarantee atomicity, implying that some key-value pairs could be
          /// set while others might fail.
          /// 
          /// Other concurrent operations may also be able to see the partial results.
          pub fn set_many(bucket: &Bucket,key_values: &[(Key,&OutgoingValue,)],) -> Result<(),Error>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 8]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let vec2 = key_values;
              let len2 = vec2.len() as i32;
              let layout2 = alloc::Layout::from_size_align_unchecked(vec2.len() * 12, 4);
              let result2 = if layout2.size() != 0
              {
                let ptr = alloc::alloc(layout2);
                if ptr.is_null()
                {
                  alloc::handle_alloc_error(layout2);
                }
                ptr
              }else {{
                ::core::ptr::null_mut()
              }};
              for (i, e) in vec2.into_iter().enumerate() {
                let base = result2 as i32 + (i as i32) * 12;
                {
                  let (t0_0, t0_1, ) = e;
                  let vec1 = t0_0;
                  let ptr1 = vec1.as_ptr() as i32;
                  let len1 = vec1.len() as i32;
                  *((base + 4) as *mut i32) = len1;
                  *((base + 0) as *mut i32) = ptr1;
                  *((base + 8) as *mut i32) = (t0_1).handle() as i32;
                }
              }
              let ptr3 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:keyvalue/eventual-batch@0.1.0")]
              extern "C" {
                #[link_name = "set-many"]
                fn wit_import(_: i32, _: i32, _: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
              wit_import((bucket).handle() as i32, result2 as i32, len2, ptr3);
              let l4 = i32::from(*((ptr3 + 0) as *const u8));
              if layout2.size() != 0 {
                alloc::dealloc(result2, layout2);
              }
              match l4 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l5 = *((ptr3 + 4) as *const i32);
                    
                    super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l5 as u32)
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
          #[allow(unused_unsafe, clippy::all)]
          /// Delete the key-value pairs associated with the keys in the bucket.
          /// 
          /// Note that the key-value pairs are not guaranteed to be deleted in the order
          /// they are provided.
          /// 
          /// If any of the keys do not exist in the bucket, it skips the key.
          /// 
          /// If any other error occurs, it returns an `Err(error)`. When an error occurs, it
          /// does not rollback the key-value pairs that were already deleted. Thus, this batch operation
          /// does not guarantee atomicity, implying that some key-value pairs could be
          /// deleted while others might fail.
          /// 
          /// Other concurrent operations may also be able to see the partial results.
          pub fn delete_many(bucket: &Bucket,keys: &[Key],) -> Result<(),Error>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 8]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let vec1 = keys;
              let len1 = vec1.len() as i32;
              let layout1 = alloc::Layout::from_size_align_unchecked(vec1.len() * 8, 4);
              let result1 = if layout1.size() != 0
              {
                let ptr = alloc::alloc(layout1);
                if ptr.is_null()
                {
                  alloc::handle_alloc_error(layout1);
                }
                ptr
              }else {{
                ::core::ptr::null_mut()
              }};
              for (i, e) in vec1.into_iter().enumerate() {
                let base = result1 as i32 + (i as i32) * 8;
                {
                  let vec0 = e;
                  let ptr0 = vec0.as_ptr() as i32;
                  let len0 = vec0.len() as i32;
                  *((base + 4) as *mut i32) = len0;
                  *((base + 0) as *mut i32) = ptr0;
                }
              }
              let ptr2 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:keyvalue/eventual-batch@0.1.0")]
              extern "C" {
                #[link_name = "delete-many"]
                fn wit_import(_: i32, _: i32, _: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
              wit_import((bucket).handle() as i32, result1 as i32, len1, ptr2);
              let l3 = i32::from(*((ptr2 + 0) as *const u8));
              if layout1.size() != 0 {
                alloc::dealloc(result1, layout1);
              }
              match l3 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l4 = *((ptr2 + 4) as *const i32);
                    
                    super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l4 as u32)
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
          
        }
        
        
        #[allow(clippy::all)]
        pub mod eventual {
          #[used]
          #[doc(hidden)]
          #[cfg(target_arch = "wasm32")]
          static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
          pub type Bucket = super::super::super::wasi::keyvalue::types::Bucket;
          pub type Error = super::super::super::wasi::keyvalue::types::Error;
          pub type IncomingValue = super::super::super::wasi::keyvalue::types::IncomingValue;
          pub type Key = super::super::super::wasi::keyvalue::types::Key;
          pub type OutgoingValue = super::super::super::wasi::keyvalue::types::OutgoingValue;
          #[allow(unused_unsafe, clippy::all)]
          /// Get the value associated with the key in the bucket.
          /// 
          /// The value is returned as an option. If the key-value pair exists in the
          /// bucket, it returns `Ok(value)`. If the key does not exist in the
          /// bucket, it returns `Ok(none)`.
          /// 
          /// If any other error occurs, it returns an `Err(error)`.
          pub fn get(bucket: &Bucket,key: &Key,) -> Result<Option<IncomingValue>,Error>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let vec0 = key;
              let ptr0 = vec0.as_ptr() as i32;
              let len0 = vec0.len() as i32;
              let ptr1 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:keyvalue/eventual@0.1.0")]
              extern "C" {
                #[link_name = "get"]
                fn wit_import(_: i32, _: i32, _: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
              wit_import((bucket).handle() as i32, ptr0, len0, ptr1);
              let l2 = i32::from(*((ptr1 + 0) as *const u8));
              match l2 {
                0 => {
                  let e = {
                    let l3 = i32::from(*((ptr1 + 4) as *const u8));
                    
                    match l3 {
                      0 => None,
                      1 => {
                        let e = {
                          let l4 = *((ptr1 + 8) as *const i32);
                          
                          super::super::super::wasi::keyvalue::types::IncomingValue::from_handle(l4 as u32)
                        };
                        Some(e)
                      }
                      _ => wit_bindgen::rt::invalid_enum_discriminant(),
                    }
                  };
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l5 = *((ptr1 + 4) as *const i32);
                    
                    super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l5 as u32)
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
          #[allow(unused_unsafe, clippy::all)]
          /// Set the value associated with the key in the bucket. If the key already
          /// exists in the bucket, it overwrites the value.
          /// 
          /// If the key does not exist in the bucket, it creates a new key-value pair.
          /// 
          /// If any other error occurs, it returns an `Err(error)`.
          pub fn set(bucket: &Bucket,key: &Key,outgoing_value: &OutgoingValue,) -> Result<(),Error>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 8]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let vec0 = key;
              let ptr0 = vec0.as_ptr() as i32;
              let len0 = vec0.len() as i32;
              let ptr1 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:keyvalue/eventual@0.1.0")]
              extern "C" {
                #[link_name = "set"]
                fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
              wit_import((bucket).handle() as i32, ptr0, len0, (outgoing_value).handle() as i32, ptr1);
              let l2 = i32::from(*((ptr1 + 0) as *const u8));
              match l2 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l3 = *((ptr1 + 4) as *const i32);
                    
                    super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l3 as u32)
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
          #[allow(unused_unsafe, clippy::all)]
          /// Delete the key-value pair associated with the key in the bucket.
          /// 
          /// If the key does not exist in the bucket, it does nothing.
          /// 
          /// If any other error occurs, it returns an `Err(error)`.
          pub fn delete(bucket: &Bucket,key: &Key,) -> Result<(),Error>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 8]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let vec0 = key;
              let ptr0 = vec0.as_ptr() as i32;
              let len0 = vec0.len() as i32;
              let ptr1 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:keyvalue/eventual@0.1.0")]
              extern "C" {
                #[link_name = "delete"]
                fn wit_import(_: i32, _: i32, _: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
              wit_import((bucket).handle() as i32, ptr0, len0, ptr1);
              let l2 = i32::from(*((ptr1 + 0) as *const u8));
              match l2 {
                0 => {
                  let e = ();
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l3 = *((ptr1 + 4) as *const i32);
                    
                    super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l3 as u32)
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
          #[allow(unused_unsafe, clippy::all)]
          /// Check if the key exists in the bucket.
          /// 
          /// If the key exists in the bucket, it returns `Ok(true)`. If the key does
          /// not exist in the bucket, it returns `Ok(false)`.
          /// 
          /// If any other error occurs, it returns an `Err(error)`.
          pub fn exists(bucket: &Bucket,key: &Key,) -> Result<bool,Error>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 8]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let vec0 = key;
              let ptr0 = vec0.as_ptr() as i32;
              let len0 = vec0.len() as i32;
              let ptr1 = ret_area.as_mut_ptr() as i32;
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:keyvalue/eventual@0.1.0")]
              extern "C" {
                #[link_name = "exists"]
                fn wit_import(_: i32, _: i32, _: i32, _: i32, );
              }
              
              #[cfg(not(target_arch = "wasm32"))]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
              wit_import((bucket).handle() as i32, ptr0, len0, ptr1);
              let l2 = i32::from(*((ptr1 + 0) as *const u8));
              match l2 {
                0 => {
                  let e = {
                    let l3 = i32::from(*((ptr1 + 4) as *const u8));
                    
                    wit_bindgen::rt::bool_lift(l3 as u8)
                  };
                  Ok(e)
                }
                1 => {
                  let e = {
                    let l4 = *((ptr1 + 4) as *const i32);
                    
                    super::super::super::wasi::keyvalue::wasi_keyvalue_error::Error::from_handle(l4 as u32)
                  };
                  Err(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              }
            }
          }
          
        }
        
      }
    }
    pub mod exports {
      pub mod golem {
        pub mod it {
          
          #[allow(clippy::all)]
          pub mod api {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_section;
            const _: () = {
              
              #[doc(hidden)]
              #[export_name = "golem:it/api#delete"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_delete(arg0: i32,arg1: i32,arg2: i32,arg3: i32,) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                
                // Before executing any other code, use this function to run all static
                // constructors, if they have not yet been run. This is a hack required
                // to work around wasi-libc ctors calling import functions to initialize
                // the environment.
                //
                // This functionality will be removed once rust 1.69.0 is stable, at which
                // point wasi-libc will no longer have this behavior.
                //
                // See
                // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                // for more details.
                #[cfg(target_arch="wasm32")]
                wit_bindgen::rt::run_ctors_once();
                
                let len0 = arg1 as usize;
                let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
                let len1 = arg3 as usize;
                let bytes1 = Vec::from_raw_parts(arg2 as *mut _, len1, len1);
                <_GuestImpl as Guest>::delete(wit_bindgen::rt::string_lift(bytes0), wit_bindgen::rt::string_lift(bytes1));
              }
            };
            const _: () = {
              
              #[doc(hidden)]
              #[export_name = "golem:it/api#delete-many"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_delete_many(arg0: i32,arg1: i32,arg2: i32,arg3: i32,) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                
                // Before executing any other code, use this function to run all static
                // constructors, if they have not yet been run. This is a hack required
                // to work around wasi-libc ctors calling import functions to initialize
                // the environment.
                //
                // This functionality will be removed once rust 1.69.0 is stable, at which
                // point wasi-libc will no longer have this behavior.
                //
                // See
                // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                // for more details.
                #[cfg(target_arch="wasm32")]
                wit_bindgen::rt::run_ctors_once();
                
                let len0 = arg1 as usize;
                let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
                let base4 = arg2;
                let len4 = arg3;
                let mut result4 = Vec::with_capacity(len4 as usize);
                for i in 0..len4 {
                  let base = base4 + i * 8;
                  let e4 = {
                    let l1 = *((base + 0) as *const i32);
                    let l2 = *((base + 4) as *const i32);
                    let len3 = l2 as usize;
                    let bytes3 = Vec::from_raw_parts(l1 as *mut _, len3, len3);
                    
                    wit_bindgen::rt::string_lift(bytes3)
                  };
                  result4.push(e4);
                }
                wit_bindgen::rt::dealloc(base4, (len4 as usize) * 8, 4);
                <_GuestImpl as Guest>::delete_many(wit_bindgen::rt::string_lift(bytes0), result4);
              }
            };
            const _: () = {
              
              #[doc(hidden)]
              #[export_name = "golem:it/api#exists"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_exists(arg0: i32,arg1: i32,arg2: i32,arg3: i32,) -> i32 {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                
                // Before executing any other code, use this function to run all static
                // constructors, if they have not yet been run. This is a hack required
                // to work around wasi-libc ctors calling import functions to initialize
                // the environment.
                //
                // This functionality will be removed once rust 1.69.0 is stable, at which
                // point wasi-libc will no longer have this behavior.
                //
                // See
                // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                // for more details.
                #[cfg(target_arch="wasm32")]
                wit_bindgen::rt::run_ctors_once();
                
                let len0 = arg1 as usize;
                let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
                let len1 = arg3 as usize;
                let bytes1 = Vec::from_raw_parts(arg2 as *mut _, len1, len1);
                let result2 = <_GuestImpl as Guest>::exists(wit_bindgen::rt::string_lift(bytes0), wit_bindgen::rt::string_lift(bytes1));
                match result2 { true => 1, false => 0 }
              }
            };
            const _: () = {
              
              #[doc(hidden)]
              #[export_name = "golem:it/api#get"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_get(arg0: i32,arg1: i32,arg2: i32,arg3: i32,) -> i32 {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                
                // Before executing any other code, use this function to run all static
                // constructors, if they have not yet been run. This is a hack required
                // to work around wasi-libc ctors calling import functions to initialize
                // the environment.
                //
                // This functionality will be removed once rust 1.69.0 is stable, at which
                // point wasi-libc will no longer have this behavior.
                //
                // See
                // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                // for more details.
                #[cfg(target_arch="wasm32")]
                wit_bindgen::rt::run_ctors_once();
                
                let len0 = arg1 as usize;
                let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
                let len1 = arg3 as usize;
                let bytes1 = Vec::from_raw_parts(arg2 as *mut _, len1, len1);
                let result2 = <_GuestImpl as Guest>::get(wit_bindgen::rt::string_lift(bytes0), wit_bindgen::rt::string_lift(bytes1));
                let ptr3 = _RET_AREA.0.as_mut_ptr() as i32;
                match result2 {
                  Some(e) => {
                    *((ptr3 + 0) as *mut u8) = (1i32) as u8;
                    let vec4 = (e).into_boxed_slice();
                    let ptr4 = vec4.as_ptr() as i32;
                    let len4 = vec4.len() as i32;
                    ::core::mem::forget(vec4);
                    *((ptr3 + 8) as *mut i32) = len4;
                    *((ptr3 + 4) as *mut i32) = ptr4;
                  },
                  None => {
                    {
                      *((ptr3 + 0) as *mut u8) = (0i32) as u8;
                    }
                  },
                };ptr3
              }
              
              const _: () = {
                #[doc(hidden)]
                #[export_name = "cabi_post_golem:it/api#get"]
                #[allow(non_snake_case)]
                unsafe extern "C" fn __post_return_get(arg0: i32,) {
                  let l0 = i32::from(*((arg0 + 0) as *const u8));
                  match l0 {
                    0 => (),
                    _ => {
                      let l1 = *((arg0 + 4) as *const i32);
                      let l2 = *((arg0 + 8) as *const i32);
                      let base3 = l1;
                      let len3 = l2;
                      wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                    },
                  }
                }
              };
            };
            const _: () = {
              
              #[doc(hidden)]
              #[export_name = "golem:it/api#get-keys"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_get_keys(arg0: i32,arg1: i32,) -> i32 {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                
                // Before executing any other code, use this function to run all static
                // constructors, if they have not yet been run. This is a hack required
                // to work around wasi-libc ctors calling import functions to initialize
                // the environment.
                //
                // This functionality will be removed once rust 1.69.0 is stable, at which
                // point wasi-libc will no longer have this behavior.
                //
                // See
                // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                // for more details.
                #[cfg(target_arch="wasm32")]
                wit_bindgen::rt::run_ctors_once();
                
                let len0 = arg1 as usize;
                let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
                let result1 = <_GuestImpl as Guest>::get_keys(wit_bindgen::rt::string_lift(bytes0));
                let ptr2 = _RET_AREA.0.as_mut_ptr() as i32;
                let vec4 = result1;
                let len4 = vec4.len() as i32;
                let layout4 = alloc::Layout::from_size_align_unchecked(vec4.len() * 8, 4);
                let result4 = if layout4.size() != 0
                {
                  let ptr = alloc::alloc(layout4);
                  if ptr.is_null()
                  {
                    alloc::handle_alloc_error(layout4);
                  }
                  ptr
                }else {{
                  ::core::ptr::null_mut()
                }};
                for (i, e) in vec4.into_iter().enumerate() {
                  let base = result4 as i32 + (i as i32) * 8;
                  {
                    let vec3 = (e.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr() as i32;
                    let len3 = vec3.len() as i32;
                    ::core::mem::forget(vec3);
                    *((base + 4) as *mut i32) = len3;
                    *((base + 0) as *mut i32) = ptr3;
                  }
                }
                *((ptr2 + 4) as *mut i32) = len4;
                *((ptr2 + 0) as *mut i32) = result4 as i32;
                ptr2
              }
              
              const _: () = {
                #[doc(hidden)]
                #[export_name = "cabi_post_golem:it/api#get-keys"]
                #[allow(non_snake_case)]
                unsafe extern "C" fn __post_return_get_keys(arg0: i32,) {
                  let l2 = *((arg0 + 0) as *const i32);
                  let l3 = *((arg0 + 4) as *const i32);
                  let base4 = l2;
                  let len4 = l3;
                  for i in 0..len4 {
                    let base = base4 + i *8;
                    {
                      let l0 = *((base + 0) as *const i32);
                      let l1 = *((base + 4) as *const i32);
                      wit_bindgen::rt::dealloc(l0, (l1) as usize, 1);
                    }
                  }
                  wit_bindgen::rt::dealloc(base4, (len4 as usize) * 8, 4);
                }
              };
            };
            const _: () = {
              
              #[doc(hidden)]
              #[export_name = "golem:it/api#get-many"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_get_many(arg0: i32,arg1: i32,arg2: i32,arg3: i32,) -> i32 {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                
                // Before executing any other code, use this function to run all static
                // constructors, if they have not yet been run. This is a hack required
                // to work around wasi-libc ctors calling import functions to initialize
                // the environment.
                //
                // This functionality will be removed once rust 1.69.0 is stable, at which
                // point wasi-libc will no longer have this behavior.
                //
                // See
                // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                // for more details.
                #[cfg(target_arch="wasm32")]
                wit_bindgen::rt::run_ctors_once();
                
                let len0 = arg1 as usize;
                let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
                let base4 = arg2;
                let len4 = arg3;
                let mut result4 = Vec::with_capacity(len4 as usize);
                for i in 0..len4 {
                  let base = base4 + i * 8;
                  let e4 = {
                    let l1 = *((base + 0) as *const i32);
                    let l2 = *((base + 4) as *const i32);
                    let len3 = l2 as usize;
                    let bytes3 = Vec::from_raw_parts(l1 as *mut _, len3, len3);
                    
                    wit_bindgen::rt::string_lift(bytes3)
                  };
                  result4.push(e4);
                }
                wit_bindgen::rt::dealloc(base4, (len4 as usize) * 8, 4);
                let result5 = <_GuestImpl as Guest>::get_many(wit_bindgen::rt::string_lift(bytes0), result4);
                let ptr6 = _RET_AREA.0.as_mut_ptr() as i32;
                match result5 {
                  Some(e) => {
                    *((ptr6 + 0) as *mut u8) = (1i32) as u8;
                    let vec8 = e;
                    let len8 = vec8.len() as i32;
                    let layout8 = alloc::Layout::from_size_align_unchecked(vec8.len() * 8, 4);
                    let result8 = if layout8.size() != 0
                    {
                      let ptr = alloc::alloc(layout8);
                      if ptr.is_null()
                      {
                        alloc::handle_alloc_error(layout8);
                      }
                      ptr
                    }else {{
                      ::core::ptr::null_mut()
                    }};
                    for (i, e) in vec8.into_iter().enumerate() {
                      let base = result8 as i32 + (i as i32) * 8;
                      {
                        let vec7 = (e).into_boxed_slice();
                        let ptr7 = vec7.as_ptr() as i32;
                        let len7 = vec7.len() as i32;
                        ::core::mem::forget(vec7);
                        *((base + 4) as *mut i32) = len7;
                        *((base + 0) as *mut i32) = ptr7;
                      }
                    }
                    *((ptr6 + 8) as *mut i32) = len8;
                    *((ptr6 + 4) as *mut i32) = result8 as i32;
                  },
                  None => {
                    {
                      *((ptr6 + 0) as *mut u8) = (0i32) as u8;
                    }
                  },
                };ptr6
              }
              
              const _: () = {
                #[doc(hidden)]
                #[export_name = "cabi_post_golem:it/api#get-many"]
                #[allow(non_snake_case)]
                unsafe extern "C" fn __post_return_get_many(arg0: i32,) {
                  let l0 = i32::from(*((arg0 + 0) as *const u8));
                  match l0 {
                    0 => (),
                    _ => {
                      let l4 = *((arg0 + 4) as *const i32);
                      let l5 = *((arg0 + 8) as *const i32);
                      let base6 = l4;
                      let len6 = l5;
                      for i in 0..len6 {
                        let base = base6 + i *8;
                        {
                          let l1 = *((base + 0) as *const i32);
                          let l2 = *((base + 4) as *const i32);
                          let base3 = l1;
                          let len3 = l2;
                          wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                        }
                      }
                      wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
                    },
                  }
                }
              };
            };
            const _: () = {
              
              #[doc(hidden)]
              #[export_name = "golem:it/api#set"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_set(arg0: i32,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                
                // Before executing any other code, use this function to run all static
                // constructors, if they have not yet been run. This is a hack required
                // to work around wasi-libc ctors calling import functions to initialize
                // the environment.
                //
                // This functionality will be removed once rust 1.69.0 is stable, at which
                // point wasi-libc will no longer have this behavior.
                //
                // See
                // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                // for more details.
                #[cfg(target_arch="wasm32")]
                wit_bindgen::rt::run_ctors_once();
                
                let len0 = arg1 as usize;
                let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
                let len1 = arg3 as usize;
                let bytes1 = Vec::from_raw_parts(arg2 as *mut _, len1, len1);
                let len2 = arg5 as usize;
                <_GuestImpl as Guest>::set(wit_bindgen::rt::string_lift(bytes0), wit_bindgen::rt::string_lift(bytes1), Vec::from_raw_parts(arg4 as *mut _, len2, len2));
              }
            };
            const _: () = {
              
              #[doc(hidden)]
              #[export_name = "golem:it/api#set-many"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_set_many(arg0: i32,arg1: i32,arg2: i32,arg3: i32,) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                
                // Before executing any other code, use this function to run all static
                // constructors, if they have not yet been run. This is a hack required
                // to work around wasi-libc ctors calling import functions to initialize
                // the environment.
                //
                // This functionality will be removed once rust 1.69.0 is stable, at which
                // point wasi-libc will no longer have this behavior.
                //
                // See
                // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                // for more details.
                #[cfg(target_arch="wasm32")]
                wit_bindgen::rt::run_ctors_once();
                
                let len0 = arg1 as usize;
                let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
                let base7 = arg2;
                let len7 = arg3;
                let mut result7 = Vec::with_capacity(len7 as usize);
                for i in 0..len7 {
                  let base = base7 + i * 16;
                  let e7 = {
                    let l1 = *((base + 0) as *const i32);
                    let l2 = *((base + 4) as *const i32);
                    let len3 = l2 as usize;
                    let bytes3 = Vec::from_raw_parts(l1 as *mut _, len3, len3);
                    let l4 = *((base + 8) as *const i32);
                    let l5 = *((base + 12) as *const i32);
                    let len6 = l5 as usize;
                    
                    (wit_bindgen::rt::string_lift(bytes3), Vec::from_raw_parts(l4 as *mut _, len6, len6))
                  };
                  result7.push(e7);
                }
                wit_bindgen::rt::dealloc(base7, (len7 as usize) * 16, 4);
                <_GuestImpl as Guest>::set_many(wit_bindgen::rt::string_lift(bytes0), result7);
              }
            };
            use super::super::super::super::super::Component as _GuestImpl;
            pub trait Guest {
              fn delete(bucket: wit_bindgen::rt::string::String,key: wit_bindgen::rt::string::String,);
              fn delete_many(bucket: wit_bindgen::rt::string::String,keys: wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>,);
              fn exists(bucket: wit_bindgen::rt::string::String,key: wit_bindgen::rt::string::String,) -> bool;
              fn get(bucket: wit_bindgen::rt::string::String,key: wit_bindgen::rt::string::String,) -> Option<wit_bindgen::rt::vec::Vec::<u8>>;
              fn get_keys(bucket: wit_bindgen::rt::string::String,) -> wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>;
              fn get_many(bucket: wit_bindgen::rt::string::String,keys: wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>,) -> Option<wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::vec::Vec::<u8>>>;
              fn set(bucket: wit_bindgen::rt::string::String,key: wit_bindgen::rt::string::String,value: wit_bindgen::rt::vec::Vec::<u8>,);
              fn set_many(bucket: wit_bindgen::rt::string::String,key_values: wit_bindgen::rt::vec::Vec::<(wit_bindgen::rt::string::String,wit_bindgen::rt::vec::Vec::<u8>,)>,);
            }
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            
            #[repr(align(4))]
            struct _RetArea([u8; 12]);
            static mut _RET_AREA: _RetArea = _RetArea([0; 12]);
            
          }
          
        }
      }
    }
    
    #[cfg(target_arch = "wasm32")]
    #[link_section = "component-type:key-value-service"]
    #[doc(hidden)]
    pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 3507] = [3, 0, 17, 107, 101, 121, 45, 118, 97, 108, 117, 101, 45, 115, 101, 114, 118, 105, 99, 101, 0, 97, 115, 109, 13, 0, 1, 0, 7, 166, 2, 1, 65, 2, 1, 66, 23, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 3, 107, 101, 121, 115, 1, 0, 4, 0, 6, 100, 101, 108, 101, 116, 101, 1, 0, 1, 112, 115, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 4, 107, 101, 121, 115, 1, 1, 0, 4, 0, 11, 100, 101, 108, 101, 116, 101, 45, 109, 97, 110, 121, 1, 2, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 3, 107, 101, 121, 115, 0, 127, 4, 0, 6, 101, 120, 105, 115, 116, 115, 1, 3, 1, 112, 125, 1, 107, 4, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 3, 107, 101, 121, 115, 0, 5, 4, 0, 3, 103, 101, 116, 1, 6, 1, 64, 1, 6, 98, 117, 99, 107, 101, 116, 115, 0, 1, 4, 0, 8, 103, 101, 116, 45, 107, 101, 121, 115, 1, 7, 1, 112, 4, 1, 107, 8, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 4, 107, 101, 121, 115, 1, 0, 9, 4, 0, 8, 103, 101, 116, 45, 109, 97, 110, 121, 1, 10, 1, 64, 3, 6, 98, 117, 99, 107, 101, 116, 115, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 4, 1, 0, 4, 0, 3, 115, 101, 116, 1, 11, 1, 111, 2, 115, 4, 1, 112, 12, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 10, 107, 101, 121, 45, 118, 97, 108, 117, 101, 115, 13, 1, 0, 4, 0, 8, 115, 101, 116, 45, 109, 97, 110, 121, 1, 14, 4, 1, 12, 103, 111, 108, 101, 109, 58, 105, 116, 47, 97, 112, 105, 5, 0, 11, 9, 1, 0, 3, 97, 112, 105, 3, 0, 0, 7, 237, 23, 1, 65, 2, 1, 65, 26, 1, 66, 4, 4, 0, 5, 101, 114, 114, 111, 114, 3, 1, 1, 104, 0, 1, 64, 1, 4, 115, 101, 108, 102, 1, 0, 115, 4, 0, 29, 91, 109, 101, 116, 104, 111, 100, 93, 101, 114, 114, 111, 114, 46, 116, 111, 45, 100, 101, 98, 117, 103, 45, 115, 116, 114, 105, 110, 103, 1, 2, 3, 1, 19, 119, 97, 115, 105, 58, 105, 111, 47, 101, 114, 114, 111, 114, 64, 48, 46, 50, 46, 48, 5, 0, 1, 66, 10, 4, 0, 8, 112, 111, 108, 108, 97, 98, 108, 101, 3, 1, 1, 104, 0, 1, 64, 1, 4, 115, 101, 108, 102, 1, 0, 127, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 112, 111, 108, 108, 97, 98, 108, 101, 46, 114, 101, 97, 100, 121, 1, 2, 1, 64, 1, 4, 115, 101, 108, 102, 1, 1, 0, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 112, 111, 108, 108, 97, 98, 108, 101, 46, 98, 108, 111, 99, 107, 1, 3, 1, 112, 1, 1, 112, 121, 1, 64, 1, 2, 105, 110, 4, 0, 5, 4, 0, 4, 112, 111, 108, 108, 1, 6, 3, 1, 18, 119, 97, 115, 105, 58, 105, 111, 47, 112, 111, 108, 108, 64, 48, 46, 50, 46, 48, 5, 1, 2, 3, 0, 0, 5, 101, 114, 114, 111, 114, 2, 3, 0, 1, 8, 112, 111, 108, 108, 97, 98, 108, 101, 1, 66, 40, 2, 3, 2, 1, 2, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 0, 2, 3, 2, 1, 3, 4, 0, 8, 112, 111, 108, 108, 97, 98, 108, 101, 3, 0, 2, 1, 105, 1, 1, 113, 2, 21, 108, 97, 115, 116, 45, 111, 112, 101, 114, 97, 116, 105, 111, 110, 45, 102, 97, 105, 108, 101, 100, 1, 4, 0, 6, 99, 108, 111, 115, 101, 100, 0, 0, 4, 0, 12, 115, 116, 114, 101, 97, 109, 45, 101, 114, 114, 111, 114, 3, 0, 5, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 1, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 1, 1, 104, 7, 1, 112, 125, 1, 106, 1, 10, 1, 6, 1, 64, 2, 4, 115, 101, 108, 102, 9, 3, 108, 101, 110, 119, 0, 11, 4, 0, 25, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 114, 101, 97, 100, 1, 12, 4, 0, 34, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 114, 101, 97, 100, 1, 12, 1, 106, 1, 119, 1, 6, 1, 64, 2, 4, 115, 101, 108, 102, 9, 3, 108, 101, 110, 119, 0, 13, 4, 0, 25, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 115, 107, 105, 112, 1, 14, 4, 0, 34, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 115, 107, 105, 112, 1, 14, 1, 105, 3, 1, 64, 1, 4, 115, 101, 108, 102, 9, 0, 15, 4, 0, 30, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 115, 117, 98, 115, 99, 114, 105, 98, 101, 1, 16, 1, 104, 8, 1, 64, 1, 4, 115, 101, 108, 102, 17, 0, 13, 4, 0, 33, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 99, 104, 101, 99, 107, 45, 119, 114, 105, 116, 101, 1, 18, 1, 106, 0, 1, 6, 1, 64, 2, 4, 115, 101, 108, 102, 17, 8, 99, 111, 110, 116, 101, 110, 116, 115, 10, 0, 19, 4, 0, 27, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 119, 114, 105, 116, 101, 1, 20, 4, 0, 46, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 119, 114, 105, 116, 101, 45, 97, 110, 100, 45, 102, 108, 117, 115, 104, 1, 20, 1, 64, 1, 4, 115, 101, 108, 102, 17, 0, 19, 4, 0, 27, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 102, 108, 117, 115, 104, 1, 21, 4, 0, 36, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 102, 108, 117, 115, 104, 1, 21, 1, 64, 1, 4, 115, 101, 108, 102, 17, 0, 15, 4, 0, 31, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 115, 117, 98, 115, 99, 114, 105, 98, 101, 1, 22, 1, 64, 2, 4, 115, 101, 108, 102, 17, 3, 108, 101, 110, 119, 0, 19, 4, 0, 34, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 119, 114, 105, 116, 101, 45, 122, 101, 114, 111, 101, 115, 1, 23, 4, 0, 53, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 119, 114, 105, 116, 101, 45, 122, 101, 114, 111, 101, 115, 45, 97, 110, 100, 45, 102, 108, 117, 115, 104, 1, 23, 1, 64, 3, 4, 115, 101, 108, 102, 17, 3, 115, 114, 99, 9, 3, 108, 101, 110, 119, 0, 13, 4, 0, 28, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 115, 112, 108, 105, 99, 101, 1, 24, 4, 0, 37, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 46, 98, 108, 111, 99, 107, 105, 110, 103, 45, 115, 112, 108, 105, 99, 101, 1, 24, 3, 1, 21, 119, 97, 115, 105, 58, 105, 111, 47, 115, 116, 114, 101, 97, 109, 115, 64, 48, 46, 50, 46, 48, 5, 4, 1, 66, 4, 4, 0, 5, 101, 114, 114, 111, 114, 3, 1, 1, 104, 0, 1, 64, 1, 4, 115, 101, 108, 102, 1, 0, 115, 4, 0, 19, 91, 109, 101, 116, 104, 111, 100, 93, 101, 114, 114, 111, 114, 46, 116, 114, 97, 99, 101, 1, 2, 3, 1, 39, 119, 97, 115, 105, 58, 107, 101, 121, 118, 97, 108, 117, 101, 47, 119, 97, 115, 105, 45, 107, 101, 121, 118, 97, 108, 117, 101, 45, 101, 114, 114, 111, 114, 64, 48, 46, 49, 46, 48, 5, 5, 2, 3, 0, 2, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 2, 3, 0, 2, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 2, 3, 0, 3, 5, 101, 114, 114, 111, 114, 1, 66, 44, 2, 3, 2, 1, 6, 4, 0, 12, 105, 110, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 0, 2, 3, 2, 1, 7, 4, 0, 13, 111, 117, 116, 112, 117, 116, 45, 115, 116, 114, 101, 97, 109, 3, 0, 2, 2, 3, 2, 1, 8, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 4, 4, 0, 6, 98, 117, 99, 107, 101, 116, 3, 1, 1, 115, 4, 0, 3, 107, 101, 121, 3, 0, 7, 4, 0, 14, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 3, 1, 4, 0, 25, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 98, 111, 100, 121, 45, 97, 115, 121, 110, 99, 3, 0, 3, 1, 112, 125, 4, 0, 24, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 98, 111, 100, 121, 45, 115, 121, 110, 99, 3, 0, 11, 4, 0, 14, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 3, 1, 4, 0, 25, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 97, 115, 121, 110, 99, 45, 98, 111, 100, 121, 3, 0, 1, 1, 112, 125, 4, 0, 24, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 115, 121, 110, 99, 45, 98, 111, 100, 121, 3, 0, 15, 1, 105, 6, 1, 105, 5, 1, 106, 1, 17, 1, 18, 1, 64, 1, 4, 110, 97, 109, 101, 115, 0, 19, 4, 0, 26, 91, 115, 116, 97, 116, 105, 99, 93, 98, 117, 99, 107, 101, 116, 46, 111, 112, 101, 110, 45, 98, 117, 99, 107, 101, 116, 1, 20, 1, 105, 9, 1, 64, 0, 0, 21, 4, 0, 41, 91, 115, 116, 97, 116, 105, 99, 93, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 46, 110, 101, 119, 45, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 1, 22, 1, 104, 9, 1, 105, 10, 1, 106, 1, 24, 1, 18, 1, 64, 1, 4, 115, 101, 108, 102, 23, 0, 25, 4, 0, 54, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 46, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 119, 114, 105, 116, 101, 45, 98, 111, 100, 121, 45, 97, 115, 121, 110, 99, 1, 26, 1, 106, 0, 1, 18, 1, 64, 2, 4, 115, 101, 108, 102, 23, 5, 118, 97, 108, 117, 101, 12, 0, 27, 4, 0, 53, 91, 109, 101, 116, 104, 111, 100, 93, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 46, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 119, 114, 105, 116, 101, 45, 98, 111, 100, 121, 45, 115, 121, 110, 99, 1, 28, 1, 104, 13, 1, 106, 1, 16, 1, 18, 1, 64, 1, 4, 115, 101, 108, 102, 29, 0, 30, 4, 0, 50, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 46, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 99, 111, 110, 115, 117, 109, 101, 45, 115, 121, 110, 99, 1, 31, 1, 105, 14, 1, 106, 1, 32, 1, 18, 1, 64, 1, 4, 115, 101, 108, 102, 29, 0, 33, 4, 0, 51, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 46, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 99, 111, 110, 115, 117, 109, 101, 45, 97, 115, 121, 110, 99, 1, 34, 1, 106, 1, 119, 1, 18, 1, 64, 1, 4, 115, 101, 108, 102, 29, 0, 35, 4, 0, 42, 91, 109, 101, 116, 104, 111, 100, 93, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 46, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 45, 115, 105, 122, 101, 1, 36, 3, 1, 25, 119, 97, 115, 105, 58, 107, 101, 121, 118, 97, 108, 117, 101, 47, 116, 121, 112, 101, 115, 64, 48, 46, 49, 46, 48, 5, 9, 2, 3, 0, 4, 6, 98, 117, 99, 107, 101, 116, 2, 3, 0, 4, 5, 101, 114, 114, 111, 114, 2, 3, 0, 4, 3, 107, 101, 121, 2, 3, 0, 4, 14, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 2, 3, 0, 4, 14, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 1, 66, 30, 2, 3, 2, 1, 10, 4, 0, 6, 98, 117, 99, 107, 101, 116, 3, 0, 0, 2, 3, 2, 1, 11, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 2, 2, 3, 2, 1, 12, 4, 0, 3, 107, 101, 121, 3, 0, 4, 2, 3, 2, 1, 13, 4, 0, 14, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 3, 0, 6, 2, 3, 2, 1, 14, 4, 0, 14, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 3, 0, 8, 1, 104, 1, 1, 112, 5, 1, 105, 7, 1, 107, 12, 1, 112, 13, 1, 105, 3, 1, 106, 1, 14, 1, 15, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 10, 4, 107, 101, 121, 115, 11, 0, 16, 4, 0, 8, 103, 101, 116, 45, 109, 97, 110, 121, 1, 17, 1, 106, 1, 11, 1, 15, 1, 64, 1, 6, 98, 117, 99, 107, 101, 116, 10, 0, 18, 4, 0, 4, 107, 101, 121, 115, 1, 19, 1, 104, 9, 1, 111, 2, 5, 20, 1, 112, 21, 1, 106, 0, 1, 15, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 10, 10, 107, 101, 121, 45, 118, 97, 108, 117, 101, 115, 22, 0, 23, 4, 0, 8, 115, 101, 116, 45, 109, 97, 110, 121, 1, 24, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 10, 4, 107, 101, 121, 115, 11, 0, 23, 4, 0, 11, 100, 101, 108, 101, 116, 101, 45, 109, 97, 110, 121, 1, 25, 3, 1, 34, 119, 97, 115, 105, 58, 107, 101, 121, 118, 97, 108, 117, 101, 47, 101, 118, 101, 110, 116, 117, 97, 108, 45, 98, 97, 116, 99, 104, 64, 48, 46, 49, 46, 48, 5, 15, 1, 66, 26, 2, 3, 2, 1, 10, 4, 0, 6, 98, 117, 99, 107, 101, 116, 3, 0, 0, 2, 3, 2, 1, 11, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 2, 2, 3, 2, 1, 13, 4, 0, 14, 105, 110, 99, 111, 109, 105, 110, 103, 45, 118, 97, 108, 117, 101, 3, 0, 4, 2, 3, 2, 1, 12, 4, 0, 3, 107, 101, 121, 3, 0, 6, 2, 3, 2, 1, 14, 4, 0, 14, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 3, 0, 8, 1, 104, 1, 1, 105, 5, 1, 107, 11, 1, 105, 3, 1, 106, 1, 12, 1, 13, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 10, 3, 107, 101, 121, 7, 0, 14, 4, 0, 3, 103, 101, 116, 1, 15, 1, 104, 9, 1, 106, 0, 1, 13, 1, 64, 3, 6, 98, 117, 99, 107, 101, 116, 10, 3, 107, 101, 121, 7, 14, 111, 117, 116, 103, 111, 105, 110, 103, 45, 118, 97, 108, 117, 101, 16, 0, 17, 4, 0, 3, 115, 101, 116, 1, 18, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 10, 3, 107, 101, 121, 7, 0, 17, 4, 0, 6, 100, 101, 108, 101, 116, 101, 1, 19, 1, 106, 1, 127, 1, 13, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 10, 3, 107, 101, 121, 7, 0, 20, 4, 0, 6, 101, 120, 105, 115, 116, 115, 1, 21, 3, 1, 28, 119, 97, 115, 105, 58, 107, 101, 121, 118, 97, 108, 117, 101, 47, 101, 118, 101, 110, 116, 117, 97, 108, 64, 48, 46, 49, 46, 48, 5, 16, 1, 66, 23, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 3, 107, 101, 121, 115, 1, 0, 4, 0, 6, 100, 101, 108, 101, 116, 101, 1, 0, 1, 112, 115, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 4, 107, 101, 121, 115, 1, 1, 0, 4, 0, 11, 100, 101, 108, 101, 116, 101, 45, 109, 97, 110, 121, 1, 2, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 3, 107, 101, 121, 115, 0, 127, 4, 0, 6, 101, 120, 105, 115, 116, 115, 1, 3, 1, 112, 125, 1, 107, 4, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 3, 107, 101, 121, 115, 0, 5, 4, 0, 3, 103, 101, 116, 1, 6, 1, 64, 1, 6, 98, 117, 99, 107, 101, 116, 115, 0, 1, 4, 0, 8, 103, 101, 116, 45, 107, 101, 121, 115, 1, 7, 1, 112, 4, 1, 107, 8, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 4, 107, 101, 121, 115, 1, 0, 9, 4, 0, 8, 103, 101, 116, 45, 109, 97, 110, 121, 1, 10, 1, 64, 3, 6, 98, 117, 99, 107, 101, 116, 115, 3, 107, 101, 121, 115, 5, 118, 97, 108, 117, 101, 4, 1, 0, 4, 0, 3, 115, 101, 116, 1, 11, 1, 111, 2, 115, 4, 1, 112, 12, 1, 64, 2, 6, 98, 117, 99, 107, 101, 116, 115, 10, 107, 101, 121, 45, 118, 97, 108, 117, 101, 115, 13, 1, 0, 4, 0, 8, 115, 101, 116, 45, 109, 97, 110, 121, 1, 14, 4, 1, 12, 103, 111, 108, 101, 109, 58, 105, 116, 47, 97, 112, 105, 5, 17, 4, 1, 26, 103, 111, 108, 101, 109, 58, 105, 116, 47, 107, 101, 121, 45, 118, 97, 108, 117, 101, 45, 115, 101, 114, 118, 105, 99, 101, 4, 0, 11, 23, 1, 0, 17, 107, 101, 121, 45, 118, 97, 108, 117, 101, 45, 115, 101, 114, 118, 105, 99, 101, 3, 2, 0, 0, 16, 12, 112, 97, 99, 107, 97, 103, 101, 45, 100, 111, 99, 115, 0, 123, 125, 0, 70, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 6, 48, 46, 49, 56, 46, 50, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 6, 48, 46, 49, 54, 46, 48];
    
    #[inline(never)]
    #[doc(hidden)]
    #[cfg(target_arch = "wasm32")]
    pub fn __link_section() {}
    
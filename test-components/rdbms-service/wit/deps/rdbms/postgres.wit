package wasi:rdbms@0.0.1;

interface postgres {

  variant error {
    connection-failure(string),
    query-parameter-failure(string),
    query-execution-failure(string),
    query-response-failure(string),
    other(string)
  }

  type uuid = tuple<u64, u64>;

  type ipv4-address = tuple<u8, u8, u8, u8>;
  type ipv6-address = tuple<u16, u16, u16, u16, u16, u16, u16, u16>;
  variant ip-address {
    ipv4(ipv4-address),
    ipv6(ipv6-address),
  }

  type mac-address = tuple<u8, u8, u8, u8, u8, u8>;

  type date = tuple<s32, u8, u8>; // year, month, day
  type time = tuple<u8, u8, u8, u32>; // hour, minute, second, nanosecond
  type timetz = tuple<u8, u8, u8, u32, s32>; // hour, minute, second, nanosecond, timezone offset in seconds
  type timestamp = tuple<s32, u8, u8, u8, u8, u8, u32>; // year, month, day, hour, minute, second, nanosecond
  type timestamptz = tuple<s32, u8, u8, u8, u8, u8, u32, s32>; // year, month, day, hour, minute, second, nanosecond, timezone offset in seconds

  type interval = tuple<s32, s32, s64>; // months, days, microseconds

  type int4range = tuple<option<tuple<s32, bool>>, option<tuple<s32, bool>>>;
  type int8range = tuple<option<tuple<s64, bool>>, option<tuple<s64, bool>>>;
  type numrange = tuple<option<tuple<string, bool>>, option<tuple<string, bool>>>;
  type tsrange = tuple<option<tuple<timestamp, bool>>, option<tuple<timestamp, bool>>>;
  type tstzrange = tuple<option<tuple<timestamptz, bool>>, option<tuple<timestamptz, bool>>>;
  type daterange = tuple<option<tuple<date, bool>>, option<tuple<date, bool>>>;

  type bit-vec = list<bool>;

  variant db-column-type-primitive {
    character,
    int2,
    int4,
    int8,
    float4,
    float8,
    numeric,
    boolean,
    text,
    varchar,
    bpchar,
    timestamp,
    timestamptz,
    date,
    time,
    timetz,
    interval,
    bytea,
    uuid,
    xml,
    json,
    jsonb,
    jsonpath,
    inet,
    cidr,
    macaddr,
    bit,
    varbit,
    int4range,
    int8range,
    numrange,
    tsrange,
    tstzrange,
    daterange,
    money,
    oid,
    custom-enum(string)
    //     point,
    //     line,
    //     lseg,
    //     box,
    //     polygon,
    //     circle,
    //     path,
    //     box2d,
    //     polygonz,
    //     circlez,
    //     pathz,
    //     hstore,
    //     tsvector,
    //     tsquery,
    //     range
  }

  variant db-value-primitive {
    character(s8),
    int2(s16),
    int4(s32),
    int8(s64),
    float4(float32),
    float8(float64),
    numeric(string),
    boolean(bool),
    text(string),
    varchar(string),
    bpchar(string),
    timestamp(timestamp),
    timestamptz(timestamptz),
    date(date),
    time(time),
    timetz(timetz),
    interval(interval),
    bytea(list<u8>),
    json(string),
    jsonb(string),
    jsonpath(string),
    xml(string),
    uuid(uuid),
    inet(ip-address),
    cidr(ip-address),
    macaddr(mac-address),
    bit(bit-vec),
    varbit(bit-vec),
    int4range(int4range),
    int8range(int8range),
    numrange(numrange),
    tsrange(tsrange),
    tstzrange(tstzrange),
    daterange(daterange),
    money(s64),
    oid(u32),
    custom-enum(string),
    null
  }

  variant db-column-type {
    primitive(db-column-type-primitive),
    array(db-column-type-primitive)
  }

  record db-column {
    ordinal:     u64,
    name:        string,
    db-type:     db-column-type,
    db-type-name: string
  }

  variant db-value {
    primitive(db-value-primitive),
    array(list<db-value-primitive>) // Flatteneed
  }

  /// A single row of values
  record db-row {
    values: list<db-value>
  }

  /// A potentially very large and lazy stream of rows:
  resource db-result-set {
    get-columns: func() -> list<db-column>;
    get-next: func() -> option<list<db-row>>;
  }

  resource db-connection {
    open: static func(address: string) -> result<db-connection, error>;

    query: func(statement: string, params: list<db-value>) -> result<db-result-set, error>;

    execute: func(statement: string, params: list<db-value>) -> result<u64, error>;
  }
}
package wasi:rdbms@0.0.1;

interface postgres {

  type node-index = u32;

  variant error {
    connection-failure(string),
    query-parameter-failure(string),
    query-execution-failure(string),
    query-response-failure(string),
    other(string)
  }

  record uuid {
    high-bits: u64,
    low-bits: u64
  }

  variant ip-address {
    ipv4(tuple<u8, u8, u8, u8>),
    ipv6(tuple<u16, u16, u16, u16, u16, u16, u16, u16>),
  }

  record mac-address {
    octets: tuple<u8, u8, u8, u8, u8, u8>
  }

  record date {
    year: s32,
    month: u8,
    day: u8
  }

  record time {
    hour: u8,
    minute: u8,
    second: u8,
    nanosecond: u32
  }

  record timestamp {
    date: date,
    time: time
  }

  record timestamptz {
    timestamp: timestamp,
    offset: s32
  }

  record timetz {
    time: time,
    offset: s32
  }

  record interval {
    months: s32,
    days: s32,
    microseconds: s64
  }

  variant int4bound {
    included(s32),
    excluded(s32),
    unbounded
  }

  variant int8bound {
    included(s64),
    excluded(s64),
    unbounded
  }

  variant numbound {
    included(string),
    excluded(string),
    unbounded
  }

  variant tsbound {
    included(timestamp),
    excluded(timestamp),
    unbounded
  }
  variant tstzbound {
    included(timestamptz),
    excluded(timestamptz),
    unbounded
  }

  variant datebound {
    included(date),
    excluded(date),
    unbounded
  }

  record int4range {
   start: int4bound,
   end: int4bound
  }

  record int8range {
   start: int8bound,
   end: int8bound
  }

  record numrange {
   start: numbound,
   end: numbound
  }

  record tsrange {
   start: tsbound,
   end: tsbound
  }

  record tstzrange {
   start: tstzbound,
   end: tstzbound
  }

  record daterange {
   start: datebound,
   end: datebound
  }

  record enumeration-type {
    name: string
  }

  record enumeration {
    name: string,
    value: string
  }

  record composite-type {
    name: string,
    attributes: list<tuple<string, node-index>>
  }

  record composite {
    name: string,
    values: list<node-index>
  }

  record domain-type {
    name: string,
    base-type: node-index
  }

  record domain {
    name: string,
    value: node-index
  }

  record db-column-type {
    nodes: list<db-column-type-node>
  }

  variant db-column-type-node {
    character,
    int2,
    int4,
    int8,
    float4,
    float8,
    numeric,
    boolean,
    text,
    varchar,
    bpchar,
    timestamp,
    timestamptz,
    date,
    time,
    timetz,
    interval,
    bytea,
    uuid,
    xml,
    json,
    jsonb,
    jsonpath,
    inet,
    cidr,
    macaddr,
    bit,
    varbit,
    int4range,
    int8range,
    numrange,
    tsrange,
    tstzrange,
    daterange,
    money,
    oid,
    enumeration(enumeration-type),
    composite(composite-type),
    domain(domain-type),
    array(node-index)
  }

  variant db-value-node {
    character(s8),
    int2(s16),
    int4(s32),
    int8(s64),
    float4(float32),
    float8(float64),
    numeric(string),
    boolean(bool),
    text(string),
    varchar(string),
    bpchar(string),
    timestamp(timestamp),
    timestamptz(timestamptz),
    date(date),
    time(time),
    timetz(timetz),
    interval(interval),
    bytea(list<u8>),
    json(string),
    jsonb(string),
    jsonpath(string),
    xml(string),
    uuid(uuid),
    inet(ip-address),
    cidr(ip-address),
    macaddr(mac-address),
    bit(list<bool>),
    varbit(list<bool>),
    int4range(int4range),
    int8range(int8range),
    numrange(numrange),
    tsrange(tsrange),
    tstzrange(tstzrange),
    daterange(daterange),
    money(s64),
    oid(u32),
    enumeration(enumeration),
    composite(composite),
    domain(domain),
    array(list<node-index>),
    null
  }

  record db-value {
    nodes: list<db-value-node>
  }

  record db-column {
    ordinal:     u64,
    name:        string,
    db-type:     db-column-type,
    db-type-name: string
  }

  /// A single row of values
  record db-row {
    values: list<db-value>
  }

  /// A potentially very large and lazy stream of rows:
  resource db-result-set {
    get-columns: func() -> list<db-column>;
    get-next: func() -> option<list<db-row>>;
  }

  resource db-connection {
    open: static func(address: string) -> result<db-connection, error>;

    query: func(statement: string, params: list<db-value>) -> result<db-result-set, error>;

    execute: func(statement: string, params: list<db-value>) -> result<u64, error>;
  }
}
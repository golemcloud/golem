{"/cli":{"title":"Golem CLI Introduction","data":{"":"Golem CLI is a command-line interface for interacting with Golem. Golem CLI allows users to upload their components, launch new agents based on these components and call functions on running agents.","golem-cli-versions#Golem CLI versions":"There are precompiled binaries of two variants of the CLI:\ngolem is the full version of the command line interface, including a locally runnable version of Golem itself.\ngolem-cli is a lightweight version of the command line interface, requiring a running Golem cluster.\nIn this documentation we will use the golem command in the snippets.","installation#Installation":"There are two ways to install any of the above described versions of Golem CLI:\nDownloading a precompiled platform-specific binary\nInstalling from source using Rust tooling","downloading-precompiled-binaries#Downloading precompiled binaries":"You can download the precompiled version of golem (and golem-cli) from the following pages:","undefined#Full version, including a locally executable Golem server":"Platform\tLink\tMac ARM64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-aarch64-apple-darwin\tMac x86_64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-x86_64-apple-darwin\tLinux ARM64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-aarch64-unknown-linux-gnu\tLinux x86_64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-x86_64-unknown-linux-gnu\t\nWindows is not supported for the current version, and expected to be added in Golem 1.3.1.","undefined#Lightweight client version, to work with an existing Golem cluster":"Platform\tLink\tMac ARM64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-cli-aarch64-apple-darwin\tMac x86_64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-cli-x86_64-apple-darwin\tLinux ARM64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-cli-aarch64-unknown-linux-gnu\tLinux x86_64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-cli-x86_64-unknown-linux-gnu\t\nWindows is not supported for the current version, and expected to be added in future patch version of Golem 1.3.\nSome platforms may prevent downloaded binaries from running by default. You may need to\nallow them in your system settings.","installing-from-source#Installing from source":"It is also possible to build it from source for yourself using Rust tooling. Refer to the page about building Golem CLI for yourself for more information.","profiles#Profiles":"The Golem CLI can have multiple profiles configured, each selecting a specific Golem cluster to connect to, as well as some settings like the default output format.See the Golem CLI profiles page for more information.","working-with-components#Working with components":"Golem CLI can manage components. See the Golem CLI components page for details.","interacting-with-agents#Interacting with agents":"Golem CLI allows creating, invoking and observing agents. See the Golem CLI agents page for more information."}},"/cli/agents":{"title":"Golem CLI Agents","data":{"":"Using golem agent command you can:\nStart and stop agent\nInterrupt and resume agents\nInvoke agent function\nGet agent stdout, stderr and logs\nUpdate agents\nSearch agents, get metadata, etc.\nRevert a agent to a previous state","create-a-new-agent#Create a new agent":"Even though agents can automatically start on the first invocation, it is possible to explicitly start an agent.\nThis allows specifying command line arguments and environment variables for the agent.\ngolem agent new 'example:counter/counter-agent(\"my-counter\")' --env A=1 --env B=2 arg1 arg2","get-agent-metadata#Get agent metadata":"","using-the-agent-id#Using the agent ID":"You can get the agent metadata using the agent-id (the agent type and it's constructor parameters) and (optionally prefixed by the component name, if it is not inferrable from the current context):\ngolem agent get 'counter-agent(\"my-counter\")'\ngolem agent get 'example:counter/counter-agent(\"my-counter\")'","search-agents#Search agents":"You can search for agents of some components or agent types using the agent list command with one or more --filter arguments.For instance lets find idle agents with component version older than 2 of the component example:counter:\ngolem agent list --filter \"status = Idle\" --filter \"version < 2\" example:counter\nEnumerating agents is a slow operation and should only be used for debugging an administrative\ntasks.","invoking-agent-methods#Invoking agent methods":"The folowing section shows the basics of invoking agents through the CLI. See the dedicated invocation with CLI page for more details.","without-waiting-for-result#Without waiting for result":"You can invoke an agent function without waiting for function result using agent invoke --enqueue command:\ngolem agent invoke --enqueue 'counter-agent(\"my-counter\")' 'increment-by' 5\nFunction parameters can be specified using repeated --arg parameters.","waiting-for-result#Waiting for result":"You can invoke an agent method and wait for result using agent invoke command:\ngolem agent invoke 'counter-agent(\"my-counter\")' 'get-value'\nInvocation results in WAVE format:\n- '5'","using-idempotency-key#Using idempotency key":"If you want to make sure function was called only once even if you called CLI multiple times (for instance due to retries on network errors) you can use --idempotency-key parameter for both invoke and invoke-and-await commands.You can use any string as idempotency key.","live-streaming-agent-logs#Live streaming agent logs":"You can connect to your running agent and stream its logs using the agent stream command:\ngolem agent stream 'counter-agent(\"my-counter\")'\nYou can also use the --stream option on invoke command to connect to the agent right after invoking the command.","agent-update#Agent update":"To update the agent to a specific component version, use the agent update command:\ngolem agent update 'counter-agent(\"my-counter\")' --target-version 2 --mode auto\nThe agent update-many with the same --filter parameters as in agent list command can update multiple agents:\ngolem agent update-many example:counter --filter 'version < 2' --target-version 2 --mode auto","interrupt-and-resume-agents#Interrupt and resume agents":"If you want to interrupt and later resume a long-running agent you can use interrupt and resume commands:\ngolem agent interrupt 'counter-agent(\"my-counter\")'\ngolem agent resume 'counter-agent(\"my-counter\")'","testing-crash-recovery#Testing crash recovery":"There is a special command to simulate a crash on an agent:\ngolem agent simulated-crash 'counter-agent(\"my-counter\")'","deleting-agents#Deleting agents":"Idle agents are not actively consuming resources but they take storage as their state is persisted. An agent can be deleted using the agent delete command:\ngolem agent delete 'counter-agent(\"my-counter\")'\nThis command deletes agent state.Please note that a next invocation to the same agent will recreate it with fresh state:\ngolem agent delete 'counter-agent(\"my-counter\")'\ngolem agent invoke 'counter-agent(\"my-counter\")' 'get-value'\nInvocation results in WAVE format:\n- '0'","oplog-query#Oplog query":"It is possible to query an existing agent's oplog for debugging purposes. To get the full oplog of an agent, use the agent oplog command:\ngolem agent oplog 'counter-agent(\"my-counter\")'\nWith the optional --from parameter it is possible to only get oplog entries after a certain oplog index:\ngolem agent oplog --from 100 'counter-agent(\"my-counter\")'\nOplog entries are indexed from 1, and the first entry is always a create entry that defines the initial state of the agent.","searching-for-oplog-entries#Searching for oplog entries":"The same command can also be used to search for oplog entries, using the --query parameter. This parameter requires a query using lucene query syntax. The following syntax elements are supported:\nsearch terms looks for search AND terms\nAND, OR and NOT\ngrouping using parentheses ()\n\"quoted terms\"\nregular expression matches using /regex/\nfield:value to search for a specific information\nThe terms and fields are interpreted in the following way:\nOplog entry\tMatching queries\tCreate\tcreate\tImportedFunctionInvoked\timported-function-invoked, match on invoked function's name, match on function arguments(), match on result value()\tExportedFunctionInvoked\texported-function-invoked, exported-function, match on invoked function's name, match on idempotency key, match on function arguments(*)\tExportedFunctionCompleted\texported-function-completed, exported-function, match on response value(*)\tSuspend\tsuspend\tError\terror, match on error message\tNoOp\tnoop\tJump\tjump\tInterrupted\tinterrupted\tExited\texited\tChangeRetryPolicy\tchange-retry-policy\tBeginAtomicRegion\tbegin-atomic-region\tEndAtomicRegion\tend-atomic-region\tBeginRemoteWrite\tbegin-remote-write\tEndRemoteWrite\tend-remote-write\tPendingWorkerInvocation\tpending-worker-invocation, match on invoked function's name, match on idempotency key, match on function arguments(*)\tPendingUpdate\tpending-update, update, match on target version\tSuccessfulUpdate\tsuccessful-update, update, match on target version\tFailedUpdate\tfailed-update, update, match on target version, match on error details\tGrowMemory\tgrow-memory\tCreateResource\tcreate-resource\tDropResource\tdrop-resource\tDescribeResource\tdescribe-resource, match on resource name, match on resource parameters(*)\tLog\tlog, match on context, match on message\tRestart\trestart\tActivatePlugin\tactivate-plugin\tDeactivatePlugin\tdeactivate-plugin\tRevert\trevert\tCancelInvocation\tcancel, cancel-invocation, match on idempotency key\tStartSpan\tstart-span, startspan, match on span ID, match on parent ID, match on linked context, match on attributes(*)\tFinishSpan\tfinish-span, finishspan, match on span ID\tSetSpanAttribute\tset-span-attribute, setspanattribute, match on key, match on value\tChangePersistenceLevel\tchange-persistence-level, changepersistencelevel, persistence-level\t\nThe cases marked with (*) can use the field:value syntax to look into the typed, structured parameter and result values.For example to look for oplog entries that contain parameters or return values of exported functions where any of these input/output values is a record having a field product-id with either value 123 or 456, we can use the following query:\ngolem agent oplog --query 'exported-function AND (product-id:123 OR product-id:456)' 'counter-agent(\"my-counter\")'","reverting-an-agent#Reverting an agent":"It is possible to revert an agent to its previous state. This can be useful if an agent got into a failed state to make it usable again, or to undo some accidental invocations or updates.There are two possible ways to specify which state to revert to:\nBy index: The index of the oplog entry to revert to. Use the oplog query command to check the agent's oplog and find the index of the desired state.\nBy undoing the last invocations: The given number is the number of invocations to revert.\nTo revert to a given oplog, use the agent revert command:\ngolem agent revert 'counter-agent(\"my-counter\")' --last-oplog-index 42\nTo revert some of the last invocations, use the --number-of-invocations parameter instead:\ngolem agent revert 'counter-agent(\"my-counter\")' --number-of-invocations 3","cancelling-a-pending-invocation#Cancelling a pending invocation":"If an invocation is enqueued for an agent, but it has not been started yet, it can be removed from the invocation queue by using it's idempotency key:\ngolem agent cancel-invocation 'counter-agent(\"my-counter\")' my-key"}},"/cli/app-manifest":{"title":"Golem Application Manifest","data":{"":"The Golem Application Manifest document format is used by golem, usually stored in files named golem.yaml, which can help working with components. Currently, the Application Manifest covers:\ndefining components and their metadata, including:\ncomponent type\nlocation of user defined and generated WIT folders\nlocation of built and composed WASM binaries\nbuild commands\nInitial File System\nconfiguration values and environment variables\ndefining component dependencies on libraries\ndefining HTTP APIs\nbuilding components\ndeploying components\nThe Application Manifest uses YAML format, see the reference for more information on the schema and for the field reference.Application manifest documents can be explicitly passed as golem arguments, but the recommended way to use them is with auto discovery mode: when golem is called with an application manifest compatible command it keeps searching for golem.yaml documents in current working directory and parent directories. Once it found the top level golem.yaml document, more documents are searched using the includes field.Once all manifest documents are found, the paths in them are resolved based on their directory, and then the documents are merged. For the field specific merge rules see the field reference.","using-composable-templates#Using composable templates":"Golem projects can be created with golem app new command. This creates a new application that may consist of multiple components. To add a new component to an existing application, use golem component new. E.g.: let's add a new c and ts component in a new and empty directory:\ngolem app new app:component-a c\ncd app:component-a\ngolem component new ts app:component-b\nWhen using the app new command, it will create:\ncommon directory for the given language (common-cpp and common-ts):\nthis directory contains the languages specific Application Manifest Template, which defines how to\nbuild the components\ncan be used for shared subprojects\nmight contain other shared configurations\ndirectory for components for the given language (components-cpp and components-ts)\ndirectory called wit/deps for common WIT dependencies, and populates it with WASI and Golem packages\ndepending on the language it might add common-adapters.\nNow that we added our components, let's use the app command list our project metadata:\n$ golem app\nBuild, deploy application\nUsage: golem app [OPTIONS] <COMMAND>\nCommands:\n  new     Create new application\n  build   Build all or selected components in the application\n  deploy  Deploy all or selected components in the application, includes building\n  clean   Clean all components in the application or by selection\n  help    Print this message or the help of the given subcommand(s)\nOptions:\n  -f, --format <FORMAT>\n          Output format, defaults to text, unless specified by the selected profile\n  -p, --profile <PROFILE>\n          Select Golem profile by name\n  -l, --local\n          Select builtin \"local\" profile, to use services provided by the \"golem server\" command\n  -c, --cloud\n          Select builtin \"cloud\" profile to use Golem Cloud\n  -a, --app-manifest-path <APP_MANIFEST_PATH>\n          Custom path to the root application manifest (golem.yaml)\n  -A, --disable-app-manifest-discovery\n          Disable automatic searching for application manifests\n  -b, --build-profile <BUILD_PROFILE>\n          Select build profile\n      --config-dir <CONFIG_DIR>\n          Custom path to the config directory (defaults to $HOME/.golem)\n  -v, --verbose...\n          Increase logging verbosity\n  -q, --quiet...\n          Decrease logging verbosity\n  -h, --help\n          Print help\nComponents:\n  app:component-a\n    Selected:     yes\n    Source:       /Users/<...>/app-demo/components-cpp/app-component-a/golem.yaml\n    Template:     cpp\n    Profiles:     debug, release\n  app:component-b\n    Selected:     yes\n    Source:       /Users/<...>/app-demo/components-ts/app-component-b/golem.yaml\n    Template:     ts\nCustom commands:\n  npm-install\nBecause the ts components use npm, we have to use npm install before building the components. We can also see that this has a wrapper custom command in the manifest called npm-install. Let's use that, then build our components:\n$ golem app npm-install\n<..>\n$ golem app build\nCollecting sources\n  Found sources: /Users/<...>/app-demo/common-cpp/golem.yaml, /Users/<...>/app-demo/common-ts/golem.yaml, /Users/<...>/app-demo/components-cpp/app-component-a/golem.yaml, /Users/<...>/app-demo/components-ts/app-component-b/golem.yaml, /Users/<...>/app-demo/golem.yaml\nCollecting components\n  Found components: app:component-a, app:component-b\nResolving application wit directories\n  Resolving component wit dirs for app:component-a (/Users/<...>/app-demo/components-cpp/app-component-a/wit, /Users/<...>/app-demo/components-cpp/app-component-a/wit-generated)\n  Resolving component wit dirs for app:component-b (/Users/<...>/app-demo/components-ts/app-component-b/wit, /Users/<...>/app-demo/components-ts/app-component-b/wit-generated)\nSelecting profiles, no profile was requested\n  Selected default profile debug for app:component-a using template cpp\n  Selected default build for app:component-b using template ts\n<...>\nLinking RPC\n  Copying app:component-a without linking, no static WASM RPC dependencies were found\n  Copying app:component-b without linking, no static WASM RPC dependencies were found\nThen we can check that the components are built:\n$ ls golem-temp/components\napp_component_a_debug.wasm app_component_b.wasm\nTo deploy (add or update) or components we can use\ngolem component deploy\nin the project root folder, and the CLI will add or update all or components.If we want to only update some components, we can do so by explicitly selecting them with the --component-name flag, or we can implicitly select them by changing our current working directory, e.g.:\n$ cd components-cpp\n$ golem app\n<...>\nComponents:\n  app:component-a\n    Selected:     yes\n    Source:       /Users/noise64/workspace/examples/app-demo/components-cpp/app-component-a/golem.yaml\n    Template:     cpp\n    Profiles:     debug, release\n  app:component-b\n    Selected:     no\n    Source:       /Users/noise64/workspace/examples/app-demo/components-ts/app-component-b/golem.yaml\n    Template:     ts\n<...>\nNotice, how only app:component-a is selected in the above example, the same selection logic is used when\nadding or updating components."}},"/app-manifest":{"title":"Golem Application Manifest Reference","data":{"json-schema#JSON schema":"For the application manifest format we also publish JSON schemas. The current version (1.1.1) is available here.The JSON schema is intended to be used with editors and IDEs, to help with base validation and code completion.Use the following YAML comments at the start of your golem.yaml documents to enable schema support:\nNote that on top of the above schema there are other checks performed by golem, see the field reference below for details.","loading-of-application-manifest-documents#Loading of Application Manifest documents":"The Golem CLI commands that use Application Manifest start by searching for golem.yaml documents in the current and the parent directories. Once the top level manifest document is found, more manifests are searched based on the  fields.After resolving relative paths in the documents they are merged, then component selection happens: this can be either explicit, by using --component-name CLI flags, or implicit, in which case only components defined in the directory - including subdirectories - from where the Golem CLI was executed are used.Application Manifest documents can also be explicitly passed to the CLI, using the --app flag. Note that when using explicit documents the includes field is not used, it is expected that all relevant documents are provided for the CLI.","template-variables-and-functions#Template variables and functions":"The Application Manifest has some fields which are used as templates, these fields are marked as Templated in the field reference below. The templates are using minijinja, which is a minimal templating engine based on Jinja2 syntax.Available template variables:\ncomponent_name: contains the current component name in which the template is used\nAvailable naming related string transforming functions:\nto_snake_case\nto_kebab_case\nto_lower_camel_case\nto_pascal_case\nto_shouty_kebab_case\nto_shouty_snake_case\nto_snake_case\nto_title_case\nto_train_case\nto_upper_camel_case\nbuild: tool-name build {{ component_name | to_snake_case }}.wasm","field-reference#Field reference":"Optional list of glob patterns that are used for adding search patterns for other Application Manifests\nwhen using auto discovery of them. The patterns are relative to the manifest document in which they are defined.The default search pattern is **/golem.yaml, which searches for golem.yaml documents in every subdirectory\nrecursively. Templates and examples provided by Golem usually use more specific search patterns to make the lookups\nmore efficient.The includes fields can be defined in one manifest only, usually in the project root directory.\nDefining it multiple times results in validation error.\nincludes:\n- components-dir/*/golem.yaml\n- custom-templates/golem-*.yaml\nOptional path that overrides the default path of the default temporary directory (golem-temp) which is\nused\nfor storing various intermediate artifacts.The path is relative to the manifest document in which they are defined.\ntempDir: target/golem-temp\nOptional list of paths of directories where WIT dependency packages can be stored.\nThe paths are relative to the manifest document in which they are defined.During component WIT generation these paths are checked for resolving missing dependencies.\nIt is intended to be used for eliminating duplication of common dependencies and interfaces.The witDeps fields can be defined in one manifest only, usually in the project root directory.\nDefining it multiple times results in validation error.\nwitDeps:\n- wit-common/deps\nOptional object for defining HTTP APIs and HTTP API deployments.\nAPIs and deployments can be defined in multiple manifests, and they are merged during deployment.\nOptional map of HTTP API definitions by API name.\nRequired string version of the API.\nOptional project reference for the API.\nOptional array of HTTP routes.\nRequired HTTP method for the route, accepted values:\nRequired HTTP path pattern for the route.\nOptional ID of the required HTTP API security.\nRequired API binding.\n*Optional binding type, accepted values:\nRequired name of the component to be used in the bindings.\nOptional version of the component to be used in the bindings, default to the latest deployed one.\nOptional Rib script for calculating the idempotency key.\nOptional Rib script for calculating the invocation context.\nRequired Rib script for creating the response.\nOptional map of HTTP API deployments by profile name.\nOptional list of HTTP API deployments for the profile.\nRequired host for the deployment.\nOptional subdomain for the deployment.\nRequired list of HTTP APIDefinitions for the deployment.\nAccepted formats: name or name@version.\nOptional custom or customized profiles for the application by profile name.\nOptional boolean which defaults to false. Only one profile can be marked as default.\nOptional boolean which marks the profile as a cloud profile. Implicitly true for\nOptional project reference for the profile.\nOptional custom URL for golem services.\nOptional custom URL for golem worker service.\nOptional default format for the profile, accepted values:\nalias for pretty-json\nOptional default build profile.\nOptional boolean which defaults to false, when set to true it\nenables the auto-confirm (yes) flag by default.\nOptional boolean which defaults to false, when set to true it\nenables redeploy-workers flag by default.\nOptional boolean which defaults to false, when set to true it\nenables redeploy-agents flag by default.\nOptional boolean which defaults to false, when set to true it\nenables redeploy-http-api flag by default.\nOptional boolean which defaults to false, when set to true it\nenables redeploy-all flag by default.\nOptional boolean which defaults to false, when set to true it\nenables reset flag by default.\nOptional map of Golem components indexed by component-name-s used for defining components.The components field can be defined in multiple manifest documents, but the used component-name-s must be\nunique across all the used manifest documents. Using the same component-name more then once results in\nvalidation error.\ncomponents:\n  pack-ns:component-name:\n    sourceWit: # ...\n    # ...\n  pack:comp-b:\n    sourceWit: # ...\n    # ...\nOptional template name which will be used for creating the component fields.The template name must be one of that are defined in .See  and Template variable and functions\nfor defining templates.\nOptional string enum of component types, accepted values:\nSee Ephemeral vs Durable Workers for more information about\ncomponent types.\ncomponents:\n  pack-ns:component-name:\n    # ...\n    componentType: durable\n  pack-ns:component-name:\n    # ...\n    componentType: ephemeral\nOptional list of files entries, which can be used for defining the Initial File System for the component.\ncomponents:\n  pack-ns:component-name:\n    # ...\n    files:\n    - sourcePath: ./files/foo.txt\n      targetPath: /files/foo.txt\n      permissions: read-only\n    - sourcePath: ./files/bar.txt\n      targetPath: /files/bar.txt\n      permissions: read-write\nRequired source path of the file to be added to the Initial File System. The path can be a\nfile path relative to the manifest document or an URL.\nRequired target path of the file in the Initial File System. The path must be an absolute\npath.\nOptional string enum which controls file permissions. Accepted values:\nOptional list of component plugin installation entries,\nRequired name of the plugin.\nRequired version of the plugin.\nOptional string map of plugin parameters.\nRequired directory path for the user defined component WIT directory.The path is relative to the manifest document in which the field is defined.The WIT directory can omit the deps folder if the required dependencies are\navailable in some of the folders defined in .\ncomponents:\n  pack-ns:component-name:\n    # ...\n    sourceWit: wit\nRequired directory path for the generated WIT directory created by the golem tooling, which handles exported\ninterface extraction and includes resolved package and client dependencies.This directory is intended to be used as source for binding generation.The path is relative to the manifest document in which the field is defined.This folder is usually added to .gitignore, as it is generated as part of build.\ncomponents:\n  pack-ns:component-name:\n    # ...\n    generatedWit: wit-generated\nRequired file path which should point to the built component WASM file before linking.The path is relative to the manifest document in which the field is defined.This file is usually added to .gitignore, as it is created as part of build.\ncomponents:\n  pack-ns:component-name:\n    # ...\n    componentWasm: build/component.wasm\nOptional file path which should point to the built component WASM file after linking.Defaults to golem-temp/linked-wasm/component-name.wasm, see .The path is relative to the manifest document in which the field is defined.This file is usually added to .gitignore, as it is created as part of build.\ncomponents:\n  pack-ns:component-name:\n    # ...\n    linkedWasm: golem-temp/component/component.wasm\nOptional list of build commands that creates .\ncomponents:\n  pack-ns:component-name:\n    build:\n    - command: bindgen-tool wit-generated\n    - command: build-tool wit-generated component.wasm\nRequired external command that will be used as a build step for creating\n.\nOptional directory path which will be used as working directory when executing\n.The path is relative to the manifest document, and defaults to ..\nOptional list of directory paths which will be deleted before executing the command.The path is relative to .The rmdirs field is useful when a binding generator does not automatically clean stale bindings.Directories are not removed if the command is skipped because of up-to-date checks, see\n and\n.Directories are removed before executing .\nOptional list of directory paths which will be created before executing the command if they do not exists.The path is relative to .The mkdirs field is useful when a build of binding generator tool does not automatically create\nrequired nested folders.Directories are not created if the command is skipped because of up-to-date checks, see\n and\n.Directories are created after executing .\nOptional list of paths and globs which are used as sources for performing up-to-date checks.If defined then  also have to be used.The up-to-date check\nskips executing \nif all matching files defined by \nare newer then the matched files defined by sources.\ncomponents:\n  pack-ns:component-name:\n    # ...\n    build:\n    - command: build-tool src-dir out.wasm\n      sources:\n      - src-dir/*\n      targets:\n      - out.wasm\nOptional list of paths and globs which are used as targets for performing up-to-date checks.If defined then  also have to be used.See  for up-to-date check details.\nOptional map of component specific external commands, which are useful for defining e.g. one time\ninstallation\nor update related commands for the component.The commands can be executed using:\ngolem app command-name\nMultiple components can use the same command-name, the above command will execute all matching\ncommands in this case, both component specific and project ones.For defining project level custom commands see .The following command names cannot be used, as they are used by golem app itself:\nbuild\nclean\ncomponents:\n  pack-ns:component-name:\n    # ...\n    customCommands:\n      npm-install:\n      - command: npm install\nOptional map of profiles, which can be used to provide multiple build profiles for a component,\ntypically used for debug and release configurations.A profile contains the same fields as a component, expect for defaultProfile and profile itself.When profiles are defined for a component:\n must be defined,\nnon-profile component fields should not be used on the component, apart from defaultProfile.\nWhen building, by default golem will use defaultProfile, unless a specific profile is requested and_\nthe component has a matching profile. E.g. the following command:\ngolem app --build-profile release build\nwill build components that have no profiles by using the non-profile component fields\nwill use the release profile for components that are using profiles and have a profile named release\nwill use the defaultProfile for components that using profiles, but do not have a profile named release\ncomponents:\n  pack-ns:component-name:\n    profiles:\n      debug:\n        build:\n        - command: build-tool --debug out.wasm\n      release:\n        build:\n        - command: build-tool --release out.wasm\n    defaultProfile: release\nOptional profile name that defines which profile should be used.It must be defined when using , and must be one of the\nprofile names defined there.\nOptional map of list of component dependencies, which can be used for defining WASM RPC connections\nbetween components.\nRequired string enum, accepted values:\nDynamic WASM RPC linking.With this dependency type the linking happens on servers side, so there is no need for generating and creating\nWASM RPC clients.\nStatic WASM RPC linking.With this dependency type the linking happens locally, so it requires Rust tooling.\nComponent linking.\nMust be a defined component name. Required when  is\nset to wasm-rpc or wasm-rpc-static.\nTarget component WASM path to be used as dependency for linking.When  is set to wasm then this or\n ir required.\nTarget component WASM path to be used as dependency for linking.When  is set to wasm then this or\n ir required.\nOptional list of paths which are added as targets to the golem app clean command.The paths are relative to the manifest document.The clean command deletes the following paths:\nbuild and custom command targets\nthe paths defined in common and component specific clean fields.\nOptional map of custom external commands, which are useful for defining e.g. one time installation\nor update related project commands.The commands can be executed using:\ngolem app command-name\nComponents specific custom commands can use the same command-name, the above command will execute all matching\ncommands in this case, both component specific and project ones.For defining component specific custom commands see .The following command names cannot be used, as they are used by golem app itself:\nbuild\nclean\ncustomCommands:\n  npm-install:\n  - command: npm install\nOptional directory path which will be used as working directory when executing\n.The path is relative to the manifest document, and defaults to ..\nOptional list of directory paths which will be deleted before executing the command.The path is relative to .The rmdirs field is useful when a binding generator does not automatically clean stale bindings.Directories are not removed if the command is skipped because of up-to-date checks, see\n and\n.Directories are removed before executing .\nOptional list of directory paths which will be created before executing the command if they do not exists.The path is relative to .The mkdirs field is useful when a build of binding generator tool does not automatically create\nrequired nested folders.Directories are not created if the command is skipped because of up-to-date checks, see\n and\n.Directories are created after executing .\nOptional list of paths and globs which are used as sources for performing up-to-date checks.If defined then  also have to be used.The up-to-date check\nskips executing \nif all matching files defined by \nare newer then the matched files defined by sources.\nOptional list of paths and globs which are used as targets for performing up-to-date checks.If defined then  also have to be used.See  for up-to-date check details.\nOptional map of named templates, which can be used in .Templates help in extracting common build patterns and reuse them for multiple components.The templates field can be defined in multiple application manifest documents, but the template names must be\nunique.See Template variable and functions for more information about templating.\ntemplates:\nmy-template:\nsourceWit: wit\ncomponentWasm: build/{{component_name | to_snake_case}}\n# ...\nmy-template-with-profiles:\nprofiles:\ndebug:\n# ...\nrelease:\n# ...\ncomponents:\npack-ns:component-a:\ntemplate: my-template\npack-ns:component-b:\ntemplate: my-template\nsourceWit: custom-wit # override\npack-ns:component-c:\ntemplate: my-template-with-profiles\nprofiles:\ndebug:\nsourceWit: custom-wit # override\nString which selects the default profile for the template. Required if profiles are used. Must be one\nof the defined profile names in .\ntemplates:\n  rust:\n    profiles:\n      debug:\n        # ...\n      release:\n        # ...\n    defaultProfile: debug","fields-and-changes-by-releases#Fields and changes by releases":""}},"/cli/components":{"title":"Golem CLI Components","data":{"":"Golem components are WASM components deployed to Golem for execution.To create, list, build and deploy components you can use golem component command.","creating-a-new-component#Creating a new component":"To create a new component in an application directory (previously created with golem app new) use the component new command in the following way:\ngolem component new <template-name> <component-name>\nTo see all the available component templates, just run the command without providing one.This command only modifies the source code of the application, does not create anything on the server.","building-a-component#Building a component":"To build a component, use the component build command in the following way:\ngolem component build <component-name>\nTo build the whole application, use the app build command in the following way:\ngolem app build\nBoth commands accept a --build-profile <BUILD_PROFILE> argument. Some of the built-in templates define a separate release profile which creates a more optimized version of the components. Build profiles can be fully customized by editing the application manifest files.","deploying-a-component#Deploying a component":"To deploy a component, use the component deploy or app deploy commands in the following way:\ngolem component deploy <component-name>\nor\ngolem app deploy <component-name>\nto deploy a specific component only.The output of the command will be something like the following:\nNew component created with URN urn:component:d8bc9194-a4a2-4a57-8545-43408fc38799, version 0, and size of 89735 bytes.\nComponent name: my-component.\nExports:\n        rpc:counters/api.{[constructor]counter}(name: string) -> handle<0>\n        rpc:counters/api.{[method]counter.inc-by}(self: &handle<0>, value: u64)\n        rpc:counters/api.{[method]counter.get-value}(self: &handle<0>) -> u64\n        rpc:counters/api.{[method]counter.get-args}(self: &handle<0>) -> list<string>\n        rpc:counters/api.{[method]counter.get-env}(self: &handle<0>) -> list<tuple<string, string>>\n        rpc:counters/api.{inc-global-by}(value: u64)\n        rpc:counters/api.{get-global-value}() -> u64\n        rpc:counters/api.{get-all-dropped}() -> list<tuple<string, u64>>\n        rpc:counters/api.{bug-wasm-rpc-i32}(in: variant { leaf }) -> variant { leaf }\n        rpc:counters/api.{[drop]counter}(self: handle<0>)\nThe returned output contains the following information:\nComponent URN - URN for the new component. You can use this URN whenever you want to specify the component instead of component name.\nComponent version - incremental component version - used for updating the agents.\nComponent size - size of the wasm file - it is important for the storage limit in the hosted Golem Cloud.\nExports - exported function you can call. You can copy function name (the part before parameters) to call the function. All Golem API expect function names in exactly this format. See the name mapping page for more details.\nTo deploy all components of an application, use:\ngolem app deploy\nTo deploy the component based on the current directory, use:\ngolem component deploy","ephemeral-components#Ephemeral components":"Components created are durable by default. To create an ephemeral component instead, change the component's application manifest (golem.yaml) to contain:\ncomponents:\n  example:component:\n    componentType: ephemeral","component-search#Component search":"","using-component-name-and-the-latest-version#Using component name and the latest version":"If you want to get the latest version of the component using its name you can you can use the component get command.\ngolem get example:component","using-component-name-and-specific-version#Using component name and specific version":"To get a specific version of a component, just pass the desired version number as well:\ngolem get example:component 2","getting-component-list#Getting component list":"To get all component versions for specific component name you can use component list command with a given component name. Note if you are in a component's source directory, the command will automatically list that component's versions.\ngolem component list example:component\nTo get all component available you can use component list command this way:\ngolem component list\nIf you want to restrict component search to some specific project on Golem Cloud you can specify\nproject via --project or --project-name option. It works for all commands that accept\n--component-name parameter.","updating-component#Updating component":"To update a component just run the component deploy (or app deploy) command again.If you want to trigger an update all agents to the new latest version right after creating this version you can use --try-update-agents option.It is possible to change the component's type (from durable to ephemeral, or from ephemeral to durable) when\nupdating the component by changing the manifest file.","updating-agents#Updating agents":"If you want to update all agents you can use component try-update-agents command.This command gets all agents for the component that are not using the latest version and triggers an update for them one by one:\ngolem component try-update-agents example:component\nThe update request is enqueued and processed by the agents asynchronously, golem cannot await for the update to finish.\nNote that automatic agent update is not guaranteed to succeed, if the updated component differs\ntoo much from the previous one.\nYou can use URL or --component-name instead.","redeploying-agents#Redeploying agents":"During the development of a Golem Component, it is often necessary to quickly rebuild the code, update the component and just restart all the test agents from scratch to test the changes.This is different from updating the agents as they will loose their state, but it can speed up the feedback loop during development.This workflow is supported by the component redeploy command:\ngolem component redeploy example:component\nThis command deletes all agents that are not using the latest version of component and re-creates them with the same name, parameters and environment variables.\nYou can use URL or --component-name instead."}},"/cli/permissions":{"title":"Golem CLI Permissions","data":{"":"This page only applies to the hosted Golem Cloud.","tokens#Tokens":"Tokens are API keys that allow accessing Golem Cloud APIs from external services. The golem-cloud-cli tool allows managing these tokens.\nTo manage them programmatically, check the token API.","listing-existing-tokens#Listing existing tokens":"The following command lists all the tokens associated with your account:\ngolem token list","creating-a-new-token#Creating a new token":"To create a new token, use the following command:\ngolem token add\nNew token created with id 08bc0eac-5c51-40a5-8bc6-5c8928efb475 and expiration date 2100-01-01 00:00:00 UTC.\nPlease save this token secret, you can't get this data later:\n64cf566c-ed72-48e5-b786-b88aa0298fb4\nOptionally, an expiration date can be specified with --expires-at. If not specified, default expiration date is 2100-01-01 00:00:00 UTC.","deleting-a-token#Deleting a token":"Each token has a token ID. Use the token delete command to remove a token using it's identifier:\ngolem token delete 08bc0eac-5c51-40a5-8bc6-5c8928efb475","project-sharing#Project sharing":"On Golem Cloud components are organized into projects.","listing-projects#Listing projects":"Existing projects can be listed using the project list subcommand:\ngolem project list","adding-projects#Adding projects":"A new project can be created using project add. The command expects a project name and description:\ngolem project add --project-name \"Golem Demo\" --project-description \"A new project for demonstrating the project feature\"\nWhen creating components or agents, the project can be specified with the --project-name flag. Every user has a default project which is used when no explicit project is specified.","sharing-projects-with-other-accounts#Sharing projects with other accounts":"The share command still uses the old terminology of workers instead of talking about agents. This is going to be changed in the next version.\nProjects can be shared among multiple Golem Cloud accounts.To share a project, use the share subcommand:\ngolem share --project-name \"Golem Demo\" --recipient-account-id 08bc0eac-5c51-40a5-8bc6-5c8928efb475 --project-actions ViewWorker --project-actions ViewComponent\nThis example shares the \"Golem Demo\" project with the account identified by 08bc0eac-5c51-40a5-8bc6-5c8928efb475 and grants component and agent view permissions for it.\nAlternatively it is possible to create and manage project policies using the project-policy\nsubcommand, and refer to these policies in the share command later.\nThe following table lists all the actions that can be granted to a project:\nAction\tDescription\tViewComponent\tList, download and get metadata of components\tCreateComponent\tCreate new components\tUpdateComponent\tUpdate existing components\tDeleteComponent\tDelete components\tViewWorker\tList and get metadata of workers\tCreateWorker\tCreate new workers\tUpdateWorker\tUpdate existing workers\tDeleteWorker\tDelete workers\tViewProjectGrants\tList existing project grants\tCreateProjectGrants\tGrant more access for the project\tDeleteProjectGrants\tRevoke access for the project\tViewApiDefinition\tView API definitions\tCreateApiDefinition\tCreate new API definitions\tUpdateApiDefinition\tUpdate existing API definitions\tDeleteApiDefinition\tDelete API definitions"}},"/cli/plugins":{"title":"Golem CLI Plugins","data":{"manage-the-available-plugins#Manage the available plugins":"To manage the plugins available for installation, use the golem plugin commands.See the Plugins page for general information about Golem plugins.","list-the-available-plugins#List the available plugins":"To list the available plugins, use the golem plugin list command.\ngolem plugin list\nPlugins can be installed to different scopes. By default the command lists the plugins installed in the global scope.Use the following options to list plugins in other scopes:\n--project <PROJECT_NAME>: List plugins installed in the given project's scope\n--component <COMPONENT_NAME>: List plugins installed in the given component's scope.","get-information-about-a-registered-plugin#Get information about a registered plugin":"To get more information about one of the available plugins, use the golem plugin get command:\ngolem plugin get <PLUGIN_NAME> <PLUGIN_VERSION>","register-a-new-plugin#Register a new plugin":"Plugins are identified by their name and version. To register a new plugin, use the golem plugin register command:\ngolem plugin register <MANIFEST_PATH>\nThe parameter should point to a plugin manifest YAML describing all the properties of the plugin.","the-plugin-manifest#The plugin manifest":"The plugin manifest consists of the following required global fields:\nfield name\tdescription\tname\tThe name of the plugin\tversion\tThe version of the plugin\tdescription\tA short description of the plugin\ticon\tPath to the plugin's icon\thomepage\tURL to the plugin's homepage\t\nThe details of the plugin are specified in the specs field, which is an object.The specs.type field specifies the type of the plugin. It can be one of the following:\nComponentTransformer: The plugin is a component transformer plugin.\nOplogProcessor: The plugin is an oplog processor plugin.\nApp: The plugin is an application plugin.\nLibrary: The plugin is a library plugin.\nThe rest of the fields of the spec object depend on the plugin type.ComponentTransformer fields\nfield name\trequired\tdescription\tprovidedWitPackage\tNo\tThe path to the WIT file describing the extra provided interfaces the plugin adds\tjsonSchema\tNo\tThe path to the JSON schema file describing the plugin's configuration fields\tvalidateUrl\tYes\tURL to the external component transformation service's validate endpoint\ttransformUrl\tYes\tURL to the external component transformation service's transform endpoint\t\nOplogProcessor fields\nfield name\trequired\tdescription\tcomponent\tYes\tThe path to the oplog processor component (WASM)\t\nApp fields\nfield name\trequired\tdescription\tcomponent\tYes\tThe path to the application component (WASM)\t\nLibrary fields\nfield name\trequired\tdescription\tcomponent\tYes\tThe path to the library component (WASM)","unregister-a-plugin#Unregister a plugin":"To unregister an available plugin, use the following command:\ngolem plugin unregister --plugin-name <PLUGIN-NAME> --version <PLUGIN-VERSION>","manage-a-components-plugins-using-the-app-manifest#Manage a component's plugins using the app manifest":"The recommended way to apply plugins to components is to define them in the app manifest.The set of installed plugins can be set for each component in the app manifest under the plugins key:\ncomponents:\n  my:example:\n      template: ts\n      plugins:\n          - name: component-transformer-1\n            version: v1\n            parameters:\n              x: 1\n              y: 2\nThe name and version fields of each installed component must match one of the available components installed to the system with the golem plugin commands described above.The parameters field contains an arbitrary set of key-value pairs, their meaning depending on the actual plugin.It is possible to install multiple plugins to a component, and the order they are going to be applied is going to match the order of the elements in the app manifest.To apply the changes, use one of the golem app deploy or the golem component deploy commands.","manage-a-components-plugins-explicitly#Manage a component's plugins explicitly":"There are CLI commands to explicitly install, uninstall or update a component's set of installed plugins. These commands may get deprecated in the future in favor of using the app manifest as described above.A subset of the registered plugins can be installed for a component using te golem component plugin commands.","get-the-installed-plugins#Get the installed plugins":"To get the list of installed plugins for a component, use the following command:\ngolem component plugin get <COMPONENT-NAME> <VERSION>","install-a-plugin#Install a plugin":"To install a plugin for a component, use the following command:\ngolem component plugin install --plugin-name <PLUGIN_NAME> --plugin-version <PLUGIN_VERSION> --priority <PRIORITY> [COMPONENT_NAME]\nMany plugins require per-installation configuration. These are key-value pairs that can be passed as arguments to the install command as --param <KEY=VAL>.The priority is a number that determines the order in which plugins are applied.","uninstall-a-plugin#Uninstall a plugin":"To uninstall a plugin from a component, use the following command:\ngolem component plugin uninstall --installation-id <INSTALLATION_ID> [COMPONENT_NAME]\nThe installation ID is a unique identifier assigned every time a plugin is installed for a component. It is not enough to use the plugin name and version here, because one plugin can be installed multiple times (for exampel with different configuration) for a component.","updating-a-plugins-priority-or-configuration#Updating a plugin's priority or configuration":"To update a plugin's priority or set of configuration parameters, use the following command:\ngolem component plugin update --installation-id <INSTALLATION_ID> --priority <NEW_PRIORITY> --param <KEY=VALUE> [...--param <KEY=VALUE>] [COMPONENT_NAME]\nThe installation ID is a unique identifier assigned every time a plugin is installed to a given component version, or its configuration has been changed.","manage-a-projects-plugins#Manage a project's plugins":"In Golem Cloud it is also possible to install plugins for a project. Every component created in the project will get the installed plugins from the project.","get-the-installed-plugins-1#Get the installed plugins":"To get the list of installed plugins for a project, use the following command:\ngolem project plugin get [PROJECT_NAME]\nThe PROJECT_NAME parameter can be either a project's name (if it is not ambigous), or it can be prefixed by the project's owner account's email address.","install-a-plugin-1#Install a plugin":"To install a plugin for a project, use the following command:\ngolem project plugin install --plugin-name <PLUGIN_NAME> --plugin-version <PLUGIN_VERSION> --priority <PRIORITY> --param <KEY=VALUE> [...--param <KEY=VALUE>] [PROJECT_NAME]\nMany plugins require per-installation configuration. These are key-value pairs that can be passed as arguments to the install command as --param <KEY=VAL>.The priority is a number that determines the order in which plugins are applied.","uninstall-a-plugin-1#Uninstall a plugin":"To uninstall a plugin from a project, use the following command:\ngolem project plugin uninstall --installation-id <INSTALLATION_ID> [COMPONENT_NAME]\nThe installation ID is a unique identifier assigned every time a plugin is installed for a component. It is not enough to use the plugin name and version here, because one plugin can be installed multiple times (for exampel with different configuration) for a component.\n### Updating a plugin's priority or configuration\nTo update a plugin's priority or set of configuration parameters, use the following command:\n```shell copy\ngolem project plugin update --installation-id <INSTALLATION_ID> --priority <NEW_PRIORITY> --param <KEY=VALUE> [...--param <KEY=VALUE>] [PROJECT_NAME]\nThe installation ID is a unique identifier assigned every time a plugin is installed to a given component version, or its configuration has been changed."}},"/cli/install-from-source":{"title":"Golem CLI installation from source","data":{"":"If the precompiled binaries are not available for your platform, or you prefer to install from source, you can build it with the Rust toolchain.","prerequisites#Prerequisites":"To build golem-cli you need to use cargo, Rust's build tool.To get cargo on your system, we recommend using rustup:\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nrustup install stable\nrustup default stable","installing-golem-cli#Installing golem-cli":"The golem-cli command is the lightweight version of Golem's command line interface, which allows you to interact with a running Golem cluster, but it does not include a built-in local version of Golem itself.To install golem-cli from source, use cargo install:\ncargo install golem-cli --git https://github.com/golemcloud/golem --tag v1.3.1\nNote that currently installing from crates.io is not possible because the package requires a patched wasmtime version. Always use the --git parameter or our precompiled binaries.\nThis will create a binary file named golem-cli in the ~/.cargo/bin directory.","installing-golem#Installing golem":"The golem binary is the full version of Golem's command line interface, containing everything golem-cli has, and it also includes a built-in local version of Golem itself.The golem package is not published to crates.io, so to install it from source, follow the steps below.","clone-the-repository#Clone the repository":"Clone the GitHub repository:\ngit clone https://github.com/golemcloud/golem-cli.git","install-cargo-make#Install cargo-make":"Install cargo-make using cargo install:\ncargo install cargo-make --locked","build-the-project#Build the project":"Build the project using cargo make:\ncargo make build"}},"/cli/shell-completion":{"title":"Golem CLI shell completion","data":{"":"The golem completion command can be used to generate shell completions for many popular shells:\ngolem completion bash\ngolem completion elvish\ngolem completion fish\ngolem completion powershell\ngolem completion zsh\nThe above command will generate and print the shell completion script to standard output. Redirect the output to a file to save the script. Consult your shell documentation about where to place it.\nAfter every Golem update, it is recommended to regenerate the shell completions to include the latest commands and flags."}},"/cli/profiles":{"title":"Golem CLI Profiles","data":{"":"Using different profiles you can use golem with multiple installations of an open source Golem and the hosted Golem Cloud at the same time.","interactive-profile-creation#Interactive profile creation":"To start interactive profile creation run the following command:\ngolem init\nIf you want to specify a custom profile name for the interactive profile creation process, you can use the following command:\ngolem profile init custom-name\nIn the first step you'll see three options:\nGolem Default. Use this option for the default local Docker Compose installation.\nGolem. Use this option in case of a customized Golem installation, i.e. a custom GOLEM_ROUTER_PORT in the .env file.\nGolem Cloud. Use this option for a hosted version of Golem.\nWith the Golem Default and the hosted Golem Cloud options, there are no other specific configuration options.\nTo specify a custom location for your local open source Golem installation, please use the Golem option.","non-interactive-profile-creation#Non-interactive profile creation":"","hosted-golem-cloud-profile#Hosted Golem Cloud profile":"To create a profile for a hosted Golem Cloud use the following command:\ngolem profile add --set-active golem-cloud --default-format json my-profile-name\nThis command creates a new Golem Cloud profile named my-profile-name with default output format json and sets it as a new active profile.\nIf you want to keep default output format text - you can omit --default-format json part. If you don't want to make the new profile as the new active profile - you can omit --set-active.If you are using golem-cloud-cli binary you should omit profile type (golem-cloud) since golem-cloud-cli does not support other profile types:\ngolem-cloud-cli profile add my-profile-name","local-open-source-golem#Local open source Golem":"To create a profile for your local open source Golem installation use the following command:\ngolem profile add --set-active golem --component-url http://localhost:9881 my-oss-profile-name\nThis command creates a new open source Golem profile named my-oss-profile-name with both component and worker service location as http://localhost:9881 and sets it as the new active profile.Additionally, you can specify the --default-format option (json or yaml) instead of the human-readable text, and --worker-url in case you want to have worker and component services at different locations.If you are using an open source specific golem - you should omit profile type (golem). If you are using a Golem Cloud specific golem-cloud-cli - you can't create an open source Golem profile.","profile-authentication#Profile authentication":"This section is specific to Golem Cloud.\nTo authenticate your Golem Cloud profile, you can run any command that requires authentication, for example, any command that accesses Golem Cloud servers.\nThe easiest way to authenticate your profile would be to run the following command:\ngolem account get\nAt the moment, the only way to authenticate your account is to use GitHub OAuth2 authorization. Please follow the instructions in your terminal and authorize the ZivergeTech organization to use OAuth2:\n>>\n>>  Application requests to perform OAuth2\n>>  authorization.\n>>\n>>  Visit following URL in a browser:\n>>\n>>   ---------------------------------\n>>    https://github.com/login/device \n>>   ---------------------------------\n>>\n>>  And enter following code:\n>>\n>>   -----------\n>>    ADFC-A318 \n>>   -----------\n>>\n>>  Code will expire in 14 minutes at 15:15:27.\n>>\nWaiting...\nAccount with id account-id for name Your Name with email your@email.com.","switch-profiles#Switch profiles":"To get the list of your profiles use the following command:\ngolem profile list\nYou'll get all available profiles with the active profile marked by *:\n * my-oss-profile-name\n   my-profile-name\nTo switch the active profile, use the profile switch command:\ngolem profile switch my-profile-name","golem-profile-configuration#Golem profile configuration":"At the moment, the only configurable option is the default output format.To change the default output format for the current active profile, you can use the profile config format command as follows:\ngolem profile config format text","output-formats#Output formats":"There are 3 output formats:\ntext - human-readable format\njson\nyaml\nAlmost all commands can change the output format based on the --format option or the default output format configured for the current active profile.","profile-configuration-files#Profile configuration files":"All golem configuration files are stored in the .golem directory in your home directory. This includes the cached authentication token for your Golem Cloud profile.\nIt is safe to remove the $HOME/.golem directory in case of any issues with profilesyou will keep access to your Golem Cloud account as long as you have access to your GitHub account linked to your Golem Cloud account."}},"/concepts/agent-to-agent-communication":{"title":"Introduction","data":{"":"Golem is a durable computing platform that makes it simple to build and deploy\nhighly reliable distributed systems.The WASM component model eliminates the need for microservice architectures,\nsince components written in different languages can interact with each other\nin-process (through component composition), without having to go through\nremote protocols like HTTP, gRPC, or JSON RPC.Despite this, however, there are times when remote procedure calls (RPC) are\nuseful or necessary when developing applications on Golem:\nYou want to parallelize computation that cannot be done on a single agent,\neither due to lack of memory or lack of compute.\nYou want to partition state that is too large to store in a single agent;\nor, perhaps, you want to partition state that can fit in a single agent, but\ncannot be read and written fast enough due to contention.\nBoth of these are examples require the development of a distributed system,\nwhere some combination of state and computation is distributed to improve\nperformance, reduce latency, or improve scalability.To build a system that distributes state or compute, it is necessary to\ncoordinate work, which requires RPC of some kind.Recognizing the critical nature of internal communication for many distributed\nsystems, Golem provides a feature called agent-to-agent communication. This\nfeature allows you to simply, and in a type-safe way, communicate between\nagents, with strong guarantees, such as reliable, exactly-once invocation\nsemantics.For agent-to-agent communication, Golem generates a type-safe client interface for each remotely callable agent type. These client interfaces are matching the agent type's interface.\nAgent to Agent Communication"}},"/concepts/agents":{"title":"Introduction","data":{"":"Golem is a durable computing platform that makes it simple to build and deploy\nhighly reliable distributed systems.In server-based programming, the fundamental unit of work is the server, which\naccepts incoming connections, and handles requests by generating responses.In Golem, which is a serverless computing platform, the fundamental unit of\nwork is the agent. An agent is a running instance of an agent type, defined in a component, with a\nunique identity, which allows addressing specific workers.Agents are similar to lambdas or functions in other serverless computing\nplatforms, but they are far more powerful and expressive.\nThe relationship between an agent type and an agent is the same as the relationship between an\nexecutable and a process: processes are running instances of executables. While the executable\ncontains mostly code, which awaits execution, a process contains both code, as well as dynamic\nstate, which captures work-in-progress.\nThe fundamental elements of every agent include:\nIdentity. Every agent has a unique identity, which allows addressing\nspecific agents.\nState. Every agent has state, including memory, environment variables,\nand file system.\nAPI. Every agent has a public API, defined by its agent type.\nThese core elements are discussed in the sections that follow.","ephemeral-vs-durable-agents#Ephemeral vs Durable Agents":"Golem supports two types of agents, ephemeral and durable. Ephemeral agents are created on the fly for each invocation, and are not suitable for stateful applications. This makes them cheaper and more performant. Durable agents, on the other hand, preserve their state across invocations and provide much stronger guarantees.Whether an agent is ephemeral or durable depends on the configuration of the deployed component. The component type can be changed from ephemeral to durable or the other way around, but this change results in a new component version, and will not affect the already running agents.","identity#Identity":"Every agent has a globally unique identity, which is formed from the\nfollowing elements:\nComponent ID. Every component deployed on Golem has a globally\nunique identity (UUID), which is assigned by Golem when a new component\nis uploaded to Golem.\nAgent type. The agent type name identifies the agent type of the ones\ndefined in the component. Each component may define multiple agent types.\nAgent parameters. Each agent type defines a constructor and part of an agent's identity is the values passed to this constructor. Every set of constructor parameter values identifies exactly one instance of that agent type.\nThe unique identity of agents allows them to be addressed individually,\nwhich unlocks many powerful patterns for building distributed systems.","durable-agent-state#Durable Agent State":"Agents are inherently stateful, in the same way that any running process\nis stateful. Agents have the following stateful elements:\nMemory. An agent has in-memory state, such as global variables, stack,\nand so on, which constantly changes over the life of the agent.\nEnvironment Variables. An agent has environment variables, which it\ninherits from component settings and any initial settings when the agent is\ncreated, and which may change over time.\nFile System. An agent has a file system, which currently starts out\nempty, but which may evolve over the life of the agent.\nStatus. The status of the agent, managed by Golem, is one of the\nfollowing: running, idle, suspended, interrupted, retrying, failed, or\nexited.\nState also includes something called the instruction pointer, which is not\naccessible in most programming languages, but which tracks which location in the\ncode the CPU is currently executing.","api#API":"Agents are running instances of agent types. Agent types define a public\nAPI, which every agent inherits.To perform work, such as handling a request, you invoke an agent's public API.\nThis process is referred to as invocation, and you can learn more in the\nsection on invocation.Golem executes agents with strong guarantees. To understand these guarantees,\nyou should read the section on reliability.However, in brief, Golem provides the following guarantees:\nTransactional Execution. Agents are executed transactionally. Once a\nagent is started, it will be executed to completion, even in the presence of\nfaults, restarts, or updates. It's perfectly acceptable to use agents for\nhigh-value use cases, such as financial transaction processing; or for\nimplementing APIs that coordinate updates across multiple systems.\nDurable State. All agent state, including in-memory state, is durable,\nand can be treated as automatically persistent. This means that state\nsurvives failures, restarts, and updates without the loss of any\ninformation. Agents may treat their memory as a database, and use it to\npersist state indefinitely and across any number of invocations.\nReliable Internal Communication. Agents can communicate with each other\nusing their public APIs, in a type-safe way. Agent-to-agent communication\nis reliable, with exactly-once semantics, and can be used to build\nsophisticated and stateful distributed systems.\nResilient External Communication. Agents can freely communicate with\nexternal systems, such as databases, message queues, and APIs. External\ncommunication is automatically resilient, with exactly-once semantics for\nsystems that support idempotency keys, and at-least-once semantics for\nsystems that do not.\nIndefinite Life. Unless forcibly deleted or failed in a way that is\nunrecoverable (e.g. corruption of memory in a C program), agents live\nforever, without loss of state or progress. This allows workers to be used\nfor long-running tasks, such as background processing, or for implementing\nAPIs that require long-lived state.\nSecure Sandboxing. Agents are executed in completely sandboxed\nenvironments, with no possibility of agents interacting with each other\n(except via their public APIs), and no possibility that one agent's failure\nimpacts another agent's health.\nSome of these guarantees are common across all serverless platforms, but others\nare unique to the durable computing environment that Golem provides.Although Golem brings the power of durable computing to serverless, it is still\npossible to use Golem as a classic serverless platform.This enables increased reliability and use of serverless for long-running tasks,\nfinancial transactions, and other use cases that are not well-suited to\ntraditional serverless platforms.","comparing-functions-to-agents#Comparing Functions to Agents":"Agent\tFunction\tExplanation\tLow-Latency\t\t\tFunctions in serverless environments are designed to execute quickly, making them suitable for low-latency use cases.\tScalable\t\t\tFunctions in serverless environments scale automatically, making them suitable for high-throughput use cases.\tStateful\t\t\tAgents are inherently stateful, which means they maintain state for their lifetime, and across repeated invocations.\tLong-Running\t\t\tAgents run indefinitely, without loss of state or progress, making them uniquely suitable for long-running tasks.\tTransactional\t\t\tAgents are executed with strong transactional guarantees, transparently surviving faults, restarts, and updates.\tPersistent\t\t\tAll agent state, including in-memory state, is persistent and survives failures, restarts, and updates without loss.","emulating-classic-serverless#Emulating Classic Serverless":"Golem's ephemeral agents are emulating the classic serverless behavior, with the difference that they can have multiple entry points (exported functions). To fully emulate the classic serverless approach, you only need to do two things:\nOne-Export Component. While WASM components can have any number of\nexports, when emulating classic serverless, you should only have one export\nper component. This export represents the event or request handler that you\nwould typically have in a classic serverless function.\nDefine the component as ephemeral. Choosing the ephemeral component type will make all its agents ephemeral (of every agent type defined in that component).\nRequest ID parameter. Because agents are identified by their constructor parameters, it is required to have a constructor parameter that can be different for each request. This can be a string or UUID parameter.\nGolem still persists some information about each ephemeral agent that was created, which can be used for debugging purposes, but this state gets persisted in the background, not affecting the agent's performance.","operations#Operations":"Agents support the following operations:\nCreation. Agents benefit from automatic creation, which occurs when an\nagent is invoked for the first time. Therefore, it is not necessary to\ncreate agents explicitly.\nInterruption. Agents can be interrupted at any time, which causes the\nagent to stop executing. Interrupted agents can be resumed later.\nDeletion. Agents can be deleted, which causes all state of the agent\nto be permanently deleted. Deleted agents cannot be undeleted or resumed,\nand if invoked again, they will be recreated from scratch.\nUpdating. Agents can be updated to a newer version of a component, which\nis useful for long-lived agents that can benefit from bug fixes or new\nfeatures.\nObservation. The persistent operation log of an agent can be queried and searched, which can be useful in debugging and auditing scenarios.\nDetails about how to perform these operations can be found in the CLI guide,\nthe REST API reference, and language-specific SDK documentation.","agent-update#Agent Update":"When a new version of a component is created (by deploying a new version of the component, changing its type or installing plugins to it), the existing agents continue to run using the version they have been created with. Existing agents have to be explicitly updated to a new version if needed.Newly created agents are created using the latest version of the component. This also means that for ephemeral agents each invocation always runs using the latest version of the component.There are two ways to update an existing agents to a new version of a component, and the update operation (triggered through the REST API, CLI, Console or host interface) can choose from either of them. These are the following:\nAutomatic update. Golem tries to automatically update the agent to the new version, and may fail to do so.\nManual update. For manual update the component author must provide a pair of save/load functions that are used to migrate the state of the agent from the old version to the new version.","automatic-update-details#Automatic update details":"Automatic update can be initiated any time, even while the agent is processing an invocation. The executor interrupts the agent, reloads it using the new component version and then replays the agent's oplog from the beginning of time. If the replay succeeds with the new codebase, the worker continues running from where it was interrupted, but now on the new component version. If the replay fails, the agent gets reverted to the original component version and continues running with that.How can the replay fail? Golem performs divergence detection during replaying the oplog. The following situations are considered divergences:\nInvocation result divergence. If the new component produces a different result value for a past invocation than the old one\nSide effect divergence. If the new component would perform different side effects (such as HTTP requests, generating random numbers, accessing the current time, etc) than the ones that have been recorded.\nBecause of these strict requirements, automatic update is only useful when the changed code is minor or it affects code paths that haven't run yet or did not exist at all before.","manual-update-details#Manual update details":"For manual update the old component version must implement saveSnapshot method, and the new component version must implement the loadSnapshot method. The update operation is enqueued the same way as invocations are enqueued, as it can only be performed when the agent is idle. As soon as all the previously enqueued and running invocations are finished, the executor calls the save snapshot function that returns an array of bytes representing the state of the agent. Then the agent gets restarted using the new component version, and the new component's load snapshot functions is called with the saved state. The load snapshot function may return with a failure in which case the agent's component version gets reverted to the original version and it continues running with that. Otherwise if the snapshot was successfully loaded the agent continues running with the new component version."}},"/concepts/plugins":{"title":"Introduction","data":{"":"Golem Plugins provide ways to extend the functionality of Golem without having to modify the core codebase. Plugins can be installed to both the open-source and the hosted versions of Golem.This page introduces the types of plugins Golem supports and explains their lifecycle.\nPlugin support is experimental and not fully available in Golem 1.1 yet. The next release will\ninclude stronger guarantees, UI support and better documentation and examples.","types-of-plugins#Types of plugins":"Golem supports the following types of plugins:\nComponent transformer plugins can alter an uploaded component when it gets uploaded to Golem\nOplog processor plugins can observe running agents\nLibrary plugins and application plugins are special, easier to use versions of component transformer plugins","component-transformer-plugins#Component transformer plugins":"Component transformer plugins are external web services providing an HTTP endpoint that receives a WASM component and returns a transformed WASM component. The most common use case for this type of plugin is to use component composition to achieve one of the following goals:\nReplace one or more of the host interfaces provided by Golem. For example a component transformer plugin may implement the WASI KeyValue store interface for a component by connecting to a third party database, instead of using the one provided by Golem.\nWrap the host interfaces provided by Golem. In this case the adapter the plugin composes the uploaded component with both imports and exports the same interfaces, and by that wraps Golem's implementation for example to publish metrics or perform logging.\nExtend the provided interface of the component by exporting additional invokable functions.","library-plugins#Library plugins":"Library plugins are special component transformer plugins that do not require any external HTTP service to be running. A library plugin is a WASM component that is going to be composed with the user's uploaded components in a way that every exported interface of the plugin's WASM is plugged into the user component's matching imports.","application-plugins#Application plugins":"Application plugins are similar to library plugins with the difference that the user's component's exported interface is getting plugged into the plugin's matching imports.","oplog-processor-plugins#Oplog processor plugins":"Oplog processor plugins are special golem agents implementing the golem:api@1.1.7/oplog-processor interface. These plugins are instantiated by Golem and are periodically invoked with oplog entries, a journal of operations performed by agents where the plugin is installed.\nOplog processor plugin support is experimental. The final version will guarantee exactly-once\nsemantics for processing the oplog of the agents, which means that if the plugin is installed and\nactivated for an agent, we guarantee that the plugin will receive all of the oplog entries of\nthat agent (even from before the plugin was active), and each entry will be only sent exactly\nonce. This guarantee is not implemented yet.","plugin-configuration#Plugin configuration":"Plugins can have configuration in the form of key-value pairs, which are customizable for each plugin installation. Golem sends these configuration values to the plugins when they are invoked.","plugin-lifecycle#Plugin lifecycle":"Plugins are first defined using Golem's Plugin API (using the REST API, CLI or the Console). Each defined plugin is identified by a name and a version. In Golem Cloud plugins are defined per account.Defining a plugin does not immediately make that plugin used by Golem. To make use of a plugin, it must be installed to a component. This can be done either when a component is created, or later using the Component API. In Golem Cloud plugins can also be installed to projects, in which case each new component created in the given project will have those plugins installed.Installing a plugin to a component creates a new component version, similarly how updating a component's WASM file does. This guarantees that already running agents are not affected by the plugin installation process. To make an existing agent use of an installed plugin, the agent must be updated to the new component version.Oplog processor plugins can also be activated and deactivated on a running agent dynamically using the Agent API. This is an advanced feature which allows the user to temporarily pause an effect of a plugin for a given agent."}},"/concepts/api-definitions":{"title":"Introduction","data":{"":"Golem is a durable computing platform that makes it simple to build and deploy\nhighly reliable distributed systems.As a serverless platform, Golem allows you to deploy components of your\napplication, without having to write servers or implement protocols like HTTP,\ngRPC, or GraphQL.Without having to write any additional code, Golem provides you with the ability\nto trigger the creation of agents from your components based on HTTP API calls.Although useful for building tooling or quick prototypes, the generic APIs that\nGolem gives you to create and interact with your agents are usually not the\npolished, engineered APIs that you want to expose to other organizations,\ndevelopers of mobile or web applications, or other backend teams.To allow you to stand up a custom API for your components, Golem supports a\nfeature called API Definitions. API definitions give you the flexibility of\nhaving a precisely engineered API, but without any of the typical boilerplate.This page contains a high-level introduction to API definitions, with links to\ntechnical reference material.In Golem, an API Definition is similar to an OpenAPI specification for an API.\nLike OpenAPI specifications, API Definitions contain the following elements:\nVersion. The version defines the version of the API.\nStatus. The status defines whether the API is a draft, or whether it is\npublished. Currently, published APIs may not be modified.\nRoutes. The routes are a list of individual HTTP endpoints.\nIn an API definition, the routes define not just the structure of the overall\nHTTP, but also how invocation of these APIs triggers the creation and activation\nof agents.The next section introduces routes in more detail.","routes#Routes":"The elements of a route are as follows:\nPath. The path of the route, such as /users/{user-id}. Paths may\ncontain variables, which may be accessed inside the route binding.\nMethod. The method of the route, such as GET, PUT, POST, or DELETE.\nBinding. The binding defines what agent will be created and invoked\nwhen the endpoint itself is invoked.\nIn the following section, you will learn more about the binding.","bindings#Bindings":"Bindings are the glue that connects your endpoint to an actual agent.\nExamples of what binding can do include invoking an agent or retrieving files from the agent filesystem.There are a variety of ways to create and manage API Definition:\nGolem CLI. The command-line interface lets you manage API definition.\nREST API. The Golem REST API lets you manage API definition\nBoth the CLI and REST API let you import an existing OpenAPI definition, with\na custom per-endpoint extension that contains the binding.See more examples of implementing custom APIs here."}},"/concepts/reliability":{"title":"Introduction","data":{"":"Golem is a durable computing platform that makes it simple to build and\ndeploy highly reliable distributed systems.When developing for Golem, you normally don't need to worry about most of\nthe complexity of ensuring reliable execution. Golem takes care of the heavy\nlifting for you, ensuring that your applications are resilient, robust,\nfault-tolerant, and highly available.However, when evaluating Golem for your use case, it is essential to understand\nexactly what guarantees Golem provides, what you need to handle on your own,\nand how you can tune Golem to meet your specific requirements.In this section, we'll explore all of these aspects in detail, starting with\nthe essential concepts of reliability in distributed systems.In the field of distributed systems, several technical concepts are crucial to\nthe development of reliable solutions:\nResiliency: The system's ability to correctly identify and respond to\nfailures in external dependencies.\nRobustness: The system's capacity to prevent, identify, and correctly\nrespond to internal failures.\nFault-Tolerance: The system's ability to continue functioning correctly\neven when experiencing one or more faults.\nHigh-Availability: The system's capability to remain available and\nresponsive under various conditions, including partial failures or high stress.\nLet's explore each of these concepts in detail to understand how they\ncontribute to overall system reliability.","resiliency#Resiliency":"Resiliency is the ability of a system to continue functioning correctly even in\nthe presence of failures in the systems it interacts with.Modern systems interact with numerous remote components through network\nprotocols. These external systems can fail in various ways, presenting\nchallenges for maintaining overall system reliability.Common types of external failures include:\nNetwork Failures: Disruptions in connectivity, degraded performance, or\nunstable connections preventing reliable communication.\nInternal Failures in Remote Systems: Bugs, crashes, or other malfunctions\nwithin external systems causing incorrect behavior or non-responsiveness.\nLoad-Related Failures: Overwhelmed systems leading to degraded performance\nor total unavailability.\nMaintenance-Related Downtime: Planned or unplanned system updates,\nmigrations, or other maintenance activities causing temporary unavailability.\nAPI Versioning Incompatibilities: Mismatches between different versions of\ninteracting systems or APIs leading to errors or unpredictable outcomes.\nAuthorization and Authentication Issues: Invalid credentials,\ninsufficient permissions, or other access-related problems.\nHighly resilient systems employ various strategies to handle these external\nfailures:\nIntelligent Retry Mechanisms: Implementing advanced retry policies,\noften combining exponential backoff with random jitter to handle transient\nfailures gracefully.\nCircuit Breaker Pattern: Temporarily disabling calls to failing services\nto prevent cascading failures.\nBulkhead Pattern: Isolating components to ensure that failures in one\npart of the system don't bring down the entire application.","robustness#Robustness":"Robustness is the ability of a system to both prevent, as well as identify and\ncorrectly respond to, failures of the system itself.Internal failure scenarios can be categorized into a hierarchy, ranging from\nbusiness logic issues to infrastructure problems:\nDefect Failures: Errors due to software defects, such as null pointer\nexceptions, buffer overflows, or division by zero.\nDomain Failures: Failures to handle scenarios anticipated and specified\nby the business logic.\nUnrecoverable Failures: Situations where the software cannot recover,\nsuch as database access failures due to incorrect configuration.\nOS Faults: Operating system interference with process execution.\nHardware Faults: Failures in critical hardware components like RAM,\nCPU, or network interfaces.\nStrategies for improving robustness include:\nComprehensive Error Handling: Implementing thorough error handling\ncovering various failure scenarios.\nGraceful Degradation: Allowing systems to continue operating with\nreduced functionality rather than complete shutdown when encountering\nnon-critical failures.\nRapid Failure Detection: Quickly identifying and reporting internal\nfailures to enable fast resolution.","fault-tolerance#Fault-Tolerance":"Fault-tolerant systems are designed to continue functioning correctly even in\nthe presence of one or more faults. Fault-tolerance can be considered a\nspecific type of robustness, focusing on a system's ability to handle systemic\nissues.Strategies for fault-tolerant systems include:\nReplication: Duplicating critical components across multiple nodes to\nensure continued operation if some nodes fail.\nState Management: Implementing robust state management tools to allow\nsystems to recover gracefully from failures without data loss.\nFailover Mechanisms: Automatically redirecting traffic to healthy nodes\nin case of node failures.","high-availability#High-Availability":"High-availability systems are designed to be accessible and responsive to their\nintended workloads, even under conditions of partial failure or stress.Strategies for achieving high availability include:\nLoad Balancing: Distributing traffic across multiple instances to\nprevent any single point of failure.\nAuto-Scaling: Automatically adjusting resources based on demand to\nensure optimal performance during peak times.\nGeographic Distribution: Deploying across multiple geographic regions\nto reduce latency and improve resilience against regional outages.\nReliability is a comprehensive term that encompasses all of the preceding\nconcepts. A highly reliable system is one that is:\nResilient to external failures\nRobust in handling internal failures\nFault-tolerant to systemic issues\nHighly available under various conditions\nBy addressing each of these aspects, developers can create distributed systems\nthat ensure data integrity, maintain consistent performance, and provide a\nseamless experience for end-users, even in the face of various challenges and\nfailure scenarios.With any programming language, tech stack, or SDK, Golem automatically provides\nyou with a high degree of built-in reliability.These guarantees are summarized as follows:\nTransactional execution. Golem ensures that your agents execute\ntransactionally. Once they begin execution, they will complete execution,\neven if there are software or hardware faults, restarts, or updates.\nDurable state. Golem ensures that the state of your agents is durable.\nIf an agent is recovered after a failure, it will resume with the same state\nas before the failure.\nReliable internal communication. Golem ensures that communication\nbetween agents is delivered reliably. If a message is sent, it will\neventually be delivered, with exactly-once semantics; even if there are\nnetwork partitions, faults, or other failures.\nResilient external communication. Golem automatically applies retry\nstrategies and other techniques to ensure that transient failures of\nexternal systems do not affect reliability.\nIn the following sections, we will explore these guarantees in more detail,\nlooking at how each of them improves different faucets of reliability.","resiliency-1#Resiliency":"All components deployed on Golem ultimately derive their capability to interact with external systems\nfrom WASI, which is the Posix-like interface provided by the WASM component\nmodel.WASI provides facilities to interact with file systems, sockets, time, and other\nsystem resources in a portable and secure manner.Because Golem provides a custom implementation of WASI, it has direct insight\ninto the interactions between components and the underlying system. This allows\nGolem to detect a variety of transient failure scenarios and automatically\napply resiliency strategies, such as retries, to ensure that the system remains\nresilient to these failures.Golem automatically applies retry strategies to the following types of failures:\nHTTP Request Failures\nIn the case of errors which are not resolved on their own, Golem will\neventually give up and mark the agent as failed. This is to prevent the\nsystem from getting stuck in an infinite loop of retries.These agents can be detected using agent enumeration.","limitations#Limitations":"Golem does not have awareness into transient errors that are expressed in protocol-\nagnostic ways. For example, if an HTTP response contains a 200 status code, but\nthe body contains a transient error, then Golem will not be able to detect this\nerror and attempt recovery.You should be aware of this limitation when designing your applications, and\nconsider implementing your own retry strategies for such cases.","customization#Customization":"Currently, you can customize an agent's retry policy, including number of\nretries, delays, and so on, but it is a global setting that applies to all\nfailed operations. See the page about retries for details.","fault-tolerance-1#Fault-Tolerance":"Golem's fault-tolerance guarantees are focused on ensuring that your agents\nare executed transactionally and that their state is durable, regardless of\nsoftware or hardware faults, restarts, or updates.In order to more precisely define the scope of these guarantees, we need to\nintroduce some terminology:\nFailure Event. A failure event is any event that causes an agent to\ninterrupt execution, but excluding all internal errors in the worker itself.\nThis includes operating system faults, hardware faults, disruptions\n(termination through the container orchestrator), restarts, and updates.\nSupervision. Supervision is the process by which Golem detects failure\nevents and takes action to recover interrupted agents.\nRecovery. Recovery is the process by which Golem restores the state of\nan agent to its state before the failure event, and resumes execution.","limitations-1#Limitations":"Golem's fault-tolerant guarantees are extensive, and they enable you to build\nhighly reliable distributed systems without having to think about most failure\nscenarios. However, you should be aware of the following limitation:\nExecution Semantics. For external systems (those not executed by Golem),\nGolem generally guarantees only at-least once semantics with respect to\nthe last external request made before the failure event.\nThe following section discusses this limitation in more depth and what you can\ndo to mitigate it.","execution-semantics#Execution Semantics":"All local code, as well as all communication between agents, is executed with\nexactly-once semantics. All local code executed strictly inside Golem,\nincluding agent-to-agent communication, is guaranteed to have exactly-once\nsemantics. This means that during recovery, the state of the agent is restored\nto the exact state it was in before the failure event, and no operations\nperformed by the agent are repeated.However, for remote operations, such as invoking an HTTP API, Golem cannot\ngenerally guarantee exactly-once semantics. This is because a failure event\nmay occur after a request has been sent, but before the response has been\nreceived. In this scenario, during the recovery, the request must be retried,\nwhich may lead to the remote system processing the same request multiple times.To mitigate this issue, you should consider using HTTP APIs that support the\nThe Idempotency-Key HTTP Header Field.\nThis header allows you to provide a unique key for each request, which the\nremote system can use to ensure that the request is idempotent.In a future release, Golem will automatically generate idempotency keys for\neach request. For now, however, you can use the language-specific Golem SDK\nto generate an idempotency key, which you can then pass to the remote system.\nIt is recommended to use the Golem SDK to generate idempotency keys, rather than generating them\nyourself, to ensure that Golem transactionally commits the key to durable persistence right\naway. If you generate a random idempotency key yourself, without also using the Golem SDK to\nmanually perform a commit, then there is a small but nonzero chance that a failure event could\nhappen after the HTTP API is invoked, but before the idempotency key is committed to durable\npersistence.\nIdempotency keys guarantee exactly-once semantics for requests that support\nthem, ensuring that the remote system can safely process the request multiple\ntimes without causing any side effects.","high-availability-1#High-Availability":"Golem is designed to be highly-available with respect to the creation and\nexecution of new agents in the Golem cluster.This is accomplished by supporting large cluster sizes that can evenly\ndistribute workloads any number of nodes, and by automatically rebalancing\nworkloads across the cluster when nodes are added or removed.However, because Golem allows and encourages communication with specific,\nstateful agents, there are limitations around the availability of specific\nagents in the cluster.The following sections overview these limitations.","limitations-2#Limitations":"The availability of specific agents in a Golem cluster is affected by several\ndifferent factors, including all of the following:\nCluster Size. The number of executor nodes in the cluster.\nIf the cluster is too small, then it may not be able to handle the\nworkload, leading to degraded performance or unavailability.\nCluster Resizing. Cluster resizing requires rebalancing the workload\nacross the new set of nodes. This process may take some time, during which\navailability of specific agents being relocated may be degraded.\nExecutor Node Health. If the node running a shard of agents goes\ndown, then those agents will be unavailable until the node is recovered.\nThis process may take anywhere from a few seconds to a few minutes,\ndepending on how quickly the failure is detected and the number of agents\nin the shard.\nShard Manager Health. If the shard manager goes down, there are scenarios\nwhere this can negatively impact availability.","tuning#Tuning":"Though not supported currently, it is very likely Golem will increase the\navailability of specific high-priority agents by supporting instant-failover.Throughout this document, we've explored the crucial aspects of reliability in\ndistributed systems and how Golem addresses these challenges. We began by\nexamining the four pillars of reliability: resiliency, robustness, fault-\ntolerance, and high availability. These concepts form the foundation for\ncreating dependable systems that can withstand various failure scenarios and\nmaintain consistent performance.Golem provides a robust set of built-in reliability guarantees that\nsignificantly simplify the development of highly reliable distributed systems.\nThese include transactional execution, durable state management, reliable\ninternal communication, and resilient external communication.By automatically handling many complex reliability concerns, Golem allows\ndevelopers to focus on their core business logic rather than intricate failure\nhandling mechanisms. While Golem offers substantial reliability features, it's\nessential to understand its current limitations. These include the potential\nfor at-least-once semantics in certain external system interactions and\nlimitations in the availability of specific agents during cluster changes.\nHowever, Golem's team is actively working on addressing these areas, with\nplans for customizable retry strategies and improved agent availability on\nthe horizon.For developers leveraging Golem, a deep understanding of these reliability\nconcepts and Golem's capabilities is crucial. This knowledge allows you to make\ninformed decisions about system design, identify areas where additional\nreliability measures may be necessary, and fully utilize Golem's built-in\nfeatures to create robust distributed applications.As distributed systems continue to grow in complexity and importance, platforms\nlike Golem evolve to meet these challenges. Future releases promise to bring\neven more advanced reliability features, such as automatic idempotency key\ngeneration and instant failover for high-priority agents, further enhancing\nGolem's ability to support mission-critical applications.In conclusion, Golem provides a powerful foundation for building highly reliable\ndistributed systems. By abstracting away many of the complexities associated with\nfault-tolerance and high availability, it enables developers to create resilient\napplications that can withstand the unpredictable nature of distributed\nenvironments.As you embark on your journey with Golem, remember that reliability is not just a\nfeature, but a fundamental aspect of system design that Golem helps you achieve\nwith greater ease and confidence."}},"/concepts/worker-gateway":{"title":"Introduction","data":{"":"Golem is a durable computing platform that makes it simple to build and deploy\nhighly reliable distributed systems.Golem is highly scalable, and partitions agents across\nmany worker executor nodes, which are each in charge of running a different\nsubset of agents.Although partitioning agents across many nodes provides the benefit of\nhorizontal scalability, it makes it more difficult to know which node is\nexecuting a particular agent.Even if you know which node is executing an agent, it would not be convenient to\ninteract with the node directly, because it could fail, and you would have to\nimplement logic that detects failure and waits until the agent is recovered on\na new node before retrying the invocation.To address these issues, Golem has a Worker Gateway service, which is\neffectively stateless and scaled independently of worker executor nodes.The primary functions of the Worker Gateway are as follows:\nIdentify the node that is responsible for executing the agent being invoked,\nand route the invocation request to the node.\nTransparently handle executor node failures by detecting failure, awaiting\nrecovery, and retrying the invocation.\nSupport the execution of custom APIs, which satisfy arbitrary business and\ntechnical requirements.\nTo learn more about how the Worker Gateway supports custom APIs, read the API definitions page."}},"/debug":{"title":"Debugging agents","data":{"":"There are many scenarios where looking into an agent's state can be useful. It is possible that an agent ran into a failed state, for example. Although transient errors are automatically retried, it is possible that an agent gets permanently failed due to a programming error. It is also possible that the agent is running, but not behaving as expected.There are several tools available in Golem to help in these situations.","querying-the-agent-state#Querying the agent state":"By querying the agent state you can get some basic information about whether the agent is running, is suspended or failed, how many pending invocations it has, and what was the error message if it failed.To query the agent state using the golem command line tool, you can use the following command:\ngolem agent get <agent_id>","getting-the-agents-logs#Getting the agent's logs":"An agent can log messages in various ways:\nWriting to the standard output (stdout)\nWriting to the standard error (stderr)\nUsing logging APIs\nAll of these log sources are preserved and can be streamed live by connecting to the agent:\ngolem agent stream <agent_id>\nThere are also parameters for invocation that capture logs of the agent while an invocation is running. For more information see the CLI agent reference.","getting-an-agents-oplog#Getting an agent's oplog":"The oplog of an agent is a journal of all the operations and events happened during the agent's lifetime. It is possible to retrieve an agent's oplog, as well as to filter it with search expressions.To get the whole oplog of an agent, you can use the following command:\ngolem agent oplog <agent_id>\nSee the CLI agent reference for more information about how to search the oplog. One debugging scenario can be to look for all oplog entries belonging to a given idempotency key that was provided with an invocation that did not behave as expected. Another can be looking for occurrences of external HTTP requests or log entries.","applying-changes-to-an-agent#Applying changes to an agent":"If the available information is not enough, it often helps to add more log lines to the agent. Recompiling the agent, updating the component and then updating the faulty agent will always succeed, if the only change was adding or removing log lines.","reverting-changes-to-an-agent#Reverting changes to an agent":"The final tool available is reverting the agent. This can be done in two different ways:\nUndoing a given number of invocations. In this case we specify a number (N), and the last N invocations will be treated as if they never happened. The agent's state will be restored to the point before these last N invocations.\nReverting to a specific oplog index. A more advanced use case is to revert the agent to a specific point in the oplog. This can be used to force rerunning some side effects such as external HTTP requests or database operations.\nTo revert an agent using the golem command line interface, you can use the following command:\ngolem agent revert <agent_id> --number-of-invocations 3\nor\ngolem agent revert <agent_id> --last-oplog-index 12345"}},"/deploy":{"title":"Deployment","data":{"":"Golem Services are distributed as Docker images. They are available in Golem Services Docker Hub. Each Docker image is built for the following architectures:\nlinux/amd64\nlinux/arm64\nThe services are using the following storage backends:\nRelational Database (RDB) - PostgreSQL or SQLite (for running locally)\nRedis\nBlob storage - Shared File System or S3","golem-services#Golem Services":"The following sections provide a description of each service.","cloud-service#Cloud Service":"cloud-service is responsible for storing entities like projects and accounts in RDB.See also: configuration, environment variables, docker image","component-service#Component Service":"golem-component-service is a component registry/management service. The service is using RDB and Blob storage as data storage.See also: configuration, environment variables, docker image","debugging-service#Debugging Service":"golem-debugging-service is a special executor for running debugging sessions, controlling the execution of agents step by step.See also: configuration, environment variables, docker image","worker-service#Worker Service":"golem-worker-service provides APIs and API Gateway functionality for agents and acts as a routing service for worker executors. The service uses an RDB as data storage.See also: configuration, environment variables, docker image","worker-executor#Worker Executor":"golem-worker-executor is responsible for running the agents that belong to assigned shards. The service uses Redis and Blob storage as data storage.See also: configuration, environment variables, docker image","shard-manager#Shard Manager":"golem-shard-manager is a single node in charge of maintaining the worker executors' shard assignments; only one instance can be alive at any given time. The service uses Redis as data storage.\nSee also: configuration, environment variables, docker image","component-compilation-service#Component Compilation Service":"golem-component-compilation-service is a sidecar service responsible for compiling components. The service uses Blob storage as data storage.See also: configuration, environment variables, docker image","golem-router#Golem Router":"golem-router is an Nginx proxy for Golem APIs.See also: configuration, docker image","deployment-variants#Deployment Variants":"For deployment variants, see the following sections:"}},"/deploy/docker":{"title":"Deploy using Docker","data":{"":"To get started we recommend using the Docker Compose file from the Golem Docker examples. You will need to have Docker and Docker Compose installed on your system.Once you have Docker Compose installed, you can make use of docker-compose file in Golem repository to spin up Golem.\n# Download an example docker-compose file along with .env file that has a few common configurations\ncurl -O https://raw.githubusercontent.com/golemcloud/golem/main/docker-examples/published-postgres/compose.yaml -O  https://raw.githubusercontent.com/golemcloud/golem/main/docker-examples/published-postgres/.env\n# Start Golem with backend storage as PostgreSQL and Redis\ndocker compose -f compose.yaml up\nYou may need to modify it to suit your needs.","troubleshooting#Troubleshooting":"If you are running into any port conflicts you can modify the .env file that was downloaded as part of the above curl command.\nIt has come to our note that, in some cases, the docker compose result in the following error:\nerror getting credentials - err: exec: \"docker-credential-desktop\": executable file not found in $PATH, out: `\nIn this situation, the best possible solution is to rename credsStore to credStore in the .docker/config.json file.\nIf you still face issues, try the sqlite version of the docker-compose file:\ndocker compose -f docker-compose-sqlite.yaml up","accessing-golem-apis#Accessing Golem APIs":"Golem APIs are exposed on port 9881 by default. Worker API Gateway endpoint is exposed under port 9006."}},"/deploy/golem-cloud":{"title":"Deploy to Golem Cloud","data":{"":"Golem Cloud is hosted version of Golem. It is easiest and fastest way to run Golem agents,\nin the cloud, at scale, without any infrastructure setup or maintenance required.Golem Cloud can be managed by:\nWeb management console\ngolem-cloud-cli\nREST API"}},"/deploy/kubernetes":{"title":"Deploy to Kubernetes","data":{"":"Golem currently does not provide an official Helm chart or equivalent for Kubernetes deployments. However all the Golem services are containerized and deployed to Docker Hub, and configurable though environment variables, so it is possible to create your own Kubernetes manifests."}},"/desktop":{"title":"Golem Desktop Introduction","data":{"":"Golem Desktop provides a native application experience across Windows, Linux, and macOS. Since the application is currently unsigned, please follow the platform-specific instructions below to install it.\nPlease note that the Golem Desktop application is only supported for the open source version of Golem.","download-and-installation-instructions#Download and Installation Instructions":"Download the .exe installer from the release page\nWhen you run the installer, Windows may show a SmartScreen warning\nClick \"More info\" and then \"Run anyway\" to proceed with installation\nFollow the on-screen instructions to complete installation\nDownload the Intel x64 .dmg file from the release page\nOpen the downloaded .dmg file\nDrag the application to your Applications folder\nWhen first launching, macOS may block the app with a message \"Golem is damaged and cant be opened. You should move it to the Trash\"\nTo open the app, try one of these methods:\nMethod 1: Right-click (or Control-click) on the app icon and select \"Open\", then click \"Open\" in the dialog box\nMethod 2: If the above doesn't work, open Terminal and run the following command:\nxattr -rd com.apple.quarantine \"/Applications/Golem.app\"\nThe app should now open and subsequent launches won't require these steps\nDownload the ARM64 .dmg file from the release page\nOpen the downloaded .dmg file\nDrag the application to your Applications folder\nWhen first launching, macOS may block the app with a message \"Golem is damaged and cant be opened. You should move it to the Trash\"\nTo open the app, try one of these methods:\nMethod 1: Right-click (or Control-click) on the app icon and select \"Open\", then click \"Open\" in the dialog box\nMethod 2: If the above doesn't work, open Terminal and run the following command:\nxattr -rd com.apple.quarantine \"/Applications/Golem.app\"\nThe app should now open and subsequent launches won't require these steps\nFor older macOS versions (pre-Catalina), you may need to adjust your security settings:\nAfter downloading and attempting to open the app, go to System Preferences  Security & Privacy\nIn the General tab, you should see a message about Golem being blocked\nClick the Open Anyway button (you may need to unlock the settings with the padlock icon first)\nIf you don't see this option, try these alternative steps:\nOpen System Preferences  Security & Privacy\nClick the padlock icon to make changes\nUnder Allow apps downloaded from, select Anywhere (if available) or App Store and identified developers\nDownload the .deb file from the release page\n# Install the downloaded .deb file\nsudo dpkg -i golem-desktop_x.x.x_amd64.deb\n# If there are dependency issues, run\nsudo apt-get install -f\nDownload the .rpm file from the release page\n# Install the downloaded .rpm file\nsudo rpm -i golem-desktop-x.x.x.x86_64.rpm\n# Alternatively, using dnf\nsudo dnf install golem-desktop-x.x.x.x86_64.rpm\nDownload the Linux .AppImage from the release page\n# Make the AppImage executable\nchmod +x golem-desktop-x.x.x.AppImage\n# Run the AppImage\n./golem-desktop-x.x.x.AppImage\nThese instructions are for the unsigned version of Golem Desktop. Signed versions with proper verification will be available in future releases."}},"/develop":{"title":"Develop an application Golem","data":{"":"Developing an application on golem consists of two major steps:\nWriting one or more Golem components in one of the supported programming languages.\nDefining external HTTP endpoints\nThis page summarizes the workflow of developing an application on Golem, with links to more specific guides for each step.","creating-an-application#Creating an application":"The primary tool for developing an application on Golem is the Golem CLI.To create a new application, use the golem app new command, passing the name of the application and it's default programming language (note: it is possible to add components using different languages later).\ngolem app new my-app","writing-the-code#Writing the code":"The application is just a project directory that can contain multiple components. To learn how to add a new component and implement it, check the specific guides in this chapter.","iterations#Iterations":"During development the whole application can be built using\ngolem app build\nand every component can be deployed using\ngolem app deploy\nThis is going to create a new version of each component. If there are agents created already, those are not going to be updated automatically to these new versions. Check the agents page for more information about updating agents.","defining-apis#Defining APIs":"Most applications require a public HTTP API (but this is not mandatory - you can always use Golem's invocation API to directly communicate with your Golem application).","guidelines#Guidelines":"Check the defining custom APIs page as a starting point for learning how to define custom APIs.The recommended way to manage these custom APIs is to create a single API definition YAML in the application's root directory. Future Golem versions will integrate API definitions into the application manifest itself.","iterations-1#Iterations":"Use the golem api commands to iterate on your APIs.","incrementing-the-version#Incrementing the version":"Every time you make changes, the API's version must be incremented in the YAML file.","uploading#Uploading":"Upload the new API definition using the golem api upload command:\ngolem api definition update api.yaml\n(Use golem api definition new api.yaml the first time)","deleting-the-previous-deployment#Deleting the previous deployment":"Before deploying the new API version, the previous deployment must be deleted using the golem api deployment delete command:\ngolem api deployment delete my-definition/0.0.1","deploying#Deploying":"To try out the actual API, you also have to deploy it using the golem api deploy command:\ngolem api deployment deploy my-definition/0.0.2","breaking-the-component-apis#Breaking the component APIs":"When an API is using a component's exported interface, it is not possible to deploy a new version of that component if it is breaking that used interface (golem app deploy will fail). To resolve this, delete the deployment first as shown above."}},"/develop/additional":{"title":"Additional Runtime APIs","data":{"generate-an-idempotency-key#Generate an idempotency key":"Golem provides a function to generate an idempotency key (a UUID) which can be passed to external systems to ensure that the same request is not processed multiple times.It is guaranteed that this idempotency key will always be the same (per occurrence) even if the agent is restarted due to a crash.To generate an idempotency key:\nimport { generateIdempotencyKey, Uuid } from \"golem:api/host@1.1.7\";\nconst key: Uuid = generateIdempotencyKey();","get-agent-metadata#Get agent metadata":"It is possible to query metadata for Golem agents. This metadata is defined by the AgentMetadata interface:\n/**\n * Metadata about an agent\n */\nexport type AgentMetadata = {\n  /** The agent ID, consists of the component ID, agent type and agent parameters */\n  agentId: AgentId;\n  /** Command line arguments seen by the agent */\n  args: string[];\n  /** Environment variables seen by the agent */\n  env: [string, string][];\n  /** Configuration variables seen by the agent */\n  configVars: [string, string][];\n  /** The current agent status */\n  status: AgentStatus;\n  /** The component version the agent is running with */\n  componentVersion: bigint;\n  /** The agent's current retry count */\n  retryCount: bigint;\n};\nThere are two exported functions to query agent metadata:\ngetSelfMetadata() returns the metadata for the current agent\ngetAgentMetadata(agentId: AgentId) returns the metadata for a specific agent given by its AgentId","enumerate-agents#Enumerate agents":"Agent enumeration is a feature of Golem available both through the public HTTP API and using the SDK.\nEnumerating agents of a component is a slow operation and should not be used as part of the application logic.\nThe following example demonstrates how to use the agent enumeration API:\nimport {\n  ComponentId,\n  GetAgents,\n  AgentAnyFilter,\n  AgentMetadata,\n  AgentStatusFilter,\n} from \"golem:api/host@1.1.0\"\nconst filter: AgentAnyFilter = {\n  filters: [\n    {\n      filters: [\n        {\n          tag: \"status\",\n          val: {\n            comparator: \"equal\",\n            value: \"idle\",\n          } satisfies AgentStatusFilter,\n        },\n      ],\n    },\n  ],\n}\nconst componentId: ComponentId = {\n  /* ... */\n}\nconst agents: AgentMetadata[] = []\nconst getter = new GetAgents(componentId, filter, true)\nlet batch: AgentMetadata[] | undefined\nwhile ((batch = getter.getNext()) !== undefined) {\n  agents.push(...batch)\n}\nThe third parameter of the GetAgents constructor enables precise mode. In this mode, Golem will calculate the latest metadata for each returned agent; otherwise, it uses only the last cached values.","update-an-agent#Update an agent":"To trigger an update for a given agent from one component version to another, use the updateAgent function:\nimport { updateAgent, AgentId, ComponentVersion } from \"golem:api/host@0.2.0\"\nconst agentId: AgentId = {\n  /* ... */\n}\nconst targetVersion: ComponentVersion = 1n\nupdateAgent(agentId, targetVersion, \"automatic\")\nTo learn more about updating agents, see the Agent Update section of the agents page.","oplog-search-and-query#Oplog search and query":"The oplog interface in golem:api provides functions to search and query the agent's persisted oplog.The interface defines a big variant data type called oplog-entry, and two resources for querying an agent's oplog.\nthe get-oplog resource enumerates through all entries of the oplog\nthe search-oplog resource accepts a search expression and only returns the matching entries\nBoth resources, once constructed, provide a get-next function that returns a chunk of oplog entries. Repeatedly calling this function goes through the whole data set, and eventually returns none.","durability#Durability":"The golem:durability package contains an API that libraries can leverage to provide a custom durability implementation for their own API. This is the same interface that Golem uses under the hood to make the WASI interfaces durable. Golem applications are not supposed to use this package directly.","types#Types":"The durability API can be imported from the golem:durability/durability@1.2.1 module.The DurableFunctionType type categorizes a durable function in the following way:\nexport type DurableFunctionType =\n  {\n    tag: 'read-local'\n  } |\n  {\n    tag: 'write-local'\n  } |\n  {\n    tag: 'read-remote'\n  } |\n  {\n    tag: 'write-remote'\n  } |\n  {\n    tag: 'write-remote-batched'\n    val: OplogIndex | undefined\n  } |\n  {\n    tag: 'write-remote-transaction'\n    val: OplogIndex | undefined\n  };\nread-local indicates that the side effect reads from the agent's local state (for example local file system, random generator, etc.)\nwrite-local indicates that the side effect writes to the agent's local state (for example local file system)\nread-remote indicates that the side effect reads from external state (for example a key-value store)\nwrite-remote indicates that the side effect manipulates external state (for example an RPC call)\nwrite-remote-batched indicates that the side effect manipulates external state through multiple invoked functions (for example an HTTP request where reading the response involves multiple host function calls)\nwrite-remote-transaction indicates that the side effect manipulates external state through multiple invoked functions, and all of them are part of a single transaction (for example a database transaction)\nThe DurableExecutionState type provides information about the current execution state, and can be queried using the currentDurableExecutionState function:\n/**\n * Gets the current durable execution state\n */\nexport function currentDurableExecutionState(): DurableExecutionState;\nexport type DurableExecutionState = {\n  isLive: boolean;\n  persistenceLevel: PersistenceLevel;\n};\n/**\n * Configurable persistence level for agents\n */\nexport type PersistenceLevel = {\n    tag: 'persist-nothing'\n  } |\n  {\n    tag: 'persist-remote-side-effects'\n  } |\n  {\n    tag: 'smart'\n  };\nHere the isLive field indicates whether the executor is currently replaying an agent's previously persisted state or side effects should be executed. The persistenceLevel is a user-configurable setting that can turn off persistence for certain sections of the code.The PersistedTypedDurableFunctionInvocation is a record holding all the information about one persisted durable function. This should be used during replay to simulate the side effect instead of actually running it.\nexport type PersistedTypedDurableFunctionInvocation = {\n  timestamp: Datetime;\n  functionName: string;\n  response: ValueAndType;\n  functionType: DurableFunctionType;\n  entryVersion: OplogEntryVersion;\n};","functions#Functions":"The durability API consists of a couple of low-level functions that must be called in a correct way to make it work.The logic to be implemented is the following, in pseudocode:\nobserveFunctionCall(\"interface\", \"function\")\nstate = currentDurableExecutionState()\nif (state.isLive) {\n  result = performSideEffect(input)\n  persistTypedDurableFunctionInvocation(\"function\", encode(input), encode(result), durableFunctionType)\n} else {\n  // Execute the side effect\n  persisted = readPersistedDurableFunctionInvocation()\n  result = decode(persisted.response)\n}\nThe input and result values must be encoded into ValueAndType, the dynamic value representation from the golem:rpc package.In cases when a durable function's execution interleaves with other calls, the beginDurableFunction and endDurableFunction calls can be used to mark the beginning and end of the operation.","invocation-context#Invocation context":"Golem associates an invocation context with each invocation, which contains various information depending on how the exported function was called. This context gets inherited when making further invocations via agent-to-agent communication, and it is also possible to define custom spans and associate custom attributes to it.The spans are not automatically sent to any tracing system but they can be reconstructed from the oplog, for example using oplog processor plugins, to provide real-time tracing information.\nTo get the current invocation context, use the currentContext host function, imported from golem:api/context@1.1.7:\n/**\n * Invocation context support\n */\ndeclare module 'golem:api/context@1.1.7' {\n  /**\n   * Gets the current invocation context\n   * The function call captures the current context; if new spans are started, the returned `invocation-context` instance will not\n   * reflect that.\n   */\n  export function currentContext(): InvocationContext;\n}\nThe InvocationContext itself is a class with various methods for querying attributes of the invocation context:\nmethod\tdescription\ttraceId\tReturns the trace ID associated with the context, coming from either an external trace header or generated at the edge of Golem\tspanId\tReturns the span ID associated with the context\tparent\tReturns the parent invocation context, if any\tgetAttribute\tGets an attribute from the context by key\tgetAttributes\tGets all attributes from the context\tgetAttributeChain\tGets all values of a given attribute from the current and parent contexts\tgetAttributeChains\tGet all attributes and their previous values\ttraceContextHeaders\tGets the W3C Trace Context headers associated with the current invocation context\t\nCustom attributes can only be set on custom spans. First start a new span using startSpan\n/**\n * Starts a new `span` with the given name, as a child of the current invocation context\n */\nexport function startSpan(name: string): Span;\nand then use the Span class's methods:\nmethod\tdescription\tstartedAt\tReturns the timestamp when the span was started\tsetAttribute\tSets an attribute on the span\tsetAttributes\tSets multiple attributes on the span\tfinish\tEnds the current span\t\nIf finish is not explicitly called on the span, it is going to be finished when the garbage collector deletes the span object.\nThe custom spans are pushed onto the invocation context stack, so whenever an RPC call or HTTP call is made, their parent span(s) will include the user-defined custom spans as well as the rest of the invocation context.","the-wasi-key-value-store-interface#The WASI Key-Value store interface":"Although Golem agents can store their state completely in their own memory, it is possible to use the wasi:keyvalue interface to store key-value pairs in a Golem managed key value storage.This can be useful if state needs to be shared between different agents or if the size of this state is too large to be stored in memory. The keys are accessible for every agent of an application - no matter which component they are defined in, or which agent type they belong to.\nThere are two primary modules for using the key-value store:\nwasi:keyvalue/eventual@0.1.0 defines an API for an eventually consistent key-value store\nwasi:keyvalue/eventual-batch@0.1.0 defines an API with batch operations working on multiple keys\nThe primary interface to work with the key-value pairs consists of the four basic operations:\n/**\n* Get the value associated with the key in the bucket.\n* The value is returned as an option. If the key-value pair exists in the\n* bucket, it returns `Ok(value)`. If the key does not exist in the\n* bucket, it returns `Ok(none)`.\n* If any other error occurs, it returns an `Err(error)`.\n* @throws Error\n*/\nexport function get(bucket: Bucket, key: Key): IncomingValue | undefined;\n/**\n* Set the value associated with the key in the bucket. If the key already\n* exists in the bucket, it overwrites the value.\n* If the key does not exist in the bucket, it creates a new key-value pair.\n* If any other error occurs, it returns an `Err(error)`.\n* @throws Error\n*/\nexport function set(bucket: Bucket, key: Key, outgoingValue: OutgoingValue): void;\n/**\n* Delete the key-value pair associated with the key in the bucket.\n* If the key does not exist in the bucket, it does nothing.\n* If any other error occurs, it returns an `Err(error)`.\n* @throws Error\n*/\nexport function delete_(bucket: Bucket, key: Key): void;\n/**\n* Check if the key exists in the bucket.\n* If the key exists in the bucket, it returns `Ok(true)`. If the key does\n* not exist in the bucket, it returns `Ok(false)`.\n* If any other error occurs, it returns an `Err(error)`.\n* @throws Error\n*/\nexport function exists(bucket: Bucket, key: Key): boolean;\nThe batch API defines similar functions such as getMany and setMany, but working on multiple keys at once.The IncomingValue and OutgoingValue types are defined as follows:\nexport class OutgoingValue {\n    static newOutgoingValue(): OutgoingValue;\n    /**\n     * Writes the value to the output-stream asynchronously.\n     * If any other error occurs, it returns an `Err(error)`.\n     * @throws Error\n     */\n    outgoingValueWriteBodyAsync(): OutgoingValueBodyAsync;\n    /**\n     * Writes the value to the output-stream synchronously.\n     * If any other error occurs, it returns an `Err(error)`.\n     * @throws Error\n     */\n    outgoingValueWriteBodySync(value: OutgoingValueBodySync): void;\n}\nexport class IncomingValue {\n    /**\n     * Consumes the value synchronously and returns the value as a list of bytes.\n     * If any other error occurs, it returns an `Err(error)`.\n     * @throws Error\n     */\n    incomingValueConsumeSync(): IncomingValueSyncBody;\n    /**\n     * Consumes the value asynchronously and returns the value as an `input-stream`.\n     * If any other error occurs, it returns an `Err(error)`.\n     * @throws Error\n     */\n    incomingValueConsumeAsync(): IncomingValueAsyncBody;\n    /**\n     * The size of the value in bytes.\n     * If the size is unknown or unavailable, this function returns an `Err(error)`.\n     * @throws Error\n     */\n    incomingValueSize(): bigint;\n}\nexport type OutgoingValueBodyAsync = OutputStream;\nexport type OutgoingValueBodySync = Uint8Array;\nexport type IncomingValueAsyncBody = InputStream;\nexport type IncomingValueSyncBody = Uint8Array;\nThe streaming variants of setting and consuming the values may be used by the underlying implementation to directly\nstream the data to the key-value store. For small values, the sync variants are more convenient, directly taking and returning\na Uint8Array.","the-wasi-blob-store-interface#The WASI Blob Store interface":"The wasi:blobstore interface provides a way to store and retrieve large binary data. This can be useful for storing large files or other binary data that is too large to be stored in the agent's memory. The blobs are accessible for every agent of an application - no matter which component they are defined in, or which agent type they belong to.\nThe Blob Store API organizes blobs identified by object names into containers. The wasi:blobstore/blobstore module exports functions to create, get and delete these containers by name:\ndeclare module 'wasi:blobstore/blobstore' {\n    /**\n     * creates a new empty container\n     * @throws Error\n     */\n    export function createContainer(name: ContainerName): Container;\n    /**\n     * retrieves a container by name\n     * @throws Error\n     */\n    export function getContainer(name: ContainerName): Container;\n    /**\n     * deletes a container and all objects within it\n     * @throws Error\n     */\n    export function deleteContainer(name: ContainerName): void;\n    /**\n     * returns true if the container exists\n     * @throws Error\n     */\n    export function containerExists(name: ContainerName): boolean;\n    /**\n     * copies (duplicates) an object, to the same or a different container.\n     * returns an error if the target container does not exist.\n     * overwrites destination object if it already existed.\n     * @throws Error\n     */\n    export function copyObject(src: ObjectId, dest: ObjectId): void;\n    /**\n     * moves or renames an object, to the same or a different container\n     * returns an error if the destination container does not exist.\n     * overwrites destination object if it already existed.\n     * @throws Error\n     */\n    export function moveObject(src: ObjectId, dest: ObjectId): void;\n    // ...\n}\nA Container is a class providing read-write access for the blobs in it:\nexport class Container {\n    /**\n     * returns container name\n     * @throws Error\n     */\n    name(): string;\n    /**\n     * returns container metadata\n     * @throws Error\n     */\n    info(): ContainerMetadata;\n    /**\n     * retrieves an object or portion of an object, as a resource.\n     * Start and end offsets are inclusive.\n     * Once a data-blob resource has been created, the underlying bytes are held by the blobstore service for the lifetime\n     * of the data-blob resource, even if the object they came from is later deleted.\n     * @throws Error\n     */\n    getData(name: ObjectName, start: bigint, end: bigint): IncomingValue;\n    /**\n     * creates or replaces an object with the data blob.\n     * @throws Error\n     */\n    writeData(name: ObjectName, data: OutgoingValue): void;\n    /**\n     * returns list of objects in the container. Order is undefined.\n     * @throws Error\n     */\n    listObjects(): StreamObjectNames;\n    /**\n     * deletes object.\n     * does not return error if object did not exist.\n     * @throws Error\n     */\n    deleteObject(name: ObjectName): void;\n    /**\n     * deletes multiple objects in the container\n     * @throws Error\n     */\n    deleteObjects(names: ObjectName[]): void;\n    /**\n     * returns true if the object exists in this container\n     * @throws Error\n     */\n    hasObject(name: ObjectName): boolean;\n    /**\n     * returns metadata for the object\n     * @throws Error\n     */\n    objectInfo(name: ObjectName): ObjectMetadata;\n    /**\n     * removes all objects within the container, leaving the container empty.\n     * @throws Error\n     */\n    clear(): void;\n}\nThe IncomingValue and OutgoingValue classes are, similar to the key-value store interface, providing two ways to work with the blobs: synchronously using UInt8Arrays or using the InputStream and OutputStream interfaces for saving/loading the data by chunks."}},"/develop/agent-filesystem":{"title":"Agent Filesystem","data":{"":"Each agent runs in a sandboxed filesystem. Both the / path and the current working directory of an agent point to the root of this sandboxed filesystem.\nThere is no way for an agent to access files outside its own filesystem.","accessing-the-filesystem#Accessing the filesystem":"For TypeScript agents, a limited subset of the node:fs package is available to work with files.The available functions are:\nreadFile\nreadFileSync\nwriteFile\nwriteFileSync","initial-file-system#Initial File System":"The Initial File System (IFS) refers to all files that are present in the agent filesystem before the agent is started.\nThese can include configuration files, static assets and other things that you want to include with your agent.The IFS is configured on the level of a component, meaning that all agents created from a given component + version will always start with the\nsame filesystem. To configure the IFS, include a files section in your golem.yaml\nIf you are using profiles in your golem.yaml, you currently have to include the files section in each of your profiles when overriding.\ncomponents:\n  example:filesystem:\n    template: ts\n    files:\n    - sourcePath: ./files/foo.txt\n      targetPath: /foobar.txt\n      permissions: read-write\n    - sourcePath: ./files/bar.txt\n      targetPath: /bar.txt\n      permissions: read-only\nAfter deploying the component, any new agents created will have the file /foobar.txt (and ./foobar.txt as the agent's initial current directory is the root) available to them.\nThe file /bar.txt on the other hand is only available for reading. Trying to open the file for writing will fail with a language-dependent error.","updating-an-agent#Updating an agent":"Updating an agent that uses IFS requires some special consideration depending on the update mode you choose:\nAutomatic updates: When using automatic updates the old agent invocations are replayed on top of the new IFS. This means that the agent\nshould produce exactly the same results and side effects as it did with the old IFS. For example, changing the format of a file will work without issues, but changing\na file that gets read by the agent and returned to the user will likely lead to divergence. In such cases a manual update might be necessary.\nManual updates: When using manual updates, you are responsible for saving and restoring the content of files in the agent filesystem. You can\nuse the golem:api/save-snapshot function to persist the files and later restore / migrate them using golem:api/load-snapshot.","externally-accessing-agent-files#Externally accessing agent files":"Previous Golem versions allowed defining file-server bindings in the API mapping to expose files on the agent filesystem via a REST API.\nThis feature is not available in Golem 1.3, but will be re-introduced in the next major release in a different and improved form.\nThere is no built-in way to automatically expose files on the agent filesystem for the outside world, but it is easy to define an agent method\nand map that to a HTTP route in the API mapping.For example, we can define a get method like in the following example agent:\nimport * as fs from 'node:fs';\nimport { BaseAgent, agent } from '@golemcloud/golem-ts-sdk';\n@agent()\nclass FileServerAgent extends BaseAgent {\n  constructor(requestId: string) {\n    super();\n  }\n  get(filepath: string): { contentType: string, data: Uint8Array } {\n    try {\n      const buffer = fs.readFileSync(\"/web/\" + filepath);\n      let contentType = \"application/octet-stream\";\n      if (filepath.endsWith(\".html\")) {\n        contentType = \"text/html\";\n      } else if (filepath.endsWith(\".js\")) {\n        contentType = \"application/javascript\";\n      }\n      return {\n        contentType: contentType,\n        data: buffer\n      };\n    } catch (err) {\n      return {\n        contentType: \"text/plain\",\n        data: new TextEncoder().encode(`Not found! (${ err })`)\n      };\n    }\n  }\n}\nThen in the HTTP API mapping we can map this method to a HTTP route:\nhttpApi:\n  definitions:\n    counter-api:\n      version: '0.0.2'\n      routes:\n        - method: POST\n          path: /{name}/increment\n          binding:\n            type: default\n            componentName: \"example:counter\"\n            response: |\n                let fsa = file-server-agent(request.request_id.value);\n                let file = fsa.get(request.path.file);\n                {\n                  headers: {\n                    Content-Type: file.content-type\n                  },\n                  body: file.data\n                }\nFor more information about defining custom HTTP APIs for agents, check the dedicated documentation page.For serving static content, it is good practice to define a separate agent in an ephemeral component that is only responsible for serving files, and pass the request.request_id.value string to its constructor to make sure each request gets its own unique ephemeral instance. This way the file-serving endpoints will not ever block by waiting for a stateful agent to process their requests."}},"/develop/ai":{"title":"Using AI providers","data":{"":"Golem comes with an extensive set of libraries for connecting to various AI and AI related third party providers. These libraries are providing abstractions for various areas, and pluggable implementations for them. This way the actual third party provider can be switched any time without modifying the Golem agent's code.The currently supported areas are:\nLarge Language Models (LLM)\nGraph Databases\nSearch Engines\nWeb Search Engines\nSpeech to Text\nVideo Generation\nCode Snippet Execution\nAll these interfaces are ready to use from any Golem agent through the Golem SDK. If one or more of the above interfaces are used in an agent, then an implementation needs to be selected for each by adding them to the golem.yaml file of the component.The golem.yaml files coming from the agent templates are coming with commented-out entries for each possible choice of implementations, so just uncomment the desired ones and provide any necessary configuration (usually in form of environment variables).The rest of the page shows detailed information about these libraries, the available implementations and their basic interface (without a full documentation of every type involved).","llms#LLMs":"The list of supported LLM providers is the following:\nAmazon Bedrock\nAnthropic (Claude)\nxAI (Grok)\nOllama\nOpenAI\nOpenRouter\nThe core interface for LLMs:\ndeclare module 'golem:llm/llm@1.0.0' {\n   /**\n      * --- Core Functions ---\n      * Make a single call to the LLM.\n      * To continue the conversation:\n      * - append tool responses and new messages to the events and use send again\n      * - or use the chat-session wrapper, which help in maintaining the chat events\n      * @throws Error\n      */\n   export function send(events: Event[], config: Config): Response;\n   /**\n      * Makes a single call to the LLM and gets back a streaming API to receive the response in chunks.\n      */\n   export function stream(events: Event[], config: Config): ChatStream;\n   // ...\n}","graph-databases#Graph Databases":"The list of supported graph databases is the following:\nArangoDb\nJanusGraph\nNeo4j\nThe core interface for graph databases:\ndeclare module 'golem:graph/transactions@1.0.0' {\n  export class Transaction {\n      /**\n       * === QUERY OPERATIONS ===\n       * Execute a database-specific query string\n       * @throws GraphError\n       */\n      executeQuery(options: ExecuteQueryOptions): QueryExecutionResult;\n      /**\n       * == TRAVESAL OPERATIONS ==\n       * Find shortest path between two vertices\n       * @throws GraphError\n       */\n      findShortestPath(options: FindShortestPathOptions): Path | undefined;\n      /**\n       * Find all paths between two vertices (up to limit)\n       * @throws GraphError\n       */\n      findAllPaths(options: FindAllPathsOptions): Path[];\n      /**\n       * Get k-hop neighborhood around a vertex\n       * @throws GraphError\n       */\n      getNeighborhood(options: GetNeighborhoodOptions): Subgraph;\n      /**\n       * Check if path exists between vertices\n       * @throws GraphError\n       */\n      pathExists(options: PathExistsOptions): boolean;\n      /**\n       * Get vertices at specific distance from source\n       * @throws GraphError\n       */\n      getVerticesAtDistance(options: GetVerticesAtDistanceOptions): Vertex[];\n      /**\n       * Get adjacent vertices through specified edge types\n       * @throws GraphError\n       */\n      getAdjacentVertices(options: GetAdjacentVerticesOptions): Vertex[];\n      /**\n       * Get edges connected to a vertex\n       * @throws GraphError\n       */\n      getConnectedEdges(options: GetConnectedEdgesOptions): Edge[];\n      /**\n       * === VERTEX OPERATIONS ===\n       * Create a new vertex\n       * @throws GraphError\n       */\n      createVertex(options: CreateVertexOptions): Vertex;\n      /**\n       * Create multiple vertices in a single operation\n       * @throws GraphError\n       */\n      createVertices(vertices: CreateVertexOptions[]): Vertex[];\n      /**\n       * Get vertex by ID\n       * @throws GraphError\n       */\n      getVertex(id: ElementId): Vertex | undefined;\n      /**\n       * Update vertex properties (replaces all properties)\n       * @throws GraphError\n       */\n      updateVertex(options: UpdateVertexOptions): Vertex;\n      /**\n       * Delete vertex (and optionally its edges)\n       * @throws GraphError\n       */\n      deleteVertex(id: ElementId, deleteEdges: boolean): void;\n      /**\n       * Find vertices by type and optional filters\n       * @throws GraphError\n       */\n      findVertices(options: FindVerticesOptions): Vertex[];\n      /**\n       * === EDGE OPERATIONS ===\n       * Create a new edge\n       * @throws GraphError\n       */\n      createEdge(options: CreateEdgeOptions): Edge;\n      /**\n       * Create multiple edges in a single operation\n       * @throws GraphError\n       */\n      createEdges(edges: CreateEdgeOptions[]): Edge[];\n      /**\n       * Get edge by ID\n       * @throws GraphError\n       */\n      getEdge(id: ElementId): Edge | undefined;\n      /**\n       * Update edge properties\n       * @throws GraphError\n       */\n      updateEdge(options: UpdateEdgeOptions): Edge;\n      /**\n       * Delete edge\n       * @throws GraphError\n       */\n      deleteEdge(id: ElementId): void;\n      /**\n       * Find edges by type and optional filters\n       * @throws GraphError\n       */\n      findEdges(options: FindEdgesOptions): Edge[];\n      /**\n       * === TRANSACTION CONTROL ===\n       * Commit the transaction\n       * @throws GraphError\n       */\n      commit(): void;\n      /**\n       * Rollback the transaction\n       * @throws GraphError\n       */\n      rollback(): void;\n      /**\n       * Check if transaction is still active\n       */\n      isActive(): boolean;\n    }\n  // ...\n}","search-engines#Search Engines":"The list of supported search engines is the following:\nAlgolia\nElasticsearch\nMeiliSearch\nTypesense\nThe core interface for search engines:\ndeclare module 'golem:search/core@1.0.0' {\n  /**\n     * Index lifecycle\n     * @throws SearchError\n     */\n    export function createIndex(options: CreateIndexOptions): void;\n    /**\n     * @throws SearchError\n     */\n    export function deleteIndex(name: IndexName): void;\n    /**\n     * @throws SearchError\n     */\n    export function listIndexes(): IndexName[];\n    /**\n     * Document operations\n     * @throws SearchError\n     */\n    export function upsert(index: IndexName, doc: Doc): void;\n    /**\n     * @throws SearchError\n     */\n    export function upsertMany(index: IndexName, docs: Doc[]): void;\n    /**\n     * @throws SearchError\n     */\n    export function delete_(index: IndexName, id: DocumentId): void;\n    /**\n     * @throws SearchError\n     */\n    export function deleteMany(index: IndexName, ids: DocumentId[]): void;\n    /**\n     * @throws SearchError\n     */\n    export function get(index: IndexName, id: DocumentId): Doc | undefined;\n    /**\n     * Query\n     * @throws SearchError\n     */\n    export function search(index: IndexName, query: SearchQuery): SearchResults;\n    /**\n     * @throws SearchError\n     */\n    export function streamSearch(index: IndexName, query: SearchQuery): SearchStream;\n    /**\n     * Schema inspection\n     * @throws SearchError\n     */\n    export function getSchema(index: IndexName): Schema;\n    /**\n     * @throws SearchError\n     */\n    export function updateSchema(index: IndexName, schema: Schema): void;\n  // ...\n}","web-search-engines#Web Search Engines":"The list of supported web search engines is the following:\nBrave\nGoogle\nSerper\nTavily\nThe core interface for web search engines:\ndeclare module 'golem:web-search/web-search@1.0.0' {\n    /**\n     * Start a search session, returning a search context\n     * @throws SearchError\n     */\n    export function startSearch(params: SearchParams): SearchSession;\n    /**\n     * One-shot search that returns results immediately (limited result count)\n     * @throws SearchError\n     */\n    export function searchOnce(params: SearchParams): [SearchResult[], SearchMetadata | undefined];\n    export class SearchSession {\n      /**\n       * Get the next page of results\n       * @throws SearchError\n       */\n      nextPage(): SearchResult[];\n      /**\n       * Retrieve session metadata (after any query)\n       */\n      getMetadata(): SearchMetadata | undefined;\n    }\n  // ...\n}","speech-to-text#Speech to Text":"The list of supported speech to text providers is the following:\nAWS Transcribe\nAzure\nDeepgram\nGoogle\nOpenAI Whisper\nThe core interface for speech to text providers:\ndeclare module 'golem:stt/transcription@1.0.0' {\n    /**\n     * @throws SttError\n     */\n    export function transcribe(request: TranscriptionRequest): TranscriptionResult;\n    /**\n     * @throws SttError\n     */\n    export function transcribeMany(requests: TranscriptionRequest[]): MultiTranscriptionResult;\n  // ...\n}","video-generation#Video Generation":"The list of supported video generation providers is the following:\nKling\nRunway\nStability\nVeo\nThe core interface for video generation providers:\ndeclare module 'golem:video-generation/video-generation@1.0.0' {\n    /**\n     * @throws VideoError\n     */\n    export function generate(input: MediaInput, config: GenerationConfig): string;\n    /**\n     * @throws VideoError\n     */\n    export function poll(jobId: string): VideoResult;\n    /**\n     * @throws VideoError\n     */\n    export function cancel(jobId: string): string;\n  // ...\n}\ndeclare module 'golem:video-generation/lip-sync@1.0.0' {\n    /**\n     * @throws VideoError\n     */\n    export function generateLipSync(video: LipSyncVideo, audio: AudioSource): string;\n    /**\n     * @throws VideoError\n     */\n    export function listVoices(language: string | undefined): VoiceInfo[];\n  // ...\n}\ndeclare module 'golem:video-generation/advanced@1.0.0' {\n    /**\n     * @throws VideoError\n     */\n    export function extendVideo(options: ExtendVideoOptions): string;\n    /**\n     * @throws VideoError\n     */\n    export function upscaleVideo(input: BaseVideo): string;\n    /**\n     * @throws VideoError\n     */\n    export function generateVideoEffects(options: GenerateVideoEffectsOptions): string;\n    /**\n     * @throws VideoError\n     */\n    export function multiImageGeneration(options: MultImageGenerationOptions): string;\n  // ...\n}","code-snippet-execution#Code Snippet Execution":"The list of supported languages is the following:\nJavaScript\nPython\nThe core interface for code snippet execution:\ndeclare module 'golem:exec/executor@1.0.0' {\n    /**\n     * Blocking, non-streaming execution\n     * - `lang` specifies the programming language and version.\n     * - `modules` are additional code files to include in the execution context. these can be imported in `snippet` in a language-specific way.\n     * - `snippet` is the top level code to execute.\n     * - `options` is controlling the script runner environment, see the run-options record for more details\n     * The returned value captures the stdout and stderr of the executed snippet.\n     * @throws Error\n     */\n    export function run(lang: Language, modules: File[], snippet: string, options: RunOptions): ExecResult;\n    export class Session {\n      /**\n       * Create a new session for executing code snippets in the specified language, with a set of additional\n       * code files that can be imported in the executed snippets.\n       */\n      constructor(lang: Language, modules: File[]);\n      /**\n       * Upload a data file to the session, which can be accessed in the executed snippets through standard file system APIs.\n       * @throws Error\n       */\n      upload(file: File): void;\n      /**\n       * Execute a code snippet in the session in a blocking way\n       * - `snippet` is the top level code to execute.\n       * - `options` is controlling the script runner environment, see the run-options record for more details\n       * The returned value captures the stdout and stderr of the executed snippet.\n       * @throws Error\n       */\n      run(snippet: string, options: RunOptions): ExecResult;\n      /**\n       * Downloads a data file from the session.\n       * @throws Error\n       */\n      download(path: string): Uint8Array;\n      /**\n       * Lists all the data files available in the session. These will include the ones that were `upload`ed and also\n       * any other file created by the executed snippets.\n       * @throws Error\n       */\n      listFiles(dir: string): string[];\n      /**\n       * Sets the current working directory within the session.\n       * @throws Error\n       */\n      setWorkingDir(path: string): void;\n    }\n  // ...\n}"}},"/develop/building-components":{"title":"Building Golem Components","data":{"":"Building Golem components having an application manifest is straightforward.Use the golem command line interface to run the build:\ngolem app build\nThe result of the golem app build command is a WebAssembly component file ready to be deployed to Golem. To deploy it, use the deploy command:\ngolem app deploy"}},"/develop/durability":{"title":"Control durability guarantees","data":{"":"Golem provides a set of functions components can call to control details of the durable execution engine.","general-concepts#General concepts":"The library allows controlling four main aspects of the durable execution engine: the current persistence level, the idempotence mode, defining atomic regions and changing retry policies (discussed in the next page).All these features are regional - they can be changed for a section of the code within a single exported function.\nTo make this easy to use in TypeScript, the library provides functions starting with with, they take a closure\nparameter which will be executed with the requested mode, and then they restore the previous settings.","persistence-level#Persistence level":"The persistence level can be one of the following:\nLevel\tDescription\tPersistNothing\tTurns off persistence for a section. In case the agent is recovered or restarted, all the side-effecting functions will be reexecuted\tPersistRemoteSideEffects\tPersists all the side-effects that are affecting the outside world. In case of recovery the side-effects won't be reexecuted and the persisted results will be used.\tSmart\tThe default setting; Let Golem decide what to persist to optimize performance\t\nTo change the persistence level for a section of the code, use the withPersistenceLevel function:\nimport {withPersistenceLevel} from \"@golemcloud/golem-ts-sdk\"\nconst result: string = withPersistenceLevel({tag: \"persist-nothing\"}, () => {\n// this closure runs in PersistNothing mode\nreturn \"hello\"\n})","idempotence-mode#Idempotence mode":"Golem assumes that HTTP requests are idempotent by default. This means that in case of a failure, if the system cannot determine whether the request successfully reached the target or not, it will be retried.\nThis behavior can be changed using the withIdempotenceMode function:\nimport {withIdempotenceMode} from \"@golemcloud/golem-ts-sdk\"\nconst result: string = withIdempotenceMode(false, () => {\n// this closure runs with idempotence mode disabled\nreturn \"hello\"\n})\nWith disabled idempotence mode, in case Golem cannot determine if the request was sent or not, it won't retry it, but the agent will fail.","atomic-regions#Atomic regions":"By default, side effects are persisted and retried one by one. It is possible to group them together into atomic regions, in which case the execution is retried for some reason (the agent failed or interrupted within the region), all the side effects will be reexecuted.\nThe golem-ts-sdk library exports the atomically function for using atomic regions:\nimport {atomically} from \"@golemcloud/golem-ts-sdk\"\nconst result: [string, string] = atomically(() => {\nconst firstResult: string = firstSideEffect()\nconst secondResult: string = secondSideEffect(firstResult)\nreturn [firstResult, secondResult]\n})","commit-oplog#Commit oplog":"The oplogCommit function in \"@golemcloud/golem-ts-sdk waits until the oplog is committed to its persistent\nstorage. The function takes a single argument, replicas, with the desired number of storage replicas the\nagent's journal is replicated to. The function will block until the oplog is committed to the specified number\nof replicas, or, if this number is larger than the available number of replicas, until it is written to all the\nreplicas."}},"/develop/http":{"title":"HTTP requests","data":{"":"HTTP requests can be made with the standard fetch function.For example:\nconst response = await fetch(`http://localhost:${port}/todos`, {\n    method: \"POST\",\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n        title: \"foo\",\n        body: \"bar\",\n        userId: 1\n    })\nconst data = await response.json();\nconsole.log(\"Body: \", data);\n});"}},"/develop/forking":{"title":"Forking Agents","data":{"explanation#Explanation":"Golem agents are single threaded. To achieve parallel execution, it is possible to spawn child agents and communicate with them using RPC, as described on the Agent to Agent communication page.A simpler way is to use the fork API. The fork API consists of a single host function, defined as the following:\ndeclare module 'golem:api/host@1.1.7' {\n  // ...\n  /**\n   * Indicates which agent the code is running on after `fork`\n   */\n  export type ForkResult = \"original\" | \"forked\";\n  /**\n   * Forks the current agent at the current execution point. The new agent gets the `new-name` agent ID,\n   * and this agent continues running as well. The return value is going to be different in this agent and\n   * the forked agent.\n   */\n  export function fork(newName: string): ForkResult;\n}\nWhen called, a new agent is created using the given name, with exactly the same state as the one that called the fork function. The execution continues in both the original and the new agents, with a different fork-result result value in each.\nThis is a low-level API that requires passing the new agent ID as a string. This ID has to be a valid agent-id, consisting of the agent type (same as the agent type of the current agent) and valid constructor parameters. However, the constructor parameters must contain an element distinguishing the new agent from the original one.One simple way to do that is to use an extra parameter to the agent constructor that is not used by the agent itself, but is used to distinguish the new agent from the original one; it needs to have a clear default value (like 0, or empty string, etc.) to be able to find the root agent.Future Golem versions will provide a more user-friendly, higher level API to implement this functionality.","usage#Usage":"Using this fork function from a component that was created from Golem's built-in templates is straightforward because access to the Golem specific host functions is already set up.The following code snippet demonstrates calling fork and continuing on two different parallel branches based on its result value:\nimport { BaseAgent, agent } from '@golemcloud/golem-ts-sdk';\nimport { fork, type ForkResult } from \"golem:api/host@1.1.7\"\n@agent()\nclass ExampleAgent extends BaseAgent {\n  name: string;\n  constructor(name: string, mode: \"root\" | \"fork\") {\n    super();\n    this.name = name;\n  }\n  run() {\n    switch (fork(`example-agent(\"${this.name}\",fork)`)) {\n      case \"original\": {\n        // ...\n        break;\n      }\n      case \"forked\": {\n        // ...\n        break;\n      }\n    }\n  }\n}","join#Join":"Once the agent has been forked, the two agent instances are running simultaneously and independently. Golem promises provide a way to resynchronize the two agents.The high level idea is the following:\nThe original agent creates a Golem promise and stores the resulting PromiseId in a variable.\nThen forks the new agent. Both the new and the old agents have the promise id.\nWhen the new agent is done with the work it was forked for, it completes the promise and includes some arbitrary payload it wants to send back to the original agent.\nThe original agent, after doing some additional work in parallel to the forked one, can suspend its execution to wait for the promise to be completed. When the promise is completed, the original agent resumes execution and receives the payload sent by the forked agent.\nThe following code snippet demonstrates this pattern:\nimport { BaseAgent, agent } from '@golemcloud/golem-ts-sdk';\nimport { awaitPromise, completePromise, createPromise, PromiseId, fork, type ForkResult } from \"golem:api/host@1.1.7\"\n@agent()\nclass ExampleAgent extends BaseAgent {\n  name: string;\n  constructor(name: string, mode: \"root\" | \"fork\") {\n    super();\n    this.name = name;\n  }\n  async run() {\n    const promiseId: PromiseId = createPromise();\n    switch (fork(`example-agent(\"${this.name}\",fork)`)) {\n      case \"original\": {\n        const localResult = ...; // ... do some more work;\n        const rawForkResult: UInt8Array = await awaitPromise(promiseId);\n        const forkResult = JSON.parse(new TextDecoder().decode(rawForkResult));\n        // Merge localResult and forkResult and continue running\n        break;\n      }\n      case \"forked\": {\n        const result = ...; // do some work in parallel to the original agent\n        const rawResult: UInt8Array = new TextEncoder().encode(JSON.stringify(result));\n        completePromise(promiseId, rawResult);\n        // Stop execution\n        break;\n      }\n    }\n  }\n}\nNote that Golem Promises are NOT JavaScript Promises, and the API to create, complete and await them is currently blocking."}},"/develop/next-steps":{"title":"Next steps","data":{"":"After setting up the TypeScript development environment and learning the basic steps writing a Golem component and building them,\nconsider learning about the following topics for creating more advanced Golem agents, or proceed to the Invoke section to learn how to call these agents:","making-http-requests-from-a-golem-component#Making HTTP requests from a Golem component":"Learn how to send HTTP requests from a Golem component written in TypeScript.","control-durability-guarantees#Control durability guarantees":"Check how the TypeScript Golem SDK can control various durability settings of Golem.","automatic-retries#Automatic retries":"Learn about Golem's retry mechanism and how it can be customized.","transactions#Transactions":"Use the higher level transactions library to implement the Saga pattern.","promises#Promises":"Create and use promises to await external events from within a running agent.","call-other-agents-from-an-agent#Call other agents from an agent":"Agent to Agent communication","set-up-the-agents-filesystem#Set up the agent's filesystem":"Agent filesystem","use-llms#Use LLMs":"LLMs","use-fork-to-achieve-parallelism#Use fork to achieve parallelism":"Forking agents"}},"/develop/promises":{"title":"Working with Golem Promises","data":{"":"Golem promises provide a way for Golem agents to wait for an external condition. The agent creates the promise and somehow sends its identifier to the external system responsible for completing the promise. Then the agent can await the promise, being suspended until the external system completes the promise using Golem's REST API.It is also possible to complete a promise from within a Golem agent using the Golem SDK, which is especially useful when used together with forking.When a promise is completed, an arbitrary byte array can be attached to it as a payload; this data is returned to the awaiting agent when it continues execution.","creating-a-promise#Creating a promise":"To create a promise simply call the createPromise function:\nimport {createPromise, PromiseId} from \"@golemcloud/golem-ts-sdk\"\nconst promiseId: PromiseId = createPromise()\nThe returned value has the type PromiseId, and defined as the following (including the nested types):\nexport type OplogIndex = bigint\nexport interface Uuid {\n    highBits: bigint\n    lowBits: bigint\n}\n// Represents a Component\nexport interface ComponentId {\n    uuid: Uuid\n}\n// Represents an agent\nexport interface AgentId {\n    componentId: ComponentId\n    agentId: string\n}\n// A promise ID is a value that can be passed to an external Golem API to complete that promise\n// from an arbitrary external source, while Golem agents can await for this completion.\nexport interface PromiseId {\n    agentId: AgentId\n    oplogIdx: OplogIndex\n}","deleting-a-promise#Deleting a promise":"If a promise is no longer used, it has to be deleted with:\nimport { deletePromise, PromiseId } from \"@golemcloud/golem-ts-sdk\"\ndeletePromise(promiseId)","awaiting-a-promise#Awaiting a promise":"To await a promise, use the async awaitPromise function, which returns the promise result as a byte array payload.\nHere's an example that awaits a promise, then decodes the payload from JSON format:\nimport { awaitPromise, PromiseId } from \"@golemcloud/golem-ts-sdk\"\nconst byteArrayPayload: Uint8Array = await awaitPromise(promiseId)\nconst payload = JSON.parse(new TextDecoder().decode(byteArrayPayload))\nNote that if an agent is only awaiting Golem promises (one or more), the agent gets suspended and is not going to consume any resources while waiting.","completing-a-promise-from-within-an-agent#Completing a promise from within an agent":"To complete a promise from within an agent, use the completePromise function.\nThe following example completes a promise with a value encoded as JSON:\nimport { completePromise, PromiseId } from \"@golemcloud/golem-ts-sdk\"\nconst payload = {\n  id: \"value\",\n  meta: \"data\",\n}\nconst byteArrayPayload: Uint8Array = new TextEncoder().encode(JSON.stringify(payload))\nconst success: boolean = completePromise(promiseId, byteArrayPayload)","completing-a-promise-from-an-external-source#Completing a promise from an external source":"To see how to use the promise ID to complete a promise through the external REST API, check the REST API documentation."}},"/develop/setup":{"title":"Setup","data":{"setting-up-the-development-environment#Setting up the development environment":"Golem's TypeScript toolchain uses npm as the underlying build tool.\nInstall Node.js and npm on your system by following the official instructions."}},"/develop/retries":{"title":"Control the retry policy","data":{"using-golems-retry-mechanism#Using Golem's retry mechanism":"Golem applies a retry mechanism to all agents. In case of a failure, Golem will automatically recover the agent to the point before the failure and retry the operation. An exponential backoff and an upper limit on the number of retries are applied.If the maximum number of retries is reached, the agent will be marked as failed and no further invocations will be possible on it.This mechanism is automatic and applied to all kinds of failures. To rely on it, throw an unhandled exception.\nGolem will retry from the point the unhandled exception was thrown. It is possible that a previous operation's\nunwanted result (if it did not end in an exception) has been already persisted, in which case it won't be retried.","customizing-the-retry-policy#Customizing the retry policy":"The retry policy which controls the maximum number of retries and the exponential backoff is a global configuration of the Golem servers, but it can be customized for each agent.\nThe golem-ts-sdk library exports the withRetryPolicy function to temporarily change the retry policy:\nimport {withRetryPolicy} from \"@golemcloud/golem-ts\"\n// Durations are expected as nanoseconds\nconst result: string = withRetryPolicy(\n{\n    maxAttempts: 3,\n    minDelay: BigInt(100 * 1000 * 1000), // 100 milliseconds\n    maxDelay: BigInt(2 * 1000 * 1000 * 1000), // 2 seconds\n    multiplier: 1.5,\n    maxJitterFactor: null,\n},\n() => {\n    // this closure runs with the custom retry policy\n    return \"hello\"\n})\nThe RetryPolicy interface required by withRetryPolicy is the following:\n/**\n* Configures how the executor retries failures\n*/\nexport type RetryPolicy = {\n    maxAttempts: number;\n    minDelay: Duration;\n    maxDelay: Duration;\n    multiplier: number;\n    maxJitterFactor?: number;\n};"}},"/develop/updating":{"title":"Updating agents to newer versions of components","data":{"":"As described in the general Agents page, each agent runs on a specific version of the component it is based on, but it is possible to update an agent to a different version of the same component.","automatic-update#Automatic update":"The automatic update mode works as it is described in the general Agents page.","manual-snapshot-based-update#Manual snapshot-based update":"It is also possible to manually implement a pair of functions for saving and loading an agent's state into an arbitrary byte array. This is useful when making significant changes to the implementation of an agent, such that the automatic replay based update mechanism is no longer working. Future versions of Golem may also use the same snapshotting functions for optimizing recovery time of agents.\nIn TypeScript, all agents are inheriting the BaseAgent class. There are two methods in BaseAgent that can\nbe overridden to implement snapshot saving and loading for an agent.The following example implements these methods for the simple counter example used on the Quickstart page:\n    override async saveSnapshot(): Promise<Uint8Array> {\n        const snapshot = new Uint8Array(4);\n        const view = new DataView(snapshot.buffer);\n        view.setUint32(0, this.value);\n        return snapshot;\n    }\n    override async loadSnapshot(bytes: Uint8Array): Promise<void> {\n        let view = new DataView(bytes.buffer);\n        this.value = view.getUint32(0);\n    }"}},"/fundamentals":{"title":"Fundamentals","data":{"":"Golem is a serverless computing platform that helps you build and deploy reliable distributed systems with simple code.In this section, you will learn some key terms and architecture that will help you better understand Golem.","key-terms#Key Terms":"WASM. WebAssembly, or WASM, for short, is a specification for a portable and secure\nvirtual machine. Software compiled to WASM can execute on any platform and architecture using a WASM Runtime.\nComponents. In WebAssembly, components are the basic building block of applications, backends, and web services.\nComponents requires certain capabilities from the host platform (like input/output), and expose a typed public API.\nWorkers. In Golem, workers are running instances created from components, with their own resources, such as RAM,\nfile system, and environment variables. Workers are created from external events like requests or by other workers.\nInvocations. In Golem, the fundamental unit of work is an invocation of a function that is part of a worker's\ntyped public API. Functions may require typed parameters as input and may return typed values as output.\nHigh-Reliability. Highly reliable systems must execute critical logic uninterrupted, even through faults,\nupdates, and cloud flakiness. Golem provides transparent high-reliability, regardless of language or technology stack.\nWIT. WIT is a standard of WASM, similar to Protobuf, which allows developers to export a typed public API from\ncomponents. Through the Worker Gateway, Golem lets you build HTTP or gRPC APIs atop these typed public APIs.","golem-architecture#Golem Architecture":"Golem is architected as a series of independent and modular components, ranging from command-line tools to core systems\nresponsible for deployment and execution.\nCLI. Golem CLI is a command-line interface to Golem, which has the ability to create and manage components\nand workers, perform invocations, and even connect to live workers for diagnostics and troubleshooting.\nWorker Gateway. Worker Gateway executes requests by delegating their processing to specific functions on\nspecified workers. Worker Gateway can extract worker input from JSON, and produce JSON from worker output.\nWorker Executor. Worker Executor creates and executes the logic of many individual workers, potentially\ncreated from different components, exposing their public typed API via the Worker Gateway.\nGolem Services. Golem Services runs a variety of different HTTP endpoints that allow programmatic management\nof all the features of Golem. CLI and Console are both implemented atop Golem Services.\nShard Manager. Shard Manager handles both supervision of individual executor nodes in the Golem cluster and the\ntask of partitioning all workers across the available executor nodes in a Golem cluster.\nGolem Cloud. Golem Cloud is the fully managed version of Golem, suitable for companies looking for a true\nzero-ops approach to building highly-reliable distributed systems with simple code.\nConsole. Console is a graphical user-interface designed to help manage accounts, components, and workers on\nGolem Cloud. It provides high-level ways of performing many of the same tasks that are supported by CLI."}},"/develop/rpc":{"title":"Agent to Agent communication","data":{"":"See the Agent to Agent communication page for a general overview of how agents can invoke each other in Golem.","code-first-approach#Code-first approach":"When defining an agent in code, this automatically defines a client interface for calling remote agents as well. This way an agent of an agent type can create other agents and invoke methods on them. The target agent can be of any agent type available for the caller agent in code.The simplest way to achieve this is to keep all the agent types that need to call each other in the same component. Otherwise the agent definition need to be extracted to some shared place and imported to all components involved.","creating-a-client#Creating a client":"The first step of calling a remote agent is creating a client for it by specifying which agent type it is and identifying the agent by providing values for its constructor parameters. If the agent identified by the parameters has not been existing yet, it is going to be created and its constructor is executed remotely. If it has been already created, the client just points to it and no action is taken until an agent method is called using it.\nIn the following example, we have two agents defined; a weather agent with a constructor parameter identifying a location, and another example agent creating and calling this weather agent.\n@agent()\nclass WeatherAgent extends BaseAgent {\n    constructor(location: string) {\n        super();\n        // ...\n    }\n    @description(\"Gets the current weather\")\n    async currentWeather(): Promise<string> {\n        // ...\n    }\n}\n@agent()\nclass ExampleAgent extends BaseAgent {\n    constructor() {\n        super();\n    }\n    async run() {\n        const weatherInLondon = WeatherAgent.get(\"London\")\n        // ...\n    }\n}\nHere weatherInLondon is the client for calling a remote WeatherAgent - it exposes the agent methods, such as currentWeather as its own methods.","calling-a-remote-agent-method#Calling a remote agent method":"Once we have a client for a remote agent, it is possible to call its methods just as if it would be a local instance.\nconst currentWeather = await weatherInLondon.currentWeather();","triggering-execution-of-an-agent-method#Triggering execution of an agent method":"It is possible to trigger the remote execution of an agent method without awaiting it. This is useful for spawning background tasks, for example.\nTo trigger an agent method and return immediately, use the trigger method exposed on each remote method in the client:\nconst remoteAgent = BackgroundTaskAgent.get(backgroundJobId);\nremoteAgent.runTask.trigger(\"hello\", 1234);","scheduling-an-agent-method#Scheduling an agent method":"An advanced case of triggering the execution of an agent method is to schedule it to be executed at a later time.\nSimilar to .trigger, there is a .schedule method as well on each remote agent method in the client:\nconst remoteAgent = BackgroundTaskAgent.get(backgroundJobId);\nremoteAgent.runTask.schedule({ seconds: X, nanoseconds: Y }, \"hello\", 1234);\nHere the first parameter is a Datetime object, with seconds and nanoseconds fields representing the UNIX Epoch time when the method should be executed. The rest of the parameters are the same as for the original method."}},"/":{"title":"Golem Developer Documentation","data":{"":"Welcome to the Golem developer documentation portal! Here you will find comprehensive documentation on how to build, deploy, and manage applications on Golem.\nGolem is available in both an open source version that you can deploy yourself and a hosted\nversion that we manage for you. This documentation covers both versions, and we will discuss any\ndifferences between the two.","getting-started#Getting Started":"","quick-links#Quick Links":""}},"/invoke":{"title":"Invoke workers","data":{"":"Learn how to invoke workers using:\nThe HTTP API\nThe CLI\nThe REPL\nBy mapping to a custom API"}},"/invoke/http":{"title":"Invoke through the REST API","data":{"":"Previously Golem called agents as workers, and the new name has not been applied everywhere yet. The APIs described in this section are still using the worker name.\nThe Golem REST API exposes two endpoints for invoking agents. See the Worker REST API reference for details.\nThese endpoints provide a direct, low level API for calling the exported functions of the agents. They use a special JSON format for encoding WASM values and types. It is possible, and recommended, to create custom HTTP APIs for exposing agents to the world.","endpoints#Endpoints":"","invoke-agents#Invoke agents":"The invoke endpoint enqueues an invocation for the given agent and returns immediately.\nPOST /v1/components/{component_id}/workers/{agent_id}/invoke?function={function_name}\nThis POST request invokes the agent called agent_id of the component identified by component_id (a UUID), calling the function function_name.\nRead the name mapping page to learn how the function names are mapped.The body of the POST request must be a JSON object containing a single field called params, which is an array of typed JSON values. The format of typed JSON values is described below.","invoke-and-await-agents#Invoke and await agents":"The invoke-and-await endpoint enqueues an invocation for a given agent and then awaits its completion, returning the successful result value or failure in the response body.\nPOST /v1/components/{component_id}/workers/{agent_id}/invoke-and-await?function={function_name}\nThis POST request invokes the agent called agent_id (consisting of the agent type name and the parameter values) of the component identified by component_id (a UUID), calling the function function_name.\nRead the name mapping page to learn how the function names are mapped.The body of the POST request must be a JSON object containing a single field called params, which is an array of typed JSON values. The format of typed JSON values is described below.The response body is a JSON object with a single field result, containing the invoked function's result encoded as a typed JSON value.","implicit-agent-creation#Implicit agent creation":"If the invoked agent does not exist, it is automatically created by the invocation.","cancelling-pending-invocations#Cancelling pending invocations":"As invocations are executed sequentially, it is possible to cancel a pending invocation before it starts executing. This can be done using the cancel invocation endpoint:\nDELETE /v1/components/{component_id}/workers/{agent_id}/invocations/{idempotency_key}","typed-json-values#Typed JSON values":"Typed JSON values are JSON objects with two fields:\ntyp describes the type of the value\nvalue is the actual value\nThe invocation API does not require type information beside the values, but providing it makes the invocation much faster. Invocations without provided type information are intended to be used only for testing, as they involve gathering the missing information for each invocation separately.","value-format#Value format":"Read the Type Mapping page to see how every WebAssembly value is encoded in JSON, and how the data types defined in the Golem component's source code are mapped to these.","getting-the-type#Getting the type":"When constructing invocation requests, the easiest way to get the type part of the request body is to get the component metadata using the REST API:\nGET /v1/components/{component_id}/latest\nThis request returns the metadata of the latest version of the component given by its identifier (a UUID). This metadata lists all the exported functions and their expected parameter types. These parameter types encode type information in the same format as the invocation API, so it is possible to copy them when constructing invocations.Note that it is not recommended to do this dynamically; the client using the invocation API should target a specific component version, with parameter types known in advance."}},"/invoke/cli":{"title":"Invoke using Golem CLI","data":{"":"The golem command line interface exposes one invocation subcommand:\ngolem agent invoke triggers a function invocation on an agent and awaits its result\ngolem agent invoke --enqueue just enqueues an invocation and returns immediately","specifying-what-to-invoke#Specifying what to invoke":"The command requires specifying which agent to invoke, and the name of the function.There are multiple options for selecting the agent:\nagent-type(agent-parameters)\ncomponent-name/agent-type(agent-parameters)\nproject-name/component-name/agent-type(agent-parameters)\naccount-name/project-name/component-name/agent-type(agent-parameters)\nNote that the agent-type(agent-parameters) part is also referred as the agent ID, or in previous versions, the worker name.Also note that you can only omit the component name if it can be inferred from the context, for example if the current directory is a component directory or the application root with a single component only.The function to be invoked is selected by the second parameter. Read the page about name mapping for more information about the possible function names.","encoding-parameters#Encoding parameters":"The CLI requires you to encode the function parameters using the WebAssembly Value Encoding with one or more parameters following the function name (one for each invocation parameter).","getting-results#Getting results":"When using invoke without the --enqueue flag, the CLI awaits the result of the invocation and prints the result value to the standard output. By default it uses the text format, in which case it prints the result value using the WebAssembly Value Encoding.This can be changed with --format json or --format yaml to print the invocation result in JSON or YAML, using the mapping described on Type Mapping page.","logs#Logs":"Both invocation commands accept an optional --stream flag for connecting to the invoked agent's event stream and showing its logs. This works the same as running a separate golem agent stream command during the invocation. The logs consists of everything the agent writes to its standard output and standard error, as well as through the logging API.The --stream option's output (and also the stream subcommand) can be customized with the following parameters:\n--format text|json|yaml for different encodings of the log lines\n--colors=yes|no to enable/disable colors for the text format\n--show-timestamps=yes|no to enable/disable showing timestamps for each log line\n--show-level=yes|no to enable/disable showing the log level (or stdout/stderr) for each log line","cancelling-pending-invocations#Cancelling pending invocations":"As invocations are executed sequentially, it is possible to cancel a pending invocation before it starts executing. This can be done using the command line interface by running the agent cancel-invocation subcommand:\ngolem agent cancel-invocation <component-name>/<agent-id> --idempotency-key <idempotency-key>"}},"/invoke/making-custom-apis":{"title":"Make Custom HTTP APIs for your Golem App","data":{"":"Golem's Gateway service not only exposes the low-level REST API for invocations\nbut also provides a way to expose the agent methods as HTTP APIs.Future versions will support other protocols such as MCP, gRPC, or GraphQL.","http-api-definition#HTTP API definition":"The HTTP APIs are defined in the application manifest (golem.yaml) httpApi section. Every template provided by Golem contains a sample API definition that can be used as a starting point.The httpApi section consists of two main parts:\ndefinitions contains the versioned API definitions describing routes and their handlers\ndeployments specifies which sets of these definitions are exposed on which hosts","definitions#Definitions":"Each API definition has a name and a version; multiple versions of the same API can be deployed simultaneously if needed, for example for backward compatibility.The primary part of an API definition is the list of routes. Each route matches an incoming HTTP request and performs a specific action, most commonly invoking an agent method.The following example defines an API called counter-api with version 0.0.1:\nhttpApi:\n    definitions:\n        counter-api:\n            version: '0.0.1'\n            routes:\n            # - method: GET\n            #   ...","routes-calling-agents#Routes calling agents":"The most common type of route is one that invokes an agent method. A route consists of an HTTP method and path, with optional variables in it, and a Rib script. The script's job is invoking an agent's method by taking information from the request to assemble the agent ID and the method's parameters, and constructing an HTTP response from the method's response. This allows a lot of flexibility in mapping the agent to an HTTP API.The routes field is a list of routes, each consisting of:\nmethod: one of GET, POST, DELETE, PUT, PATCH, HEAD, CONNECT, OPTIONS, TRACE\npath: the path part of the URL, which may contain variables in {} braces\nbindings: describes how to handle the request, for example by invoking an agent method\nThe bindings field has several subfields:\ntype: default: indicates that this route invokes an agent method; other types are documented below\ncomponentName: the name of the component containing the agent to invoke\nresponse: the Rib script that handles the request\noptionally idempotencyKey: a Rib script that computes an idempotency key for the request\noptionally invocationContext: a Rib script that computes an invocation context for the request\nTo learn more about the Rib scripting language, see the Rib page.","response-script#Response script":"The response script has access to the request object, which allows access to details of the HTTP request:\nrequest.path.xyz refers to a path variable named xyz\nrequest.headers.xyz refers to a header named xyz\nrequest.body refers to the JSON request body - it can be inspected by accessing its fields such as request.body.exampleField etc.\nrequest.auth when authentication is configured (see below)\nrequest.request_id.value is a string containing a UUID that is unique for each incoming request. It can be used with ephemeral agents to provide a unique identity for each request by defining a requestId string parameter for the ephemeral agent's constructor, and passing this value from Rib.\nThe script can construct an agent reference for any of the agent types defined in the component identified by componentName by using the agent type name and providing the necessary constructor parameters. For example if there is an agent type counter-agent with a single string constructor parameter, the following Rib snippets are constructing an instance of it:\nlet agent = counter-agent(\"test\");\nor\nlet agent = counter-agent(request.path.user);\nThis agent variable then can be used to invoke an agent method, for example:\nlet new-value = agent.increment();\nThe script must return an object with at least a status and a body field:\n{ status: 200u64, body: \"Hello World\" }\nAdditionally, this response object can also have a headers field, which is a map of header names to values.For example, it is possible to modify the response content type by adding a Content-Type header:\n{ status: 200u64, body: \"Hello World\", headers: { Content-Type: \"text/plain\" } }\nThe next example reads a custom header from the requests, and uses it as another custom header that is added to the response:\nlet customer-id: string = request.headers.X-Customer-ID;\n{\n  status: 200u64,\n  body: \"The customer id header was ${customer-id}\",\n  headers: {\n    Content-Type: \"text/plain\",\n    X-Request-Customer-ID: customer-id\n  }\n}","example#Example":"The following example defines an increment endpoint for the example used on the Quickstart page:\nhttpApi:\n  definitions:\n    counter-api:\n      version: '0.0.2'\n      routes:\n        - method: POST\n          path: /{name}/increment\n          binding:\n            type: default\n            componentName: \"example:counter\"\n            response: |\n              let name: string = request.path.name;\n              let agent = counter-agent(name);\n              let new-value = agent.increment();\n              { status: 200u64, body: { result: \"incremented ${name}, new value is ${new-value}\" } }\nNote that when the content type header is not specified, the body is automatically serialized as JSON and the Content-Type: application/json header is added to the response.","non-json-request-or-response-bodies#Non-JSON request or response bodies":"Currently Rib only supports JSON request bodies. The request.body field is always a parsed JSON object, allowing access to its fields. Arbitrary payload can be only sent as part of the JSON object, for example by encoding it as a base64 string.The response body's content type can be customized by adding a Content-Type header to the response object, and it also depends on the request's Accept header, if any. Depending on the accept and content type headers, different values returned in the response object's body field have different outcomes:\nBy default, if no Accept or Content-Type header is present, the resulting content type is application/json, and the body field can be any structured value, that is going to be serialized as JSON.\nOne exception to the above rule is if the value returned as the response body is an array of bytes. In this case the content type is set to application/octet-stream and the byte array is sent as-is in the response body.\nIf there is an explicit Content-Type header, or if the Accept header in the request requires a specific content type, then the following rules apply:\nIf the content type is application/json, then the body field can be any structured value, that is going to be serialized as JSON.\nIf the content type is text/plain, then the body field must be a string, which is sent as-is in the response body.\nIf the content type is anything else, then the body field must be an array of bytes, which is sent as-is in the response body.","optional-idempotency-key-script#Optional idempotency key script":"In Golem every request is associated with an idempotency key. If there is no special idempotency key script provided, then this key is either taken from the Idempotency-Key HTTP header, if any, or otherwise a random key is generated for each request.The idempotencyKey field of a binding can define a Rib script returning a string value. The following example uses a custom header instead of the Idempotency-Key one for extracting the idempotency key:\nrequest.headers.X-Custom-Idempotency-Key","optional-invocation-context-script#Optional invocation context script":"Every invocation in Golem has access to an invocation context. This invocation context has a span ID and a set of key-value pairs associated with it. Golem adds several keys by default to the invocation context, but by providing a Rib script in the binding's invocationContext field, additional key-value pairs can be added to the invocation context of the agent method invocation based on the request.The result of this Rib script must be an object of which each field is going to be added to the invocation context.","authentication#Authentication":"Golem API gateway has built-in authentication support to identify users using OpenID protocol. See the API authentication page for details.When authentication is configured for a route, the request object in the Rib script has an additional auth field, which contains the claims from the authenticated user's ID token. For example, if the authentication provider provides an email claim, it can be accessed as request.auth.email.In the HTTP API route definitions, authentication is enabled by adding a security field to the route (next to the method, path and binding fields) referring to the preconfigured security scheme:\nhttpApi:\n  definitions:\n    counter-api:\n      version: '0.0.2'\n      routes:\n        - method: POST\n          path: /{name}/increment\n          security: my-security\n          binding:\n            type: default\n            componentName: \"example:counter\"\n            response: |\n              # ...","cors#CORS":"Setting up CORS for a route in API Gateway is done by specifying an extra route for the same path with OPTIONS method and using the cors-preflight binding type.Optionally a response field can be added to the binding, customizing the CORS headers:\nhttpApi:\n  definitions:\n    counter-api:\n      version: '0.0.2'\n      routes:\n        - method: POST\n          path: /{name}/increment\n          binding:\n            type: default\n            componentName: \"example:counter\"\n            response: |\n              # ...\n        - method: OPTIONS\n          path: /{name}/increment\n          binding:\n            type: cors-preflight\n            response: | # this field is optional\n             {\n              Access-Control-Allow-Origin: \"*\",\n              Access-Control-Allow-Methods: \"GET, POST, PUT, DELETE, OPTIONS\",\n              Access-Control-Allow-Headers: \"Content-Type, Authorization\",\n              Access-Control-Expose-Headers: \"Content-Length, X-Requested-With\",\n              Access-Control-Allow-Credentials: true,\n              Access-Control-Max-Age: 86400u64\n             }","deployments#Deployments":"A deployment simply associates a set of API definitions with a host, for example to deploy the example API definition when running the local Golem server, the following deployment can be used:\nhttpApi:\n    definitions:\n      # ...\n    deployments:\n        local:\n          - host: localhost:9006\n            definitions:\n              - counter-api","deploying-the-api#Deploying the API":"Once the API definition and deployments are added to the golem.yaml file, the API can be deployed using the following command:\ngolem api deploy\nThe interactive shell will force you to update the version of the API definition to not lose track of the changes,\nand keep a note that you can have advanced management of the APIs using the golem api definition and golem api deploy commands\nallowing you to switch back to a previous API if needed.Note that the api deploy command also deploys the underlying components if needed.","constraints#Constraints":"Once an API is deployed using a specific component-version, the agent methods used in the Rib script of the deployed API definition must be kept backward compatible. This is checked and enforced in the deploy command.If there are conflicts the api deploy command will fail with a conflict report message,\nwhich details especially the missing functions and conflicting functions, where conflicting functions\ndetail about existing parameter types, new parameter types, existing return type, and new return type.","exporting-as-openapi-specification#Exporting as OpenAPI specification":"The API definitions can also be exported as OpenAPI specifications, which can be used for generating client code or as documentation.Use the golem api definition export CLI command to export the OpenAPI specification of a specific API definition:\ngolem api definition export --id counter-api --version 0.0.1","troubleshooting#Troubleshooting":"See the troubleshooting page for some common issues and their solutions."}},"/invoke/making-custom-apis/troubleshooting":{"title":"Troubleshooting","data":{"watch-out-for-errors-during-deployment#Watch out for errors during deployment":"","route-conflict-errors-during-deployment#Route conflict errors during deployment":"Please note the following: If you already deployed an API definition before with the same path /{user-id}/get-cart-contents,\nthen you will receive a conflict error as given below.\nAPI deployment definitions conflict error: /{user-id}/get-cart-contents\nThis implies, when you update the version, you have to update the path as well, such as /v5/{user-id}/get-cart-contents\nunder the path field in route.","badrequest-errors-when-invoking-the-api-with-inputs#BadRequest errors when invoking the API with inputs":"If your API's implementation (Rib script which internally calls agents) gets a wrong input (Example: wrong types in http request),\nit produces a BadRequest. This makes Golem Gateway much more type safe than a typical Gateway\nwhere it always routes to the backend regardless of wrong inputs.Here is an example:\nlet user: u64 = request.path.user-id;\nlet agent = user-agent(user);\nagent.add-cart(request.body.product);\nHere we expect the request body to have a product field, with all the fields of the record type that add-cart function expects.\nIf the request body is wrong, we get a bad request error as shown below.\n>\n* Request completely sent off\n< HTTP/1.1 400 Bad Request\n< access-control-allow-origin: *\n< content-length: 392\n< date: Tue, 10 Dec 2024 03:42:54 GMT\n<\n* Connection #1 to host localhost left intact\nInput request details don't match the requirements for rib expression to execute: Invalid value for the key path.\nError: Invalid value for the key product. Error: Expected function parameter type is u64. But found string.\nRequirements. Record(TypeRecord { fields: [NameTypePair { name: \"product-id\", typ: U64)%"}},"/invoke/making-custom-apis/authentication":{"title":"Make Secure HTTP APIs","data":{"":"Golem API gateway has built-in authentication support to identify users using OpenID protocol.\nThis allows you to refer to the claims such as request.auth.email (as an example) once authenticated in your Rib expression.\nYou can choose to pass this information into the agent method that exist in the Rib expression, and do further logic with it.\nCurrently, this is tested with Google Identity connector.","setup-security-for-your-api-routes-in-golem#Setup Security for your API routes in Golem":"","register-an-app-with-google-identity-provider-and-get-a-client-id-and-client-secret#Register an app with Google Identity Provider and get a client-id and client-secret.":"Here is the direct link to register your app with Google Identity Provider.\nMake sure your app with a redirect URL and get the client-id and client secret.When using a locally executed Golem instance during development, the redirect URI can be http://localhost:9006/auth/callback. Otherwise it should be be https://mydomain.com/auth/callback, where mydomain.com is the domain in which you will be deploying your API definition in Golem.The /auth/callback part is just an example and it can be anything, as far as it doesn't collide with any other existing routes.We call these details \"Api Security Scheme\" in Golem API Gateway. Next step is to register this scheme in Golem.","register-api-security-scheme-with-your-apps-client-id-and-client-secret-with-golem#Register API Security Scheme with your app's client-id and client-secret with Golem":"Make sure you name your security scheme uniquely, and provide the client-id, client-secret and redirect-url as given below.\ngolem api security-scheme create \\\n  --provider-type google \\\n  --client-id REPLACE_WITH_GOOGLE_CLIENT_ID \\\n  --client-secret REPLACE_WITH_GOOGLE_CLIENT_SECRET \\\n  --redirect-url http://localhost:9006/auth/callback\n  --scope openid,email,profile \\\n  my-security\nBy now, you are having a security scheme registered with golem which you can refer in API definitions.","reference-the-security-scheme-name-in-api-definition#Reference the security scheme name in API definition":"This name (my-security in the above example) is the one to be used in the route's security field, as described in the Making Custom APIs page.","new-fields-available-on-the-rib-request-object#New fields available on the Rib request object":"Attaching a security scheme to a route adds an additional auth field to the Rib request object, which contains the claims from the authenticated user's ID token. For example, to get the authenticated user's email and use it to access an agent (with agent type example-agent) associated with this user:\nlet email: string = request.auth.email;\nlet agent = example-agent(email);","redirects-and-cookies#Redirects and Cookies":"Internally, there are a couple of redirects that's going on when you access the protected endpoint.\nThe first redirect is to the Google Identity Provider login page as explained below, and internally this is followed by identity provider hitting the redirect URL (\nwhich is exposed on your behalf by Golem API gateway) with all the details of the user.\nThis is followed by another redirect to the original URL that you tried to access, and this time the session-id, tokens/secrets set in a secure Cookie, which your\nbrowser will resend. Once the browser sends the cookie, Golem API gateway will validate the cookie and allow you to access the protected endpoint.We will be adding more support for various clients and use-cases in future releases based on the user feedback.","unexposed-callback-endpoint#Unexposed CallBack Endpoint":"Note that the callback endpoint is exposed automatically based on the re-direct url specified in the API security scheme. Users cannot customise or add\nthese call back endpoints manually. This is to avoid any security issues that may arise due to misconfiguration of the callback endpoint.","troubleshooting#Troubleshooting":"Most of the errors in this use-case are originated from a wrong security scheme configuration. For example, a wrong redirect-url\ncan result in odd errors that is difficult to spot, as this is originated from the providers and not Golem.Make sure the scope is correct and includes email. Trying to specify request.auth.email while the scope doesn't have it in the security scheme,\nwill result in errors such as email not found in the request object","known-issues#Known Issues":"Using multiple security schemes (with the names foo-security-scheme, and bar-security-scheme ) with the same redirect-url is not supported and leads to an internal error.\nSelected profile: local\nerror: API Security Scheme Service - Error: 500 Internal Server Error, InternalError: Internal repository error (unique\n     key violation)"}},"/invoke/repl":{"title":"Repl","data":{"golem-repl#Golem REPL":"Once you have a component using golem app commands,\nyou can spin up a REPL to interact with your functions.Golem REPL is backed by the language RibFor example, using the quickstart example:\ngolem repl\n>>> let a1 = counter-agent(\"agent-1\")\n()\n>>> let a2 = counter-agent(\"another\")\n()\n>>> a1.increment()\n1\n>>> a1.increment()\n2\n>>> a2.increment()\n1\nREPL is a great way to test the component and its functions,\nhowever note that it's a brand new feature and is experimental in nature."}},"/name-mapping":{"title":"Agent type and method name mapping","data":{"":"The agents defined by code are compiled to WebAssembly and there are some specific rules of how the agent methods can be referred to from outside the source code, such as from Rib scripts or the CLI.","component-name#Component name":"The component name must always be in the form of namespace:name. This is enforced when the component is created.","agent-types#Agent types":"The agent types have names idiomatic to the used programming language (for example SampleAgent in TypeScript). However, when referring to them in agent IDs, invocations, etc., we always use the name converted to kebab-case (for example sample-agent).","agent-ids#Agent IDs":"Every agent is identified by a unique ID which consists of the agent type (in kebab-case) and its constructor arguments. The constructor arguments are specified in a specific text format in these IDs.\nFor regular data types, the WAVE encoding is used, same as in Rib scripts. See the Type Mapping page for more details.\nUnstructured text parameters are either inlined between \", or a remote URL (not in quotes). The inline string can be optionally prefixed with a language code in square brackets.\nUnstructured binary parameters are either base64 encoded between \" and prefixed with a mimetype in square brackets, or a remote URL (not in quotes)\nMultimodal values are specified as a list of values, where each value is prefixed with the multimodal type name.\nSee the following examples of valid agent IDs:","singleton-agent-with-no-parameters#Singleton agent with no parameters":"agent-1()","agent-with-one-numeric-parameter#Agent with one numeric parameter":"agent-2(12)","agent-with-multiple-parameters#Agent with multiple parameters":"agent-3(12,{x: 1, y: 2, properties: {a, c}})","agent-with-two-unstructured-text-parameters#Agent with two unstructured text parameters":"agent-4(https://url1.com/,https://url2.com/) // tuple with two unstructured text params pointing to a remote URL\nagent-4(\"hello, world!\",[en]\"\\\"hello,\\\" world!\") // tuple with two unstructured inline text params, second having a language code prefix","agent-with-two-unstructured-binary-parameters#Agent with two unstructured binary parameters":"agent-5(https://url1.com/,https://url2.com/) // tuple with two unstructured binary params pointing to a remote URL\nagent-5([application/json]\"SGVsbG8gd29ybGQh\",[image/png]\"SGVsbG8gd29ybGQh\") // tuple with two unstructured inline binary params with MIME type prefixes","agent-with-multimodal-parameters#Agent with multimodal parameters":"agent-6(z([application/json]\"SGVsbG8gd29ybGQh\"),x(101)) // multimodal with two values, one named `z` which is a binary and one named `x` which is a wit value","method-names#Method names":"Agent method names are also converted to kebab-case.","method-names-in-rib-scripts#Method names in Rib scripts":"When calling methods from Rib, first we get an instance of the agent using the constructor syntax:\nlet agent1 = sample-agent(1, 2, 3);\nThen each exported agent method can be called using the dot syntax, using the kebab-cased method name:\nagent1.the-first-method();","method-calls-from-the-cli-or-the-rest-apis#Method calls from the CLI or the REST APIs":"When directly calling agent methods using golem agent invoke or the REST API, the method name must be constructed to point to the WebAssembly export. This indirection is going to be removed in the future.The rule to construct the method name is:\nnamespace:name/agent-type.{method-name}\nHere namespace:name is the component name, agent-type is the agent type name in kebab-case, and method-name is the method name in kebab-case."}},"/js-apis":{"title":"Supported JS APIs","data":{"apis#APIs":"","console#Console":"If the logging feature flag is enabled in the generated crate, it depends on wasi:logging, otherwise just on the\ncore WASI interfaces.\nassert\nclear\ncount\ncountReset\ndebug\ndir\ndirXml\nerror\ngroup\ngroupCollapsed\ngroupEnd\ninfo\nlog\ntable\ntime\ntimeEnd\ntimeLog\ntrace\nwarn","http-fetch#HTTP (fetch)":"Only if the http feature flag is enabled in the generated crate. It depends on wasi:http.\nfetch\nHeaders\nRequest\nResponse\nFormData\nBlob\nFile","url#URL":"URL\nURLSearchParams","streams#Streams":"Implemented by https://github.com/MattiasBuelens/web-streams-polyfill\nByteLengthQueuingStrategy\nCountQueuingStrategy\nReadableByteStreamController\nReadableStream\nReadableStreamBYOBReader\nReadableStreamBYOBRequest\nReadableStreamDefaultController\nReadableStreamDefaultReader\nTransformStream\nTransformStreamDefaultController\nWritableStream\nWritableStreamDefaultController","timeout-functions#Timeout functions":"setTimeout\nclearTimeout\nsetInterval\nclearInterval\nsetImmediate","encoding#Encoding":"TextEncoder\nTextDecoder\nTextDecoderStream\nTextEncoderStream","nodeutil#node:util":"format\ndeprecate\ndebugLog\ninspect\nisArray\nisBoolean\nisNull\nisNullOrUndefined\nisNumber\nisString\nisSymbol\nisUndefined\nisRegExp\nisObject\nisDate\nisError\nisFunction\nisPrimitive\nisBuffer\nlog\n_extend\npromisify\ncallbackify","nodebuffer#node:buffer":"Buffer\nINSPECT_MAX_BYTES\nkMaxLength\nkStringMaxLength\nconstants\nSlowBuffer","nodefs#node:fs":"readFile\nreadFileSync\nwriteFile\nwriteFileSync","nodeprocess#node:process":"argv\nargv0\nenv\ncwd","base64-js#base64-js":"byteLength\ntoByteArray\nfromByteArray","ieee754#ieee754":"read\nwrite","provided-by-quickjs#Provided by QuickJS":"Global:\nparseInt\nparseFloat\nisNaN\nisFinite\nquickMicrotask\ndecodeURI\ndecodeURIComponent\nencodeURI\nencodeURIComponent\nescape\nunescape\nInfinity\nNaN\nundefined\n[Symbol.toStringTag]\nObject\nstatic methods and properties:\ncreate\ngetPrototypeOf\nsetPrototypeOf\ndefineProperty\ndefineProperties\ngetOwnPropertyNames\ngetOwnPropertySymbols\ngroupBy\nkeys\nvalues\nentries\nisExtensible\npreventExtensions\ngetOwnPropertyDescriptor\ngetOwnPropertyDescriptors\nis\nassign\nseal\nfreeze\nisSealed\nisFrozen\nfromEntries\nhasOwn\nmethods and properties:\ntoString\ntoLocaleString\nvalueOf\nhasOwnProperty\nisPrototypeOf\npropertyIsEnumerable\n__proto__\n__defineGetter__\n__defineSetter__\n__lookupGetter__\n__lookupSetter__\nFunction\nmethods and properties:\ncall\napply\nbind\ntoString\n[Symbol.hasInstance]\nfileName\nlineNumber\ncolumnNumber\nError\nmethods and properties:\nname\nmessage\ntoString\nstatic methods and properties:\nisError\ncaptureStackTrace\nstackTraceLimit\nprepareStackTrace\nGenerator\nmethods and properties:\nnext\nreturn\nthrow\n[Symbol.toStringTag]\nstatic methods and properties:\nfrom\nIterator\nstatic methods and properties:\nfrom\nmethods and properties:\ndrop\nfilter\nflatMap\nmap\ntake\nevery\nfind\nforEach\nsome\nreduce\ntoArray\n[Symbol.iterator]\n[Symbol.toStringTag]\nArray\nstatic methods and properties:\nisArray\nfrom\nof\n[Symbol.species]\nmethods and properties:\nat\nwith\nconcat\nevery\nsome\nforEach\nmap\nfilter\nreduce\nreduceRight\nfill\nfind\nfindIndex\nfindLast\nfindLastIndex\nindexOf\nlastIndexOf\nincludes\njoin\ntoString\ntoLocaleString\npop\npush\nshift\nunshift\nreverse\ntoReversed\nsort\ntoSorted\nslice\nsplice\ntoSpliced\ncopyWithin\nflatMap\nflat\nvalues\n[Symbol.iterator]\nkeys\nentries\nNumber\nstatic methods and properties:\nparseInt\nparseFloat\nisNaN\nisFinite\nisInteger\nisSafeInteger\nMAX_VALUE\nMIN_VALUE\nNaN\nNEGATIVE_INFINITY\nPOSITIVE_INFINITY\nEPSILON\nMAX_SAFE_INTEGER\nMIN_SAFE_INTEGER\nmethods and properties:\ntoExponential\ntoFixed\ntoPrecision\ntoString\ntoLocaleString\nvalueOf\nBoolean\nmethods and properties:\ntoString\nvalueOf\nString\nstatic methods and properties:\nfromCharCode\nfromCodePoint\nraw\nmethods and properties:\nlength\nat\ncharCodeAt\ncharAt\nconcat\ncodePointAt\nisWellFormed\ntoWellFormed\nindexOf\nlastIndexOf\nincludes\nendsWith\nstartsWith\nmatch\nmatchAll\nsearch\nsplit\nsubstring\nsubstr\nslice\nrepeat\nreplace\nreplaceAll\npadEnd\npadStart\ntrim\ntrimEnd\ntrimRight\ntrimStart\ntrimLeft\ntoString\nvalueOf\nlocaleCompare\nnormalize\ntoLowerCase\ntoUpperCase\ntoLocaleLowerCase\ntoLocaleUpperCase\n[Symbol.iterator]\nanchor\nbig\nblink\nbold\nfixed\nfontcolor\nfontsize\nitalics\nlink\nsmall\nstrike\nsub\nsup\nSymbol\nstatic methods and properties:\nfor\nkeyFor\nmethods and properties:\ntoString\nvalueOf\ndescription\n[Symbol.toPrimitive]\n[Symbol.toStringTag]\nMap\nstatic methods and properties:\ngroupBy\n[Symbol.species]\nmethods and properties:\nset\nget\nhas\ndelete\nclear\nsize\nforEach\nvalues\nkeys\nentries\n[Symbol.iterator]\n[Symbol.toStringTag]\nSet\nstatic methods and properties:\n[Symbol.species]\nmethods and properties:\nadd\nhas\ndelete\nclear\nsize\nforEach\nisDisjointFrom\nisSubsetOf\nisSupersetOf\nintersection\ndifference\nsymmetricDifference\nunion\nvalues\nkeys\n[Symbol.iterator]\nentries\n[Symbol.toStringTag]\nWeakMap\nmethods and properties:\nset\nget\nhas\ndelete\n[Symbol.toStringTag]\nWeakSet\nmethods and properties:\nadd\nhas\ndelete\n[Symbol.toStringTag]\nGeneratorFunction\nmethods and properties:\n[Symbol.toStringTag]\nMath\nstatic methods and properties:\nmin\nmax\nabs\nfloor\nceil\nround\nsqrt\nacos\nasin\natan\natan2\ncos\nexp\nlog\npow\nsin\ntan\ntrunc\nsign\ncosh\nsinh\ntanh\nacosh\nasinh\natanh\nexpm1\nlog1p\nlog2\nlog10\ncbrt\nhypot\nrandom\nf16round\nfround\nimul\nclz32\nsumPrecise\n[Symbol.toStringTag]\nE\nLN10\nLN2\nLOG2E\nLOG10E\nPI\nSQRT1_2\nSQRT2\nReflect\nstatic methods and properties:\napply\nconstruct\ndefineProperty\ndeleteProperty\nget\ngetOwnPropertyDescriptor\ngetPrototypeOf\nhas\nisExtensible\nownKeys\npreventExtensions\nset\nsetPrototypeOf\n[Symbol.toStringTag]\nRegExp\nstatic methods and properties:\nescape\n[Symbol.species]\nmethods and properties:\nflags\nsource\nglobal\nignoreCase\nmultiline\ndotAll\nunicode\nunicodeSets\nsticky\nhasIndices\nexec\ncompile\ntest\ntoString\n[Symbol.replace]\n[Symbol.match]\n[Symbol.matchAll]\n[Symbol.search]\n[Symbol.split]\nJSON\nstatic methods and properties:\nparse\nstringify\n[Symbol.toStringTag]\nPromise\nstatic methods and properties:\nresolve\nreject\nall\nallSettled\nany\ntry\nrace\nwithResolvers\n[Symbol.species]\nmethods and properties:\nthen\ncatch\nfinally\n[Symbol.toStringTag]\nAsyncFunction\nmethods and properties:\n[Symbol.toStringTag]\nAsyncIterator\nmethods and properties:\nnext\nreturn\nthrow\nAsyncGeneratorFunction\nmethods and properties:\n[Symbol.toStringTag]\nAsyncGenerator\nmethods and properties:\nnext\nreturn\nthrow\n[Symbol.toStringTag]\nDate\nstatic methods and properties:\nnow\nparse\nUTC\nmethods and properties:\nvalueOf\ntoString\n[Symbol.toPrimitive]\ntoUTCString\ntoGMTString\ntoISOString\ntoDateString\ntoTimeString\ntoLocaleString\ntoLocaleDateString\ntoLocaleTimeString\ngetTimezoneOffset\ngetTime\ngetYear\ngetFullYear\ngetUTCFullYear\ngetMonth\ngetUTCMonth\ngetDate\ngetUTCDate\ngetHours\ngetUTCHours\ngetMinutes\ngetUTCMinutes\ngetSeconds\ngetUTCSeconds\ngetMilliseconds\ngetUTCMilliseconds\ngetDay\ngetUTCDay\nsetTime\nsetMilliseconds\nsetUTCMilliseconds\nsetSeconds\nsetUTCSeconds\nsetMinutes\nsetUTCMinutes\nsetHours\nsetUTCHours\nsetDate\nsetUTCDate\nsetMonth\nsetUTCMonth\nsetYear\nsetFullYear\nsetUTCFullYear\ntoJSON\nBigInt\nstatic methods and properties:\nasIntN\nasUintN\nmethods and properties:\ntoString\nvalueOf\n[Symbol.toStringTag]\nArrayBuffer\nstatic methods and properties:\nisView\n[Symbol.species\nmethods and properties:\nbyteLength\nmaxByteLength\nresizeable\ndetached\nresize\nslice\ntransfer\ntransferToFixedLength\n[Symbol.toStringTag]\nSharedArrayBuffer\nstatic methods and properties:\n[Symbol.species]\nmethods and properties:\nbyteLength\nmaxByteLength\ngrowable\ngrow\nslice\n[Symbol.toStringTag]\nTyped arrays (Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, BigInt64Array,\nBigUint64Array, Float32Array, Float64Array, Float16Array)\nstatic methods and properties:\nfrom\nof\n[Symbol.species]\nmethods and properties:\nlength\nat\nwith\nbuffer\nbyteLength\nset\nbyteOffset\nvalues\n[Symbol.iterator]\nkeys\nentries\n[Symbol.toStringTag]\ncopyWithin\nevery\nsome\nforEach\nmap\nfilter\nreduce\nreduceRight\nfill\nfind\nfindIndex\nfindLast\nfindLastIndex\nreverse\ntoReversed\nslice\nsubarray\nsort\ntoSorted\njoin\ntoLocaleString\nindexOf\nlastIndexOf\nincludes\nDataView\nmethods and properties:\nbuffer\nbyteLength\nbyteOffset\ngetInt8\ngetUint8\ngetInt16\ngetUint16\ngetInt32\ngetUint32\ngetBigInt64\ngetBigUint64\ngetFloat16\ngetFloat32\ngetFloat64\nsetInt8\nsetUint8\nsetInt16\nsetUint16\nsetInt32\nsetUint32\nsetBigInt64\nsetBigUint64\nsetFloat16\nsetFloat32\nsetFloat64\n[Symbol.toStringTag]\nAtomics\nstatic methods and properties:\nadd\nand\nor\nsub\nxor\nexchange\ncompareExchange\nload\nstore\nisLockFree\npause\nwait\nnotify\n[Symbol.toStringTag]\nPerformance\nmethods and properties:\nnow\nWeakRef\nmethods and properties:\nderef\n[Symbol.toStringTag]\nFinalizationRegistry\nmethods and properties:\nregister\nunregister\n[Symbol.toStringTag]\nCallsite\nmethods and properties:\n-isNative\ngetFileName\ngetFunction\ngetFunctionName\ngetColumnNumber\ngetLineNumber\n[Symbol.toStringTag]\nProxy"}},"/operate/invocation_context":{"title":"Invocation Context","data":{"":"Golem associates an invocation context with each agent invocation. This invocation context consists of a stack of spans, each having a collection of attributes. Currently only string attributes are supported.The invocation context can be queried and manipulated (by adding custom spans with custom attributes) using the SDK.By default, the invocation context's spans are not used by Golem for anything; they are just information propagated among agents to be used by either the agents or oplog processor plugins installed to them. It is possible to reconstruct all information about invocation context from the oplog, so oplog processor plugins can be used, for example, to provide live traces of agents through OpenTelemetry.","automatic-invocation-context-spans#Automatic invocation context spans":"","incoming-http-requests#Incoming HTTP requests":"The root spans of an invocation contain information depending on how that invocation was started. When invoking through the invocation REST API, W3C Trace Context headers are automatically processed to set the root trace-id and parent span-id.When using custom APIs, the same headers are also taken into account by default, but it is also possible to write a custom Rib script per endpoint to extract more information from the HTTP requests and define custom span attributes with them.In both cases, when the invocation's trigger is an HTTP request, a span is added with the following attributes:\nrequest.method\nrequest.uri\nrequest.remote_addr","invocations#Invocations":"When an invocation reaches an agent, a new span is created containing the following attributes:\nname: span's name (invoke-exported-function)\nidempotency_key: unique identifier of the invocation\nfunction_name: the fully qualified function name\nworker_id: worker's ID (consists of component ID and agent ID)\nagent_type: the agent type of this agent\nagent_parameters: constructor parameter values of the agent","outgoing-http-requests#Outgoing HTTP requests":"Outgoing HTTP requests are also represented by their own automatic spans with the following attributes:\nname: span's name (outgoing-http-request)\nrequest.method: the outgoing request's HTTP method\nrequest.uri: the outgoing request's URI","rpc-calls#RPC calls":"RPC calls on the caller side are also represented by custom spans. First, a span is created when the underlying RPC resource is initialized, with the following attributes:\nname: span's name (rpc-connection)\ntarget_worker_id: the target worker's ID\nWithin this span, a new span is created for each remote invocation, with the following attributes:\nname: span's name (rpc-invocation)\nfunction_name: the invoked function's fully qualified name\nidempotency_key: the unique identifier of the invocation"}},"/operate/logs":{"title":"Logs","data":{"golem-server-logs#Golem server logs":"Every Golem service emits structured logs with with configurable format and level. The default configuration for our dockerized builds is to log to the container's standard output using JSON format. Each service supports the same set of configuration keys controlling the logging behavior, which can be overwritten using environment variables.The default log level and filtering can be configured using the RUST_LOG environment variable, as described in the tracing-subscriber crate's documentation. The simplest way to use this environment variable is to set a global log level, for example RUST_LOG=debug.The Golem specific config keys are the following:\n[tracing]\nconsole = false\ndtor_friendly = false\nfile_name = \"worker-executor.log\"\nfile_truncate = true\n[tracing.file]\nansi = false\ncompact = false\nenabled = false\njson = true\njson_flatten = true\njson_flatten_span = true\npretty = false\nspan_events_active = false\nspan_events_full = false\nwithout_time = false\n[tracing.stdout]\nansi = true\ncompact = false\nenabled = true\njson = false\njson_flatten = true\njson_flatten_span = true\npretty = false\nspan_events_active = false\nspan_events_full = false\nwithout_time = false","overwriting-config#Overwriting config":"To overwrite any of the above config keys using environment variables, use the GOLEM_ prefix and the __ separator for levels. For example to disable logging to the standard output, and instead enable logging to a file, set the following two variables:\nGOLEM_TRACING__FILE__ENABLED=true\nGOLEM_TRACING__STDOUT__ENABLED=false","configurable-options#Configurable options":"The top-level tracing block allows setting the file name and truncate behavior for file logging, as well as enabling connection to tokio-console.For both file and stdout logging, a set of boolean flags control the format of the emitted log lines:\nFlag\tDescription\tansi\tUse ANSI colors for the output\tcompact\tUse the compact formatter.\tenabled\tEnables logging to file or stdout\tjson\tUse JSON logging\tjson_flatten\tFlatten event metadata\tjson_flatten_span\tFlatten nested span fields\tpretty\tUse the pretty formatter\tspan_events_active\tEmit one event per enter/exit of a span\tspan_events_full\tEmit one event at all points (new, enter, exit, drop)\twithout_time\tDo not emit timestamps for the log entries","golem-agent-logs#Golem agent logs":"In TypeScript agents, use the standard functions of console to log messages. console.log writes to the agent's standard output,\nwhile console.debug, console.info, etc. are writing log entries with the specific log level.","getting-agent-logs#Getting agent logs":"Agent logs (both stdout/err and WASI logging entries) are persisted for each agent, and they can be watched in live by using the connect API. There are three ways to connect to an agent:\nUsing golem\nUsing the connect WebSocket API\nUsing the Golem Console (Golem Cloud only)\nTo connect to a agent's log with golem, use either the golem agent stream command or the --stream flag when making an invocation. See the CLI documentation for more details."}},"/operate/metrics":{"title":"Metrics","data":{"overview#Overview":"Every Golem service exposes Prometheus metrics on its HTTP interface. The metrics are available at the /metrics endpoint for scraping.Beside the service-specific metrics each service exports a single counter called version_info in which the labels hold service-specific information.\nThe currently available labels are:\nLabel\tDescription\tversion\tThe version of the service","service-specific-metrics#Service-specific metrics":"","component-service#Component Service":"Component service exposes the following Prometheus metrics:\nMetric\tType\tLabels\tDescription\tpoem_request_count\tcounter\thttp.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message\tCounts every request on the HTTP interface\tpoem_errors_count\tcounter\thttp.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message\tCounts failed requests on the HTTP interface\tpoem_request_duration_ms\thistogram\thttp.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message\tMeasures the duration of handling requests on the HTTP interface\tapi_success_seconds\thistogram\tapi, api_type\tMeasures the duration of successfully serving API requests (both HTTP and gRPC)\tapi_failure_seconds\thistogram\tapi, api_type\tMeasures the duration of failed API requests (both HTTP and gRPC)\tgrpc_api_active_streams\tgauge\t\tNumber of open incoming gRPC streams\thttp_api_active_streams\tgauge\t\tNumber of open incoming HTTP streams","component-compilation-service#Component Compilation Service":"Component compilation service exposes the following Prometheus metrics:\nMetric\tType\tLabels\tDescription\tcache_size\tgauge\tcache\tCurrent maximal capacity of the cache\tcache_hit_total\tcounter\tcache\tNumber of cache hits\tcache_miss_total\tcounter\tcache\tNumber of cache misses\tcache_eviction_total\tcounter\tcache, trigger\tNumber of cache evictions\tcomponent_compilation_queue_length\tgauge\t\tNumber of compilation requests enqueued\tcompilation_time_seconds\thistogram\t\tTime to compile a WASM compnent to native code","shard-manager#Shard Manager":"Shard manager exposes the following Prometheus metrics:\nMetric\tType\tLabels\tDescription\tapi_success_seconds\thistogram\tapi, api_type\tMeasures the duration of successfully serving API requests (both HTTP and gRPC)\tapi_failure_seconds\thistogram\tapi, api_type\tMeasures the duration of failed API requests (both HTTP and gRPC)\tgrpc_api_active_streams\tgauge\t\tNumber of open incoming gRPC streams\thttp_api_active_streams\tgauge\t\tNumber of open incoming HTTP streams\texternal_call_success_seconds\thistogram\ttarget, op\tDureation of successful outgoing calls\texternal_call_response_size_bytes\thistogram\ttarget, op\tSize of the response of outgoing calls\texternal_call_retry_total\tcounter\ttarget, op\tNumber of failed outgoing calls that got retried\texternal_call_failure_total\tcounter\ttarget, op\tNumber of failed outgoing calls not to be retried\tredis_success_seconds\thistogram\tsvc, api, cmd\tDuration of successful Redis calls\tredis_failure_total\tcounter\tsvc, api, cmd\tNumber of failed Redis calls\tredis_serialized_size_bytes\thistogram\tsvc, entity\tSize of serialized Redis entities\tredis_deserialized_size_bytes\thistogram\tsvc, entity\tSize of deserialized Redis entities","worker-executor#Worker Executor":"Worker executors expose the following Prometheus metrics:\nMetric\tType\tLabels\tDescription\tapi_success_seconds\thistogram\tapi, api_type\tMeasures the duration of successfully serving API requests (both HTTP and gRPC)\tapi_failure_seconds\thistogram\tapi, api_type\tMeasures the duration of failed API requests (both HTTP and gRPC)\tgrpc_api_active_streams\tgauge\t\tNumber of open incoming gRPC streams\thttp_api_active_streams\tgauge\t\tNumber of open incoming HTTP streams\texternal_call_success_seconds\thistogram\ttarget, op\tDureation of successful outgoing calls\texternal_call_response_size_bytes\thistogram\ttarget, op\tSize of the response of outgoing calls\texternal_call_retry_total\tcounter\ttarget, op\tNumber of failed outgoing calls that got retried\texternal_call_failure_total\tcounter\ttarget, op\tNumber of failed outgoing calls not to be retried\tredis_success_seconds\thistogram\tsvc, api, cmd\tDuration of successful Redis calls\tredis_failure_total\tcounter\tsvc, api, cmd\tNumber of failed Redis calls\tredis_serialized_size_bytes\thistogram\tsvc, entity\tSize of serialized Redis entities\tredis_deserialized_size_bytes\thistogram\tsvc, entity\tSize of deserialized Redis entities\tcache_size\tgauge\tcache\tCurrent maximal capacity of the cache\tcache_hit_total\tcounter\tcache\tNumber of cache hits\tcache_miss_total\tcounter\tcache\tNumber of cache misses\tcache_eviction_total\tcounter\tcache, trigger\tNumber of cache evictions\tcompilation_time_seconds\thistogram\t\tTime to compile a WASM compnent to native code\tevent_total\tcounter\tevent\tNumber of events produced by workers\tevent_broadcast_total\tcounter\tevent\tNumber of events broadcasted by the executor\tworker_executor_call_total\tcounter\tapi\tNumber of calls to the worker layer\tpromises_count_total\tcounter\t\tNumber of promises created\tpromises_scheduled_complete_total\tcounter\t\tNumber of scheduled promise completions\tassigned_shard_count\tgauge\t\tNumber of assigned shards\tcreate_worker_seconds\thistogram\t\tTime to create a new worker\tcreate_worker_failure_total\tcounter\terror\tNumber of failed worker creations\tinvocation_total\tcounter\tmode, outcome\tNumber of invocations\tinvocation_consumption_total\thistogram\t\tAmount of fuel consumed by an invocation\tallocated_memory_bytes\thistogram\t\tAmount of memory allocated by a single memory.grow instruction\thost_function_call_total\tcounter\tinterface, name\tNumber of calls to specific host functions\tresume_worker_seconds\thistogram\t\tTime taken to resume a worker\treplayed_functions_count\thistogram\t\tNumber of functions replayed per forker resumption\toplog_svc_call_total\tcounter\tapi\tNumber of calls to the oplog layer","worker-service#Worker Service":"Worker service exposes the following Prometheus metrics:\nMetric\tType\tLabels\tDescription\tpoem_request_count\tcounter\thttp.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message\tCounts every request on the HTTP interface\tpoem_errors_count\tcounter\thttp.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message\tCounts failed requests on the HTTP interface\tpoem_request_duration_ms\thistogram\thttp.request.method, url.full, [http.path_pattern], http.response.status_code, exception.message\tMeasures the duration of handling requests on the HTTP interface\tapi_success_seconds\thistogram\tapi, api_type\tMeasures the duration of successfully serving API requests (both HTTP and gRPC)\tapi_failure_seconds\thistogram\tapi, api_type\tMeasures the duration of failed API requests (both HTTP and gRPC)\tgrpc_api_active_streams\tgauge\t\tNumber of open incoming gRPC streams\thttp_api_active_streams\tgauge\t\tNumber of open incoming HTTP streams\texternal_call_success_seconds\thistogram\ttarget, op\tDureation of successful outgoing calls\texternal_call_response_size_bytes\thistogram\ttarget, op\tSize of the response of outgoing calls\texternal_call_retry_total\tcounter\ttarget, op\tNumber of failed outgoing calls that got retried\texternal_call_failure_total\tcounter\ttarget, op\tNumber of failed outgoing calls not to be retried\tcache_size\tgauge\tcache\tCurrent maximal capacity of the cache\tcache_hit_total\tcounter\tcache\tNumber of cache hits\tcache_miss_total\tcounter\tcache\tNumber of cache misses\tcache_eviction_total\tcounter\tcache, trigger\tNumber of cache evictions"}},"/operate/persistence":{"title":"Persistence","data":{"introduction#Introduction":"The Golem Worker Executor uses a set of storage layers for persisting worker state and everything related to the execution of workers. This page gives an overview of what is stored where, as well as some pointers for extending Golem OSS with new storage implementations.","storage-types#Storage types":"The worker executor requires three types of storage backends:\nA blob storage for storing and retrieving arbitrary sized binary blobs\nA key-value storge with some extra requirements for set/sorted-set-like operations\nAn indexed storage for an append-only, indexable store for agent's operation log (oplog)\nCurrently Golem provides the following implementations, configurable through the worker executor's config file:\nStorage type\tImplementations\tBlob storage\tS3, file system, in-memory\tKey-values storage\tRedis, in-memory\tIndexed storage\tRedis (streams), in-memory","compilation-cache#Compilation cache":"The Golem component service stores the component WASM files in its own storage layer (configured to be either S3 or a persistent volume) and exposes them through its download API for the worker executor. The WASM files need to be compiled to native code before execution, which is a time-consuming task. To reduce the time required for instantiating agents, these compiled binaries are cached in the worker executor's blob storage.The component compilation service is a special, horizontally scalable component of the Golem system which shares this storage with worker executors and is capable of precompiling components before they are being used by any of the executors.","oplog#Oplog":"Running agents continuously persist operations into the worker's oplog. The oplog is append-only (persisted entries are never modified) and it is indexable (during the recovery of an agent it is read from the earliest entry to the latest one).\nThe oplog is stored in multiple configurable layers. The default configuration is the following:\nThe primary oplog layer uses the indexed storage. This is the one where running agent's entries are appended to\nThere is a secondary layer that is also persisted to the indexed storage, but on this level each entry holds a compressed set of oplog entries.\nA tertiary layer holds even larger chunks of compressed oplog entries and stores them in the blob storage.\nOplogs are continuously moved towards the lower layers to prevent the primary oplog storage (Redis) from getting full. Agents which were not active for a while are fully stored in the blob storage only.In addition to the above, there are oplog entries holding user-defined data (such as invocation parameters). As these user-defined payloads can have an arbitrary size, the worker executor has to protect its storage layer against putting too large entries into the primary oplog. For this reason large payloads are written to the blob storage and the corresponding oplog entry only stores a reference to them. Payloads below a configurable limit are stored inline in the oplog entry.","configuration#Configuration":"The [oplog] section of the worker executor configuration allows customizing the above described behavior.The default configuration is the following:\n[oplog]\narchive_interval = \"1day\"\nblob_storage_layers = 1\nentry_count_limit = 1024\nindexed_storage_layers = 2\nmax_operations_before_commit = 128\nmax_payload_size = 65536\nThese options have the following meaning:\nOption\tDescription\tarchive_interval\tThe period after the old sections of the oplog get moved to one layer down in the layered oplog storage\tblob_storage_layers\tThe number of archive layers using the blob storage\tindexed_storage_layers\tThe total number of layers (one primary + archives) using the indexed storage\tentry_count_limit\tThe number of oplog entries triggering the archivation of a chunk to the lower oplog layer\tmax_operations_before_commit\tThe number of non-critical oplog entries that can be buffered before committed to the oplog\tmax_payload_size\tThe maximum size of user-defined payloads that can be stored inline in an oplog entry","worker-metadata#Worker metadata":"The oplog is the primary source of truth for everything we need to store about an agent, but for performance reasons the key value store is also used to store aggregated agent metadata for agents. This metadata is not always completely up-to-date; it store the last oplog index it was calculated from, and its latest version can be reproduced by reading and processing the newer oplog entries. For agents which has no longer data in the primary oplog, we don't store agent metadata either. When these agents have to be recovered, their metadata is reconstructed by reading the whole archived oplog.","promises-and-schedules#Promises and schedules":"The worker executor also stores promise information in its key-value storage. This is simply an entry for each created Golem promise, storing it's completion state. Internally Golem also uses scheduled promise completion (for example for waking up agents after long sleeps). These scheduled events are also stored in the key-value storage.","wasi-blob-store-and-key-value-store#WASI Blob store and Key Value store":"Golem implements (partially) the WASI Blob Store and WASI Key-Value Store proposals. These interfaces allow agents to store blobs and key-value data in the worker executor's configured blob storage and key-value storage layers.","adding-new-storage-implementations#Adding new storage implementations":"The open-source version of Golem can be easily extended to support alternative databases than the built-in Redis and S3 implementations. Take a look at the following traits:\nBlobStorage\nKeyValueStorage\nIndexedStorage"}},"/quickstart":{"title":"Quickstart","data":{"":"This guide will get you up and running in Golem in minutes.","install-golem-cli#Install Golem CLI":"Golem CLI is a command-line application that allows you to deploy components,\ncreate and invoke agents, and otherwise manage your Golem applications.There are precompiled binaries of golem (and its other variants) for\nvarious platforms. Alternatively, you can build Golem CLI for yourself.","precompiled-binaries#Precompiled binaries":"There are precompiled binaries of two variants of the CLI here:\ngolem is the full version of the command line interface, including a locally runnable version of Golem itself.\ngolem-cli is a lightweight version of the command line interface, requiring a running Golem cluster\nYou can download the full version of golem from the following page:","undefined#Full version, including a locally executable Golem server":"Platform\tLink\tMac ARM64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-aarch64-apple-darwin\tMac x86_64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-x86_64-apple-darwin\tLinux ARM64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-aarch64-unknown-linux-gnu\tLinux x86_64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-x86_64-unknown-linux-gnu\t\nWindows is not supported for the current version, and expected to be added in Golem 1.3.1.","undefined#Lightweight client version, to work with an existing Golem cluster":"Platform\tLink\tMac ARM64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-cli-aarch64-apple-darwin\tMac x86_64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-cli-x86_64-apple-darwin\tLinux ARM64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-cli-aarch64-unknown-linux-gnu\tLinux x86_64\thttps://github.com/golemcloud/golem/releases/download/v1.3.1/golem-cli-x86_64-unknown-linux-gnu\t\nWindows is not supported for the current version, and expected to be added in Golem 1.3.1.\nIn this documentation we will use the golem command in the snippets. The available commands (except the one for starting the local Golem cluster) are the same in both variants.","running-golem#Running Golem":"It is possible to test Golem locally without installing anything other than the golem executable described above. To use it, start the local Golem cluster by running the following command:\ngolem server run\nTo use the open source version of Golem in production, you will need to deploy it to your own infrastructure. See the deployment page for available deployment options.It is also possible to use our hosted version of Golem, available at [https://console.golem.cloud].","building-an-example#Building an Example":"Golem runs components that are WebAssembly programs implementing agents. Every component defines one or more agent types, and Golem runs stateful, durable instances of these agent types that we call agents.The golem command line interface provides a set of commands to create, build, and deploy components.To get started, you create an application and a single component using one of the supported programming languages with the golem app new command. If no additional parameters are provided, the command will interactively ask for all required information.\nCreate a TypeScript agent using the default template:\ngolem app new\n> Application name: agent-examples\n> Select language for the new component TypeScript\n> Select a template for the new component: default: The default agent template for TypeScript\n> Component Package Name: example:counter\n> Add another component or create application? Create application\nNote: For TypeScript, you need to have npm installed on your system.\nThis will generate a new component in a new directory named after the provided application name, and it is ready to be compiled and deployed to Golem.To build the newly created component, use the following command:\ngolem app build\nThis compiles the newly created application, which consists of a single Golem component at the moment. An application can have multiple components, each implementing a different set of agent types. New components can be added to the application by using the golem component new command.","write-the-code#Write the code":"The default template's source code is located in the components-ts/example-counter/src/main.ts file, assuming that the example:counter name has been used in the app new command. The directory structure allows applications to have multiple components, even implemented in multiple programming languages if needed.Let's use the following code snippet for this example:\nimport {\n    BaseAgent,\n    agent,\n    prompt,\n    description,\n} from '@golemcloud/golem-ts-sdk';\n@agent()\nclass CounterAgent extends BaseAgent {\n    private readonly name: string;\n    private value: number = 0;\n    constructor(name: string) {\n        super()\n        this.name = name;\n    }\n    @prompt(\"Increase the count by one\")\n    @description(\"Increases the count by one and returns the new value\")\n    async increment(): Promise<number> {\n        this.value += 1;\n        return this.value;\n    }\n}\nIn this simple example we define a very simple agent that is identified by a name string, and exposes a single agent method increment that increments the count by one and returns the new value.\nThis is a simple example of an agent that does not communicate with other agents or external services, but has state.","uploading-your-component#Uploading Your Component":"To upload your component to Golem, you can use the app deploy command.\ngolem app deploy\nWhen you add a component you will see some basic information about the component such as its name, unique identifier, version, and size. In addition, you will see a list of exports. These are the exported agent types of the component.Uploading a component to Golem does not actually execute the component. Instead, it only makes it available for execution in Golem.Every separate running instance of your component is referred to as an agent, based on one of the agent types implemented by that component.","create-agents#Create Agents":"In Golem, every agent has a unique ID that has a specific format: it consists of the agent type followed by the values passed to the agent's constructor.There are individual CLI commands to create agents and invoke agent methods, where this agent name is used to identify the agent.For testing purposes, it is much easier to use the Golem REPL to create agents and interact with them.First start the REPL using:\ngolem repl\nThe REPL uses a special scripting language called Rib. We can create some counter agents and interact with them using the following commands:\n>>> let a1 = counter-agent(\"agent-1\")\n()\n>>> let a2 = counter-agent(\"another\")\n()\n>>> a1.increment()\n1\n>>> a1.increment()\n2\n>>> a2.increment()\n1\nNote that the REPL provides autocompletion on Tab.Check the Invoke section to learn more about other ways to invoke agents.","expose-an-http-api#Expose an HTTP API":"Agents can be invoked from other agents, through the REPL or CLI, or Golem's Invocation API, but Golem Applications can also define HTTP APIs that map routes to agents and agent methods.To finish the Quickstart example with an HTTP POST endpoint for tracking counts, let's open the golem.yaml file in the component's directory. It's going to contain a components and a dependencies section already.To define the HTTP API, we add its definition and information about how to expose it:\nhttpApi:\n  definitions:\n    counter-api:\n      version: '0.0.1'\n      routes:\n        - method: POST\n          path: /{name}/increment\n          binding:\n            type: default\n            componentName: \"example:counter\"\n            response: |\n              let name: string = request.path.name;\n              let agent = counter-agent(name);\n              let new-value = agent.increment();\n              { status: 200, body: { result: \"incremented ${name}, new value is ${new-value}\" } }\n  deployments:\n    local:\n    - host: localhost:9006\n      definitions:\n       - counter-api\nThen use the golem CLI to deploy this API:\ngolem api deploy\nAfter this command, the API is deployed to our locally running Golem instance and can be tried out by sending POST requests to http://localhost:9006/{name}/increment:\ncurl -X POST http://localhost:9006/agent-1/increment","notes-about-the-golem-13-release#Notes about the Golem 1.3 release":"Read the following important notes about the Golem 1.3 release, especially if you have used previous Golem versions:","changes-in-naming#Changes in naming":"Previously Golem called agents as workers, and the new name has not been applied everywhere yet. The APIs described in this section are still using the worker name.","grouping-multiple-agent-types#Grouping multiple agent types":"In Golem 1.3, a component can define multiple agent types, and it is recommended to put all agent types that are calling each other into the same component. This is a change from previous versions, where one component was implementing one specific worker interface.Currently the agent-to-agent RPC is only possible if the caller have access to the called agent type's source.It is still possible to have multiple components in an application. There are some component-level settings that may motivate this, such as per-component environment variables and configuration, or the component type (durable or ephemeral). Another possible reason for grouping agent types into separate components can be to apply different update policies to them.","durability-while-testing-locally#Durability while testing locally":"Golem provides durable execution by default, which can be inconvenient when iterating on a code and testing things locally. To start from a fresh state when trying out new changes, one possibility is to restart the local Golem server with golem server run --clean. This deletes all data. A more fine grained options is to pass --reset to CLI options such as golem agent invoke. This will delete existing agents and APIs but only for the invoked component.","supported-typescript-types#Supported TypeScript types":"The Golem TypeScript SDK supports a subset of TypeScript types when defining agent constructors and methods. See the type mapping page for details. If something is not supported, it is going to be a compile time error. Please report such issues to our issue tracker.","supported-js-apis#Supported JS APIs":"Only a subset of browser and Node APIs are supported in Golem agents currently. See the full list for details. This limits the external libraries that can be used in Golem agents. Please report any important missing APIs to our issue tracker.","rpc-cycles#RPC cycles":"When calling agents from other agents, the default mode is that the invoked method's result is awaited in the callee. As every agent is single threaded and invocations cannot overlap, it is possible to create a deadlock if agents are invoking each other in a cycle. This can be fixed by not awaiting the invocation, but instead just trigger the invocation (or schedule for later). See the agent-to-agent communication page for details.","ai-libraries#AI libraries":"Golem 1.3 comes with a suite of libraries for building AI agents. See the AI libraries page for details. When importing one of these libraries in the agent's code, don't forget to also specify the implementation in the golem.yaml file, as described on the AI libraries page. The agent templates are coming with commented out sections in the application manifest (golem.yaml) for all the supported libraries.","next-steps#Next Steps":"In this guide, you have learned how to build and deploy invincible serverless agents on Golem, and seen how you can interact with them as they execute.Take your next steps with Golem by exploring the following resources:\nRead about the fundamentals of Golem\nLearn about the main concepts\nRead everything developing Golem applications\nCheck out how to deploy Golem to your infrastructure\nRead the details of how to invoke workers\nLearn more about the Golem CLI\nExplore operational aspects such as how worker state is persisted, what metrics and logs are available\nCheck the References section for detailed information on APIs and syntaxes"}},"/rest-api":{"title":"REST API","data":{}},"/rest-api/account":{"title":"Account API","data":{"":"The account API allows users to query and manipulate their own account data.","find-accounts#Find accounts":"Path\tMethod\tProtected\t/v1/accounts\tGET\tYes\t\nFind matching accounts. Only your own account or accounts you have at least one grant from will be returnedQuery Parameters\nName\tType\tRequired\tDescription\temail\tstring\tNo\t-\t\nExample Response JSON\n{\n  \"values\": [\n    {\n      \"id\": \"string\",\n      \"name\": \"string\",\n      \"email\": \"string\",\n      \"planId\": \"b3f60ba2-c1fd-4b3a-a23d-8e876e0ef75d\"\n    }\n  ]\n}","create-account#Create account":"Path\tMethod\tProtected\t/v1/accounts\tPOST\tYes\t\nCreate a new account. The response is the created account data.Example Request JSON\n{\n  \"name\": \"string\",\n  \"email\": \"string\"\n}\nExample Response JSON\n{\n  \"id\": \"string\",\n  \"name\": \"string\",\n  \"email\": \"string\",\n  \"planId\": \"b3f60ba2-c1fd-4b3a-a23d-8e876e0ef75d\"\n}","get-account#Get account":"Path\tMethod\tProtected\t/v1/accounts/{account_id}\tGET\tYes\t\nRetrieve an account for a given Account IDExample Response JSON\n{\n  \"id\": \"string\",\n  \"name\": \"string\",\n  \"email\": \"string\",\n  \"planId\": \"b3f60ba2-c1fd-4b3a-a23d-8e876e0ef75d\"\n}","update-account#Update account":"Path\tMethod\tProtected\t/v1/accounts/{account_id}\tPUT\tYes\t\nAllows the user to change the account details such as name and email.Changing the planId is not allowed and the request will be rejected.\nThe response is the updated account data.Example Request JSON\n{\n  \"name\": \"string\",\n  \"email\": \"string\"\n}\nExample Response JSON\n{\n  \"id\": \"string\",\n  \"name\": \"string\",\n  \"email\": \"string\",\n  \"planId\": \"b3f60ba2-c1fd-4b3a-a23d-8e876e0ef75d\"\n}","delete-account#Delete account":"Path\tMethod\tProtected\t/v1/accounts/{account_id}\tDELETE\tYes\t\nDelete an account.Example Response JSON\n{}","get-accounts-plan#Get account's plan":"Path\tMethod\tProtected\t/v1/accounts/{account_id}/plan\tGET\tYes\t\nExample Response JSON\n{\n  \"planId\": \"b3f60ba2-c1fd-4b3a-a23d-8e876e0ef75d\",\n  \"planData\": {\n    \"projectLimit\": 0,\n    \"componentLimit\": 0,\n    \"workerLimit\": 0,\n    \"storageLimit\": 0,\n    \"monthlyGasLimit\": 0,\n    \"monthlyUploadLimit\": 0\n  }\n}","account-api-errors#Account API Errors":"Status Code\tDescription\tBody\t400\tInvalid request, returning with a list of issues detected in the request\t{\"errors\":[\"string\"]}\t401\tUnauthorized request\t{\"error\":\"string\"}\t403\tForbidden Request\t{\"error\":\"string\"}\t404\tEntity not found\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\tInternal server error\t{\"error\":\"string\"}"}},"/rest-api/agent-types":{"title":"Agent Types API","data":{"":"API working on registered agent types","undefined#undefined":"Path\tMethod\tProtected\t/v1/agent-types\tGET\tYes\t\nQuery Parameters\nName\tType\tRequired\tDescription\tproject-id\tstring\tNo\t-\t\nExample Response JSON\n[\n  {\n    \"agentType\": {\n      \"typeName\": \"string\",\n      \"description\": \"string\",\n      \"constructor\": {\n        \"name\": \"string\",\n        \"description\": \"string\",\n        \"promptHint\": \"string\",\n        \"inputSchema\": {\n          \"type\": \"Multimodal\",\n          \"elements\": [\n            {\n              \"name\": \"string\",\n              \"schema\": {\n                \"type\": \"ComponentModel\",\n                \"elementType\": {\n                  \"type\": \"Variant\",\n                  \"name\": \"string\",\n                  \"owner\": \"string\",\n                  \"cases\": [\n                    {\n                      \"name\": \"string\",\n                      \"typ\": {}\n                    }\n                  ]\n                }\n              }\n            }\n          ]\n        }\n      },\n      \"methods\": [\n        {\n          \"name\": \"string\",\n          \"description\": \"string\",\n          \"promptHint\": \"string\",\n          \"inputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          },\n          \"outputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        }\n      ],\n      \"dependencies\": [\n        {\n          \"typeName\": \"string\",\n          \"description\": \"string\",\n          \"constructor\": {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          },\n          \"methods\": [\n            {\n              \"name\": \"string\",\n              \"description\": \"string\",\n              \"promptHint\": \"string\",\n              \"inputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              },\n              \"outputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              }\n            }\n          ]\n        }\n      ]\n    },\n    \"implementedBy\": \"4477f3c1-21c0-4963-9ef3-4e200af3a9ba\"\n  }\n]","undefined-1#undefined":"Path\tMethod\tProtected\t/v1/agent-types/{agent-type}\tGET\tYes\t\nQuery Parameters\nName\tType\tRequired\tDescription\tproject-id\tstring\tNo\t-\t\nExample Response JSON\n{\n  \"agentType\": {\n    \"typeName\": \"string\",\n    \"description\": \"string\",\n    \"constructor\": {\n      \"name\": \"string\",\n      \"description\": \"string\",\n      \"promptHint\": \"string\",\n      \"inputSchema\": {\n        \"type\": \"Multimodal\",\n        \"elements\": [\n          {\n            \"name\": \"string\",\n            \"schema\": {\n              \"type\": \"ComponentModel\",\n              \"elementType\": {\n                \"type\": \"Variant\",\n                \"name\": \"string\",\n                \"owner\": \"string\",\n                \"cases\": [\n                  {\n                    \"name\": \"string\",\n                    \"typ\": {}\n                  }\n                ]\n              }\n            }\n          }\n        ]\n      }\n    },\n    \"methods\": [\n      {\n        \"name\": \"string\",\n        \"description\": \"string\",\n        \"promptHint\": \"string\",\n        \"inputSchema\": {\n          \"type\": \"Multimodal\",\n          \"elements\": [\n            {\n              \"name\": \"string\",\n              \"schema\": {\n                \"type\": \"ComponentModel\",\n                \"elementType\": {\n                  \"type\": \"Variant\",\n                  \"name\": \"string\",\n                  \"owner\": \"string\",\n                  \"cases\": [\n                    {\n                      \"name\": \"string\",\n                      \"typ\": {}\n                    }\n                  ]\n                }\n              }\n            }\n          ]\n        },\n        \"outputSchema\": {\n          \"type\": \"Multimodal\",\n          \"elements\": [\n            {\n              \"name\": \"string\",\n              \"schema\": {\n                \"type\": \"ComponentModel\",\n                \"elementType\": {\n                  \"type\": \"Variant\",\n                  \"name\": \"string\",\n                  \"owner\": \"string\",\n                  \"cases\": [\n                    {\n                      \"name\": \"string\",\n                      \"typ\": {}\n                    }\n                  ]\n                }\n              }\n            }\n          ]\n        }\n      }\n    ],\n    \"dependencies\": [\n      {\n        \"typeName\": \"string\",\n        \"description\": \"string\",\n        \"constructor\": {\n          \"name\": \"string\",\n          \"description\": \"string\",\n          \"promptHint\": \"string\",\n          \"inputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        },\n        \"methods\": [\n          {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            },\n            \"outputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"implementedBy\": \"4477f3c1-21c0-4963-9ef3-4e200af3a9ba\"\n}","agent-types-api-errors#Agent Types API Errors":"Status Code\tDescription\tBody\t400\tInvalid request, returning with a list of issues detected in the request\t{\"errors\":[\"string\"]}\t401\tUnauthorized\t{\"error\":\"string\"}\t403\tMaximum number of components exceeded\t{\"error\":\"string\"}\t404\tComponent not found\t{\"error\":\"string\"}\t409\tComponent already exists\t{\"error\":\"string\"}\t500\tInternal server error\t{\"error\":\"string\"}"}},"/rest-api/api-certificate":{"title":"Api Certificate API","data":{"gets-one-or-all-certificates-for-a-given-project#Gets one or all certificates for a given project":"Path\tMethod\tProtected\t/v1/api/certificates\tGET\tYes\t\nIf certificate-id is not set, it returns all certificates associated with the project.\nIf certificate-id is set, it returns a single certificate if it exists.Query Parameters\nName\tType\tRequired\tDescription\tproject-id\tstring\tYes\t-\tcertificate-id\tstring\tNo\t-\t\nExample Response JSON\n[\n  {\n    \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n    \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n    \"domainName\": \"string\",\n    \"createdAt\": \"2019-08-24T14:15:22Z\"\n  }\n]","creates-a-new-certificate#Creates a new certificate":"Path\tMethod\tProtected\t/v1/api/certificates\tPOST\tYes\t\nA certificate is associated with a given Golem project and domain, and consists of\na key pair.The created certificate will be associated with a certificate ID returned by this endpoint.Example Request JSON\n{\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"domainName\": \"string\",\n  \"certificateBody\": \"string\",\n  \"certificatePrivateKey\": \"string\"\n}\nExample Response JSON\n{\n  \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"domainName\": \"string\",\n  \"createdAt\": \"2019-08-24T14:15:22Z\"\n}","deletes-a-certificate#Deletes a certificate":"Path\tMethod\tProtected\t/v1/api/certificates\tDELETE\tYes\t\nDeletes the certificate associated with the given certificate ID and project ID.Query Parameters\nName\tType\tRequired\tDescription\tproject-id\tstring\tYes\t-\tcertificate-id\tstring\tYes\t-\t\nExample Response JSON\n\"string\"","api-certificate-api-errors#Api Certificate API Errors":"Status Code\tDescription\tBody\t400\t\t{\"errors\":[\"string\"]}\t401\t\t{\"error\":\"string\"}\t403\t\t{\"error\":\"string\"}\t404\t\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\t\t{\"error\":\"string\",\"workerError\":{\"cause\":\"string\",\"stderr\":\"string\"}}"}},"/rest-api/api-definition":{"title":"Api Definition API","data":{"upload-an-openapi-definition#Upload an OpenAPI definition":"Path\tMethod\tProtected\t/v1/api/definitions/{project_id}/import\tPUT\tYes\t\nUploads an OpenAPI JSON document and either creates a new one or updates an existing Golem\nAPI definition using it.Example Response JSON\n{\n  \"id\": \"string\",\n  \"version\": \"string\",\n  \"routes\": [\n    {\n      \"method\": \"Get\",\n      \"path\": \"string\",\n      \"security\": \"string\",\n      \"binding\": {\n        \"component\": {\n          \"name\": \"string\",\n          \"version\": 0\n        },\n        \"workerName\": \"string\",\n        \"idempotencyKey\": \"string\",\n        \"invocationContext\": \"string\",\n        \"response\": \"string\",\n        \"bindingType\": \"default\",\n        \"responseMappingInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"workerNameInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"idempotencyKeyInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"corsPreflight\": {\n          \"allowOrigin\": \"string\",\n          \"allowMethods\": \"string\",\n          \"allowHeaders\": \"string\",\n          \"exposeHeaders\": \"string\",\n          \"allowCredentials\": true,\n          \"maxAge\": 0\n        },\n        \"responseMappingOutput\": {\n          \"analysedType\": {\n            \"type\": \"Variant\",\n            \"name\": \"string\",\n            \"owner\": \"string\",\n            \"cases\": [\n              {\n                \"name\": \"string\",\n                \"typ\": {}\n              }\n            ]\n          }\n        }\n      }\n    }\n  ],\n  \"draft\": true,\n  \"createdAt\": \"2019-08-24T14:15:22Z\"\n}","list-api-definitions#List API definitions":"Path\tMethod\tProtected\t/v1/api/definitions/{project_id}\tGET\tYes\t\nLists all API definitions associated with the project.Query Parameters\nName\tType\tRequired\tDescription\tapi-definition-id\tstring\tNo\t-\t\nExample Response JSON\n[\n  {\n    \"id\": \"string\",\n    \"version\": \"string\",\n    \"routes\": [\n      {\n        \"method\": \"Get\",\n        \"path\": \"string\",\n        \"security\": \"string\",\n        \"binding\": {\n          \"component\": {\n            \"name\": \"string\",\n            \"version\": 0\n          },\n          \"workerName\": \"string\",\n          \"idempotencyKey\": \"string\",\n          \"invocationContext\": \"string\",\n          \"response\": \"string\",\n          \"bindingType\": \"default\",\n          \"responseMappingInput\": {\n            \"types\": {\n              \"property1\": {\n                \"type\": \"Variant\",\n                \"name\": \"string\",\n                \"owner\": \"string\",\n                \"cases\": [\n                  {\n                    \"name\": \"string\",\n                    \"typ\": {}\n                  }\n                ]\n              },\n              \"property2\": {\n                \"type\": \"Variant\",\n                \"name\": \"string\",\n                \"owner\": \"string\",\n                \"cases\": [\n                  {\n                    \"name\": \"string\",\n                    \"typ\": {}\n                  }\n                ]\n              }\n            }\n          },\n          \"workerNameInput\": {\n            \"types\": {\n              \"property1\": {\n                \"type\": \"Variant\",\n                \"name\": \"string\",\n                \"owner\": \"string\",\n                \"cases\": [\n                  {\n                    \"name\": \"string\",\n                    \"typ\": {}\n                  }\n                ]\n              },\n              \"property2\": {\n                \"type\": \"Variant\",\n                \"name\": \"string\",\n                \"owner\": \"string\",\n                \"cases\": [\n                  {\n                    \"name\": \"string\",\n                    \"typ\": {}\n                  }\n                ]\n              }\n            }\n          },\n          \"idempotencyKeyInput\": {\n            \"types\": {\n              \"property1\": {\n                \"type\": \"Variant\",\n                \"name\": \"string\",\n                \"owner\": \"string\",\n                \"cases\": [\n                  {\n                    \"name\": \"string\",\n                    \"typ\": {}\n                  }\n                ]\n              },\n              \"property2\": {\n                \"type\": \"Variant\",\n                \"name\": \"string\",\n                \"owner\": \"string\",\n                \"cases\": [\n                  {\n                    \"name\": \"string\",\n                    \"typ\": {}\n                  }\n                ]\n              }\n            }\n          },\n          \"corsPreflight\": {\n            \"allowOrigin\": \"string\",\n            \"allowMethods\": \"string\",\n            \"allowHeaders\": \"string\",\n            \"exposeHeaders\": \"string\",\n            \"allowCredentials\": true,\n            \"maxAge\": 0\n          },\n          \"responseMappingOutput\": {\n            \"analysedType\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        }\n      }\n    ],\n    \"draft\": true,\n    \"createdAt\": \"2019-08-24T14:15:22Z\"\n  }\n]","create-a-new-api-definition#Create a new API definition":"Path\tMethod\tProtected\t/v1/api/definitions/{project_id}\tPOST\tYes\t\nCreates a new API definition described by Golem's API definition JSON document.\nIf an API definition of the same version already exists, its an error.Example Response JSON\n{\n  \"id\": \"string\",\n  \"version\": \"string\",\n  \"routes\": [\n    {\n      \"method\": \"Get\",\n      \"path\": \"string\",\n      \"security\": \"string\",\n      \"binding\": {\n        \"component\": {\n          \"name\": \"string\",\n          \"version\": 0\n        },\n        \"workerName\": \"string\",\n        \"idempotencyKey\": \"string\",\n        \"invocationContext\": \"string\",\n        \"response\": \"string\",\n        \"bindingType\": \"default\",\n        \"responseMappingInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"workerNameInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"idempotencyKeyInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"corsPreflight\": {\n          \"allowOrigin\": \"string\",\n          \"allowMethods\": \"string\",\n          \"allowHeaders\": \"string\",\n          \"exposeHeaders\": \"string\",\n          \"allowCredentials\": true,\n          \"maxAge\": 0\n        },\n        \"responseMappingOutput\": {\n          \"analysedType\": {\n            \"type\": \"Variant\",\n            \"name\": \"string\",\n            \"owner\": \"string\",\n            \"cases\": [\n              {\n                \"name\": \"string\",\n                \"typ\": {}\n              }\n            ]\n          }\n        }\n      }\n    }\n  ],\n  \"draft\": true,\n  \"createdAt\": \"2019-08-24T14:15:22Z\"\n}","get-an-api-definition#Get an API definition":"Path\tMethod\tProtected\t/v1/api/definitions/{project_id}/{id}/{version}\tGET\tYes\t\nAn API definition is selected by its API definition ID and version.Example Response JSON\n{\n  \"id\": \"string\",\n  \"version\": \"string\",\n  \"routes\": [\n    {\n      \"method\": \"Get\",\n      \"path\": \"string\",\n      \"security\": \"string\",\n      \"binding\": {\n        \"component\": {\n          \"name\": \"string\",\n          \"version\": 0\n        },\n        \"workerName\": \"string\",\n        \"idempotencyKey\": \"string\",\n        \"invocationContext\": \"string\",\n        \"response\": \"string\",\n        \"bindingType\": \"default\",\n        \"responseMappingInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"workerNameInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"idempotencyKeyInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"corsPreflight\": {\n          \"allowOrigin\": \"string\",\n          \"allowMethods\": \"string\",\n          \"allowHeaders\": \"string\",\n          \"exposeHeaders\": \"string\",\n          \"allowCredentials\": true,\n          \"maxAge\": 0\n        },\n        \"responseMappingOutput\": {\n          \"analysedType\": {\n            \"type\": \"Variant\",\n            \"name\": \"string\",\n            \"owner\": \"string\",\n            \"cases\": [\n              {\n                \"name\": \"string\",\n                \"typ\": {}\n              }\n            ]\n          }\n        }\n      }\n    }\n  ],\n  \"draft\": true,\n  \"createdAt\": \"2019-08-24T14:15:22Z\"\n}","update-an-existing-api-definition#Update an existing API definition.":"Path\tMethod\tProtected\t/v1/api/definitions/{project_id}/{id}/{version}\tPUT\tYes\t\nOnly draft API definitions can be updated.Example Response JSON\n{\n  \"id\": \"string\",\n  \"version\": \"string\",\n  \"routes\": [\n    {\n      \"method\": \"Get\",\n      \"path\": \"string\",\n      \"security\": \"string\",\n      \"binding\": {\n        \"component\": {\n          \"name\": \"string\",\n          \"version\": 0\n        },\n        \"workerName\": \"string\",\n        \"idempotencyKey\": \"string\",\n        \"invocationContext\": \"string\",\n        \"response\": \"string\",\n        \"bindingType\": \"default\",\n        \"responseMappingInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"workerNameInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"idempotencyKeyInput\": {\n          \"types\": {\n            \"property1\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            },\n            \"property2\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        },\n        \"corsPreflight\": {\n          \"allowOrigin\": \"string\",\n          \"allowMethods\": \"string\",\n          \"allowHeaders\": \"string\",\n          \"exposeHeaders\": \"string\",\n          \"allowCredentials\": true,\n          \"maxAge\": 0\n        },\n        \"responseMappingOutput\": {\n          \"analysedType\": {\n            \"type\": \"Variant\",\n            \"name\": \"string\",\n            \"owner\": \"string\",\n            \"cases\": [\n              {\n                \"name\": \"string\",\n                \"typ\": {}\n              }\n            ]\n          }\n        }\n      }\n    }\n  ],\n  \"draft\": true,\n  \"createdAt\": \"2019-08-24T14:15:22Z\"\n}","delete-an-api-definition#Delete an API definition":"Path\tMethod\tProtected\t/v1/api/definitions/{project_id}/{id}/{version}\tDELETE\tYes\t\nDeletes an API definition by its API definition ID and version.Example Response JSON\n\"string\"","export-an-api-definition-in-openapi-format#Export an API definition in OpenAPI format":"Path\tMethod\tProtected\t/v1/api/definitions/{project_id}/{id}/{version}/export\tGET\tYes\t\nExports an API definition by its API definition ID and version in OpenAPI format.Example Response JSON\n{\n  \"id\": \"string\",\n  \"version\": \"string\",\n  \"openapi_yaml\": \"string\"\n}","api-definition-api-errors#Api Definition API Errors":"Status Code\tDescription\tBody\t400\t\t{\"errors\":[\"string\"]}\t401\t\t{\"error\":\"string\"}\t403\t\t{\"error\":\"string\"}\t404\t\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\t\t{\"error\":\"string\",\"workerError\":{\"cause\":\"string\",\"stderr\":\"string\"}}"}},"/rest-api/api-domain":{"title":"Api Domain API","data":{"get-all-api-domains#Get all API domains":"Path\tMethod\tProtected\t/v1/api/domains\tGET\tYes\t\nReturns a list of API domains for the given project.Query Parameters\nName\tType\tRequired\tDescription\tproject-id\tstring\tYes\t-\t\nExample Response JSON\n[\n  {\n    \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n    \"domainName\": \"string\",\n    \"nameServers\": [\n      \"string\"\n    ],\n    \"createdAt\": \"2019-08-24T14:15:22Z\"\n  }\n]","create-or-update-an-api-domain#Create or update an API domain":"Path\tMethod\tProtected\t/v1/api/domains\tPUT\tYes\t\nExample Request JSON\n{\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"domainName\": \"string\"\n}\nExample Response JSON\n{\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"domainName\": \"string\",\n  \"nameServers\": [\n    \"string\"\n  ],\n  \"createdAt\": \"2019-08-24T14:15:22Z\"\n}","delete-an-api-domain#Delete an API domain":"Path\tMethod\tProtected\t/v1/api/domains\tDELETE\tYes\t\nQuery Parameters\nName\tType\tRequired\tDescription\tproject-id\tstring\tYes\t-\tdomain\tstring\tYes\t-\t\nExample Response JSON\n\"string\"","api-domain-api-errors#Api Domain API Errors":"Status Code\tDescription\tBody\t400\t\t{\"errors\":[\"string\"]}\t401\t\t{\"error\":\"string\"}\t403\t\t{\"error\":\"string\"}\t404\t\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\t\t{\"error\":\"string\",\"workerError\":{\"cause\":\"string\",\"stderr\":\"string\"}}"}},"/rest-api/api-security":{"title":"API Security API","data":{"get-a-security-scheme#Get a security scheme":"Path\tMethod\tProtected\t/v1/api/security/{project_id}/{security_scheme_identifier}\tGET\tYes\t\nGet a security scheme by nameExample Response JSON\n{\n  \"providerType\": \"Google\",\n  \"schemeIdentifier\": \"string\",\n  \"clientId\": \"string\",\n  \"clientSecret\": \"string\",\n  \"redirectUrl\": \"string\",\n  \"scopes\": [\n    \"string\"\n  ]\n}","create-a-security-scheme#Create a security scheme":"Path\tMethod\tProtected\t/v1/api/security/{project_id}\tPOST\tYes\t\nExample Request JSON\n{\n  \"providerType\": \"Google\",\n  \"schemeIdentifier\": \"string\",\n  \"clientId\": \"string\",\n  \"clientSecret\": \"string\",\n  \"redirectUrl\": \"string\",\n  \"scopes\": [\n    \"string\"\n  ]\n}\nExample Response JSON\n{\n  \"providerType\": \"Google\",\n  \"schemeIdentifier\": \"string\",\n  \"clientId\": \"string\",\n  \"clientSecret\": \"string\",\n  \"redirectUrl\": \"string\",\n  \"scopes\": [\n    \"string\"\n  ]\n}","api-security-api-errors#API Security API Errors":"Status Code\tDescription\tBody\t400\t\t{\"errors\":[\"string\"]}\t401\t\t{\"error\":\"string\"}\t403\t\t{\"error\":\"string\"}\t404\t\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\t\t{\"error\":\"string\",\"workerError\":{\"cause\":\"string\",\"stderr\":\"string\"}}"}},"/rest-api/api-deployment":{"title":"Api Deployment API","data":{"creates-or-updates-a-deployment#Creates or updates a deployment":"Path\tMethod\tProtected\t/v1/api/deployments/deploy\tPOST\tYes\t\nDeploys a set of API definitions to a site (specific host and subdomain).Example Request JSON\n{\n  \"apiDefinitions\": [\n    {\n      \"id\": \"string\",\n      \"version\": \"string\"\n    }\n  ],\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"site\": {\n    \"host\": \"string\",\n    \"subdomain\": \"string\"\n  }\n}\nExample Response JSON\n{\n  \"apiDefinitions\": [\n    {\n      \"id\": \"string\",\n      \"version\": \"string\"\n    }\n  ],\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"site\": {\n    \"host\": \"string\",\n    \"subdomain\": \"string\"\n  },\n  \"createdAt\": \"2019-08-24T14:15:22Z\"\n}","get-one-or-more-api-deployments#Get one or more API deployments":"Path\tMethod\tProtected\t/v1/api/deployments\tGET\tYes\t\nIf api-definition-id is not set, it lists all API deployments.\nIf api-definition-id is set, returns a single API deployment.Query Parameters\nName\tType\tRequired\tDescription\tproject-id\tstring\tYes\t-\tapi-definition-id\tstring\tNo\t-\t\nExample Response JSON\n[\n  {\n    \"apiDefinitions\": [\n      {\n        \"id\": \"string\",\n        \"version\": \"string\"\n      }\n    ],\n    \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n    \"site\": {\n      \"host\": \"string\",\n      \"subdomain\": \"string\"\n    },\n    \"createdAt\": \"2019-08-24T14:15:22Z\"\n  }\n]","get-api-deployment-by-site#Get API deployment by site":"Path\tMethod\tProtected\t/v1/api/deployments/{site}\tGET\tYes\t\nGets an API deployment by the host name (optionally with a subdomain) it is deployed to.Query Parameters\nName\tType\tRequired\tDescription\tproject-id\tstring\tYes\t-\t\nExample Response JSON\n{\n  \"apiDefinitions\": [\n    {\n      \"id\": \"string\",\n      \"version\": \"string\"\n    }\n  ],\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"site\": {\n    \"host\": \"string\",\n    \"subdomain\": \"string\"\n  },\n  \"createdAt\": \"2019-08-24T14:15:22Z\"\n}","delete-api-deployment-by-site#Delete API deployment by site":"Path\tMethod\tProtected\t/v1/api/deployments/{site}\tDELETE\tYes\t\nDeletes an API deployment by the host name (optionally with a subdomain) it is deployed to.Query Parameters\nName\tType\tRequired\tDescription\tproject-id\tstring\tYes\t-\t\nExample Response JSON\n\"string\"","undeploy-a-single-api-definition-from-a-site#Undeploy a single API definition from a site":"Path\tMethod\tProtected\t/v1/api/deployments/{site}/{id}/{version}\tDELETE\tYes\t\nRemoves a specific API definition (by id and version) from a site without deleting the entire deployment.Query Parameters\nName\tType\tRequired\tDescription\tproject-id\tstring\tYes\t-\t\nExample Response JSON\n\"string\"","api-deployment-api-errors#Api Deployment API Errors":"Status Code\tDescription\tBody\t400\t\t{\"errors\":[\"string\"]}\t401\t\t{\"error\":\"string\"}\t403\t\t{\"error\":\"string\"}\t404\t\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\t\t{\"error\":\"string\",\"workerError\":{\"cause\":\"string\",\"stderr\":\"string\"}}"}},"/rest-api/component":{"title":"Component API","data":{"get-the-metadata-for-all-component-versions#Get the metadata for all component versions":"Path\tMethod\tProtected\t/v1/components/{component_id}\tGET\tYes\t\nEach component can have multiple versions. Every time a new WASM is uploaded for a given component id, that creates a new version.\nThis endpoint returns a list of all versions for the component id provided as part of the URL. Each element of the response describes a single version of a component, but does not contain the binary (WASM) itself:\nversionedComponentId associates a specific version with the component id\ncomponentName is the human-readable name of the component\ncomponentSize is the WASM binary's size in bytes\nmetadata contains information extracted from the WASM itself\nmetadata.exports is a list of exported functions, including their parameter's and return value's types\nmetadata.producers is a list of producer information added by tooling, each consisting of a list of fields associating one or more values to a given key. This contains information about what compilers and other WASM related tools were used to construct the Golem component.\nExample Response JSON\n[\n  {\n    \"versionedComponentId\": {\n      \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n      \"version\": 0\n    },\n    \"componentName\": \"string\",\n    \"componentSize\": 0,\n    \"metadata\": {\n      \"exports\": [\n        {\n          \"type\": \"Function\",\n          \"name\": \"string\",\n          \"parameters\": [\n            {\n              \"name\": \"string\",\n              \"typ\": {\n                \"type\": \"Variant\",\n                \"name\": \"string\",\n                \"owner\": \"string\",\n                \"cases\": [\n                  {\n                    \"name\": \"string\",\n                    \"typ\": {}\n                  }\n                ]\n              }\n            }\n          ],\n          \"result\": {\n            \"typ\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        }\n      ],\n      \"producers\": [\n        {\n          \"fields\": [\n            {\n              \"name\": \"string\",\n              \"values\": [\n                {\n                  \"name\": \"string\",\n                  \"version\": \"string\"\n                }\n              ]\n            }\n          ]\n        }\n      ],\n      \"memories\": [\n        {\n          \"initial\": 0,\n          \"maximum\": 0\n        }\n      ],\n      \"binaryWit\": \"string\",\n      \"rootPackageName\": \"string\",\n      \"rootPackageVersion\": \"string\",\n      \"dynamicLinking\": {\n        \"property1\": {\n          \"type\": \"WasmRpc\",\n          \"targets\": {\n            \"property1\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            },\n            \"property2\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            }\n          }\n        },\n        \"property2\": {\n          \"type\": \"WasmRpc\",\n          \"targets\": {\n            \"property1\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            },\n            \"property2\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            }\n          }\n        }\n      },\n      \"agentTypes\": [\n        {\n          \"typeName\": \"string\",\n          \"description\": \"string\",\n          \"constructor\": {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          },\n          \"methods\": [\n            {\n              \"name\": \"string\",\n              \"description\": \"string\",\n              \"promptHint\": \"string\",\n              \"inputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              },\n              \"outputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              }\n            }\n          ],\n          \"dependencies\": [\n            {\n              \"typeName\": \"string\",\n              \"description\": \"string\",\n              \"constructor\": {\n                \"name\": \"string\",\n                \"description\": \"string\",\n                \"promptHint\": \"string\",\n                \"inputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                }\n              },\n              \"methods\": [\n                {\n                  \"name\": \"string\",\n                  \"description\": \"string\",\n                  \"promptHint\": \"string\",\n                  \"inputSchema\": {\n                    \"type\": \"Multimodal\",\n                    \"elements\": [\n                      {\n                        \"name\": \"string\",\n                        \"schema\": {\n                          \"type\": \"ComponentModel\",\n                          \"elementType\": {\n                            \"type\": \"Variant\",\n                            \"name\": \"string\",\n                            \"owner\": \"string\",\n                            \"cases\": [\n                              null\n                            ]\n                          }\n                        }\n                      }\n                    ]\n                  },\n                  \"outputSchema\": {\n                    \"type\": \"Multimodal\",\n                    \"elements\": [\n                      {\n                        \"name\": \"string\",\n                        \"schema\": {\n                          \"type\": \"ComponentModel\",\n                          \"elementType\": {\n                            \"type\": \"Variant\",\n                            \"name\": \"string\",\n                            \"owner\": \"string\",\n                            \"cases\": [\n                              null\n                            ]\n                          }\n                        }\n                      }\n                    ]\n                  }\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    },\n    \"accountId\": \"string\",\n    \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n    \"createdAt\": \"2019-08-24T14:15:22Z\",\n    \"componentType\": \"Durable\",\n    \"files\": [\n      {\n        \"key\": \"string\",\n        \"path\": \"string\",\n        \"permissions\": \"read-only\"\n      }\n    ],\n    \"installedPlugins\": [\n      {\n        \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n        \"pluginName\": \"string\",\n        \"pluginVersion\": \"string\",\n        \"pluginRegistered\": true,\n        \"priority\": 0,\n        \"parameters\": {\n          \"property1\": \"string\",\n          \"property2\": \"string\"\n        }\n      }\n    ],\n    \"env\": {\n      \"property1\": \"string\",\n      \"property2\": \"string\"\n    }\n  }\n]","update-a-component#Update a component":"Path\tMethod\tProtected\t/v1/components/{component_id}/upload\tPUT\tYes\t\nQuery Parameters\nName\tType\tRequired\tDescription\tcomponent_type\t#/components/schemas/ComponentType\tNo\tType of the new version of the component - if not specified, the type of the previous version\tis used.\t\nRequest Body: WASM Binary File\nMake sure to include Content-Type: application/octet-stream Header\nExample Response JSON\n{\n  \"versionedComponentId\": {\n    \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n    \"version\": 0\n  },\n  \"componentName\": \"string\",\n  \"componentSize\": 0,\n  \"metadata\": {\n    \"exports\": [\n      {\n        \"type\": \"Function\",\n        \"name\": \"string\",\n        \"parameters\": [\n          {\n            \"name\": \"string\",\n            \"typ\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        ],\n        \"result\": {\n          \"typ\": {\n            \"type\": \"Variant\",\n            \"name\": \"string\",\n            \"owner\": \"string\",\n            \"cases\": [\n              {\n                \"name\": \"string\",\n                \"typ\": {}\n              }\n            ]\n          }\n        }\n      }\n    ],\n    \"producers\": [\n      {\n        \"fields\": [\n          {\n            \"name\": \"string\",\n            \"values\": [\n              {\n                \"name\": \"string\",\n                \"version\": \"string\"\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"memories\": [\n      {\n        \"initial\": 0,\n        \"maximum\": 0\n      }\n    ],\n    \"binaryWit\": \"string\",\n    \"rootPackageName\": \"string\",\n    \"rootPackageVersion\": \"string\",\n    \"dynamicLinking\": {\n      \"property1\": {\n        \"type\": \"WasmRpc\",\n        \"targets\": {\n          \"property1\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          },\n          \"property2\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          }\n        }\n      },\n      \"property2\": {\n        \"type\": \"WasmRpc\",\n        \"targets\": {\n          \"property1\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          },\n          \"property2\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          }\n        }\n      }\n    },\n    \"agentTypes\": [\n      {\n        \"typeName\": \"string\",\n        \"description\": \"string\",\n        \"constructor\": {\n          \"name\": \"string\",\n          \"description\": \"string\",\n          \"promptHint\": \"string\",\n          \"inputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        },\n        \"methods\": [\n          {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            },\n            \"outputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          }\n        ],\n        \"dependencies\": [\n          {\n            \"typeName\": \"string\",\n            \"description\": \"string\",\n            \"constructor\": {\n              \"name\": \"string\",\n              \"description\": \"string\",\n              \"promptHint\": \"string\",\n              \"inputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              }\n            },\n            \"methods\": [\n              {\n                \"name\": \"string\",\n                \"description\": \"string\",\n                \"promptHint\": \"string\",\n                \"inputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                },\n                \"outputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                }\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  },\n  \"accountId\": \"string\",\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"createdAt\": \"2019-08-24T14:15:22Z\",\n  \"componentType\": \"Durable\",\n  \"files\": [\n    {\n      \"key\": \"string\",\n      \"path\": \"string\",\n      \"permissions\": \"read-only\"\n    }\n  ],\n  \"installedPlugins\": [\n    {\n      \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n      \"pluginName\": \"string\",\n      \"pluginVersion\": \"string\",\n      \"pluginRegistered\": true,\n      \"priority\": 0,\n      \"parameters\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n      }\n    }\n  ],\n  \"env\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}","update-a-component-1#Update a component":"Path\tMethod\tProtected\t/v1/components/{component_id}/updates\tPOST\tYes\t\nRequest Form: multipart/form-data\nMake sure to include Content-Type: multipart/form-data Header\nField componentType: JSON\n\"Durable\"\nField component: string binaryField filesPermissions: JSON\n{\n  \"values\": [\n    {\n      \"path\": \"string\",\n      \"permissions\": \"read-only\"\n    }\n  ]\n}\nField files: string binaryField dynamicLinking: JSON\n{\n  \"dynamicLinking\": {\n    \"property1\": {\n      \"type\": \"WasmRpc\",\n      \"targets\": {\n        \"property1\": {\n          \"interfaceName\": \"string\",\n          \"componentName\": \"string\",\n          \"componentType\": \"Durable\"\n        },\n        \"property2\": {\n          \"interfaceName\": \"string\",\n          \"componentName\": \"string\",\n          \"componentType\": \"Durable\"\n        }\n      }\n    },\n    \"property2\": {\n      \"type\": \"WasmRpc\",\n      \"targets\": {\n        \"property1\": {\n          \"interfaceName\": \"string\",\n          \"componentName\": \"string\",\n          \"componentType\": \"Durable\"\n        },\n        \"property2\": {\n          \"interfaceName\": \"string\",\n          \"componentName\": \"string\",\n          \"componentType\": \"Durable\"\n        }\n      }\n    }\n  }\n}\nField env: JSON\n{\n  \"keyValues\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}\nField agentTypes: JSON\n{\n  \"types\": [\n    {\n      \"typeName\": \"string\",\n      \"description\": \"string\",\n      \"constructor\": {\n        \"name\": \"string\",\n        \"description\": \"string\",\n        \"promptHint\": \"string\",\n        \"inputSchema\": {\n          \"type\": \"Multimodal\",\n          \"elements\": [\n            {\n              \"name\": \"string\",\n              \"schema\": {\n                \"type\": \"ComponentModel\",\n                \"elementType\": {\n                  \"type\": \"Variant\",\n                  \"name\": \"string\",\n                  \"owner\": \"string\",\n                  \"cases\": [\n                    {\n                      \"name\": \"string\",\n                      \"typ\": {}\n                    }\n                  ]\n                }\n              }\n            }\n          ]\n        }\n      },\n      \"methods\": [\n        {\n          \"name\": \"string\",\n          \"description\": \"string\",\n          \"promptHint\": \"string\",\n          \"inputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          },\n          \"outputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        }\n      ],\n      \"dependencies\": [\n        {\n          \"typeName\": \"string\",\n          \"description\": \"string\",\n          \"constructor\": {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          },\n          \"methods\": [\n            {\n              \"name\": \"string\",\n              \"description\": \"string\",\n              \"promptHint\": \"string\",\n              \"inputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              },\n              \"outputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              }\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\nExample Response JSON\n{\n  \"versionedComponentId\": {\n    \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n    \"version\": 0\n  },\n  \"componentName\": \"string\",\n  \"componentSize\": 0,\n  \"metadata\": {\n    \"exports\": [\n      {\n        \"type\": \"Function\",\n        \"name\": \"string\",\n        \"parameters\": [\n          {\n            \"name\": \"string\",\n            \"typ\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        ],\n        \"result\": {\n          \"typ\": {\n            \"type\": \"Variant\",\n            \"name\": \"string\",\n            \"owner\": \"string\",\n            \"cases\": [\n              {\n                \"name\": \"string\",\n                \"typ\": {}\n              }\n            ]\n          }\n        }\n      }\n    ],\n    \"producers\": [\n      {\n        \"fields\": [\n          {\n            \"name\": \"string\",\n            \"values\": [\n              {\n                \"name\": \"string\",\n                \"version\": \"string\"\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"memories\": [\n      {\n        \"initial\": 0,\n        \"maximum\": 0\n      }\n    ],\n    \"binaryWit\": \"string\",\n    \"rootPackageName\": \"string\",\n    \"rootPackageVersion\": \"string\",\n    \"dynamicLinking\": {\n      \"property1\": {\n        \"type\": \"WasmRpc\",\n        \"targets\": {\n          \"property1\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          },\n          \"property2\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          }\n        }\n      },\n      \"property2\": {\n        \"type\": \"WasmRpc\",\n        \"targets\": {\n          \"property1\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          },\n          \"property2\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          }\n        }\n      }\n    },\n    \"agentTypes\": [\n      {\n        \"typeName\": \"string\",\n        \"description\": \"string\",\n        \"constructor\": {\n          \"name\": \"string\",\n          \"description\": \"string\",\n          \"promptHint\": \"string\",\n          \"inputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        },\n        \"methods\": [\n          {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            },\n            \"outputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          }\n        ],\n        \"dependencies\": [\n          {\n            \"typeName\": \"string\",\n            \"description\": \"string\",\n            \"constructor\": {\n              \"name\": \"string\",\n              \"description\": \"string\",\n              \"promptHint\": \"string\",\n              \"inputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              }\n            },\n            \"methods\": [\n              {\n                \"name\": \"string\",\n                \"description\": \"string\",\n                \"promptHint\": \"string\",\n                \"inputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                },\n                \"outputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                }\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  },\n  \"accountId\": \"string\",\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"createdAt\": \"2019-08-24T14:15:22Z\",\n  \"componentType\": \"Durable\",\n  \"files\": [\n    {\n      \"key\": \"string\",\n      \"path\": \"string\",\n      \"permissions\": \"read-only\"\n    }\n  ],\n  \"installedPlugins\": [\n    {\n      \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n      \"pluginName\": \"string\",\n      \"pluginVersion\": \"string\",\n      \"pluginRegistered\": true,\n      \"priority\": 0,\n      \"parameters\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n      }\n    }\n  ],\n  \"env\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}","get-all-components#Get all components":"Path\tMethod\tProtected\t/v1/components\tGET\tYes\t\nGets all components, optionally filtered by project and/or component name.Query Parameters\nName\tType\tRequired\tDescription\tproject-id\tstring\tNo\tProject ID to filter by\tcomponent-name\tstring\tNo\tComponent name to filter by\t\nExample Response JSON\n[\n  {\n    \"versionedComponentId\": {\n      \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n      \"version\": 0\n    },\n    \"componentName\": \"string\",\n    \"componentSize\": 0,\n    \"metadata\": {\n      \"exports\": [\n        {\n          \"type\": \"Function\",\n          \"name\": \"string\",\n          \"parameters\": [\n            {\n              \"name\": \"string\",\n              \"typ\": {\n                \"type\": \"Variant\",\n                \"name\": \"string\",\n                \"owner\": \"string\",\n                \"cases\": [\n                  {\n                    \"name\": \"string\",\n                    \"typ\": {}\n                  }\n                ]\n              }\n            }\n          ],\n          \"result\": {\n            \"typ\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        }\n      ],\n      \"producers\": [\n        {\n          \"fields\": [\n            {\n              \"name\": \"string\",\n              \"values\": [\n                {\n                  \"name\": \"string\",\n                  \"version\": \"string\"\n                }\n              ]\n            }\n          ]\n        }\n      ],\n      \"memories\": [\n        {\n          \"initial\": 0,\n          \"maximum\": 0\n        }\n      ],\n      \"binaryWit\": \"string\",\n      \"rootPackageName\": \"string\",\n      \"rootPackageVersion\": \"string\",\n      \"dynamicLinking\": {\n        \"property1\": {\n          \"type\": \"WasmRpc\",\n          \"targets\": {\n            \"property1\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            },\n            \"property2\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            }\n          }\n        },\n        \"property2\": {\n          \"type\": \"WasmRpc\",\n          \"targets\": {\n            \"property1\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            },\n            \"property2\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            }\n          }\n        }\n      },\n      \"agentTypes\": [\n        {\n          \"typeName\": \"string\",\n          \"description\": \"string\",\n          \"constructor\": {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          },\n          \"methods\": [\n            {\n              \"name\": \"string\",\n              \"description\": \"string\",\n              \"promptHint\": \"string\",\n              \"inputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              },\n              \"outputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              }\n            }\n          ],\n          \"dependencies\": [\n            {\n              \"typeName\": \"string\",\n              \"description\": \"string\",\n              \"constructor\": {\n                \"name\": \"string\",\n                \"description\": \"string\",\n                \"promptHint\": \"string\",\n                \"inputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                }\n              },\n              \"methods\": [\n                {\n                  \"name\": \"string\",\n                  \"description\": \"string\",\n                  \"promptHint\": \"string\",\n                  \"inputSchema\": {\n                    \"type\": \"Multimodal\",\n                    \"elements\": [\n                      {\n                        \"name\": \"string\",\n                        \"schema\": {\n                          \"type\": \"ComponentModel\",\n                          \"elementType\": {\n                            \"type\": \"Variant\",\n                            \"name\": \"string\",\n                            \"owner\": \"string\",\n                            \"cases\": [\n                              null\n                            ]\n                          }\n                        }\n                      }\n                    ]\n                  },\n                  \"outputSchema\": {\n                    \"type\": \"Multimodal\",\n                    \"elements\": [\n                      {\n                        \"name\": \"string\",\n                        \"schema\": {\n                          \"type\": \"ComponentModel\",\n                          \"elementType\": {\n                            \"type\": \"Variant\",\n                            \"name\": \"string\",\n                            \"owner\": \"string\",\n                            \"cases\": [\n                              null\n                            ]\n                          }\n                        }\n                      }\n                    ]\n                  }\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    },\n    \"accountId\": \"string\",\n    \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n    \"createdAt\": \"2019-08-24T14:15:22Z\",\n    \"componentType\": \"Durable\",\n    \"files\": [\n      {\n        \"key\": \"string\",\n        \"path\": \"string\",\n        \"permissions\": \"read-only\"\n      }\n    ],\n    \"installedPlugins\": [\n      {\n        \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n        \"pluginName\": \"string\",\n        \"pluginVersion\": \"string\",\n        \"pluginRegistered\": true,\n        \"priority\": 0,\n        \"parameters\": {\n          \"property1\": \"string\",\n          \"property2\": \"string\"\n        }\n      }\n    ],\n    \"env\": {\n      \"property1\": \"string\",\n      \"property2\": \"string\"\n    }\n  }\n]","create-a-new-component#Create a new component":"Path\tMethod\tProtected\t/v1/components\tPOST\tYes\t\nThe request body is encoded as multipart/form-data containing metadata and the WASM binary.\nIf the component type is not specified, it will be considered as a Durable component.Request Form: multipart/form-data\nMake sure to include Content-Type: multipart/form-data Header\nField query: JSON\n{\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"componentName\": \"string\"\n}\nField component: string binaryField componentType: JSON\n\"Durable\"\nField filesPermissions: JSON\n{\n  \"values\": [\n    {\n      \"path\": \"string\",\n      \"permissions\": \"read-only\"\n    }\n  ]\n}\nField files: string binaryField dynamicLinking: JSON\n{\n  \"dynamicLinking\": {\n    \"property1\": {\n      \"type\": \"WasmRpc\",\n      \"targets\": {\n        \"property1\": {\n          \"interfaceName\": \"string\",\n          \"componentName\": \"string\",\n          \"componentType\": \"Durable\"\n        },\n        \"property2\": {\n          \"interfaceName\": \"string\",\n          \"componentName\": \"string\",\n          \"componentType\": \"Durable\"\n        }\n      }\n    },\n    \"property2\": {\n      \"type\": \"WasmRpc\",\n      \"targets\": {\n        \"property1\": {\n          \"interfaceName\": \"string\",\n          \"componentName\": \"string\",\n          \"componentType\": \"Durable\"\n        },\n        \"property2\": {\n          \"interfaceName\": \"string\",\n          \"componentName\": \"string\",\n          \"componentType\": \"Durable\"\n        }\n      }\n    }\n  }\n}\nField env: JSON\n{\n  \"keyValues\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}\nField agentTypes: JSON\n{\n  \"types\": [\n    {\n      \"typeName\": \"string\",\n      \"description\": \"string\",\n      \"constructor\": {\n        \"name\": \"string\",\n        \"description\": \"string\",\n        \"promptHint\": \"string\",\n        \"inputSchema\": {\n          \"type\": \"Multimodal\",\n          \"elements\": [\n            {\n              \"name\": \"string\",\n              \"schema\": {\n                \"type\": \"ComponentModel\",\n                \"elementType\": {\n                  \"type\": \"Variant\",\n                  \"name\": \"string\",\n                  \"owner\": \"string\",\n                  \"cases\": [\n                    {\n                      \"name\": \"string\",\n                      \"typ\": {}\n                    }\n                  ]\n                }\n              }\n            }\n          ]\n        }\n      },\n      \"methods\": [\n        {\n          \"name\": \"string\",\n          \"description\": \"string\",\n          \"promptHint\": \"string\",\n          \"inputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          },\n          \"outputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        }\n      ],\n      \"dependencies\": [\n        {\n          \"typeName\": \"string\",\n          \"description\": \"string\",\n          \"constructor\": {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          },\n          \"methods\": [\n            {\n              \"name\": \"string\",\n              \"description\": \"string\",\n              \"promptHint\": \"string\",\n              \"inputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              },\n              \"outputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              }\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\nExample Response JSON\n{\n  \"versionedComponentId\": {\n    \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n    \"version\": 0\n  },\n  \"componentName\": \"string\",\n  \"componentSize\": 0,\n  \"metadata\": {\n    \"exports\": [\n      {\n        \"type\": \"Function\",\n        \"name\": \"string\",\n        \"parameters\": [\n          {\n            \"name\": \"string\",\n            \"typ\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        ],\n        \"result\": {\n          \"typ\": {\n            \"type\": \"Variant\",\n            \"name\": \"string\",\n            \"owner\": \"string\",\n            \"cases\": [\n              {\n                \"name\": \"string\",\n                \"typ\": {}\n              }\n            ]\n          }\n        }\n      }\n    ],\n    \"producers\": [\n      {\n        \"fields\": [\n          {\n            \"name\": \"string\",\n            \"values\": [\n              {\n                \"name\": \"string\",\n                \"version\": \"string\"\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"memories\": [\n      {\n        \"initial\": 0,\n        \"maximum\": 0\n      }\n    ],\n    \"binaryWit\": \"string\",\n    \"rootPackageName\": \"string\",\n    \"rootPackageVersion\": \"string\",\n    \"dynamicLinking\": {\n      \"property1\": {\n        \"type\": \"WasmRpc\",\n        \"targets\": {\n          \"property1\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          },\n          \"property2\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          }\n        }\n      },\n      \"property2\": {\n        \"type\": \"WasmRpc\",\n        \"targets\": {\n          \"property1\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          },\n          \"property2\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          }\n        }\n      }\n    },\n    \"agentTypes\": [\n      {\n        \"typeName\": \"string\",\n        \"description\": \"string\",\n        \"constructor\": {\n          \"name\": \"string\",\n          \"description\": \"string\",\n          \"promptHint\": \"string\",\n          \"inputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        },\n        \"methods\": [\n          {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            },\n            \"outputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          }\n        ],\n        \"dependencies\": [\n          {\n            \"typeName\": \"string\",\n            \"description\": \"string\",\n            \"constructor\": {\n              \"name\": \"string\",\n              \"description\": \"string\",\n              \"promptHint\": \"string\",\n              \"inputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              }\n            },\n            \"methods\": [\n              {\n                \"name\": \"string\",\n                \"description\": \"string\",\n                \"promptHint\": \"string\",\n                \"inputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                },\n                \"outputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                }\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  },\n  \"accountId\": \"string\",\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"createdAt\": \"2019-08-24T14:15:22Z\",\n  \"componentType\": \"Durable\",\n  \"files\": [\n    {\n      \"key\": \"string\",\n      \"path\": \"string\",\n      \"permissions\": \"read-only\"\n    }\n  ],\n  \"installedPlugins\": [\n    {\n      \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n      \"pluginName\": \"string\",\n      \"pluginVersion\": \"string\",\n      \"pluginRegistered\": true,\n      \"priority\": 0,\n      \"parameters\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n      }\n    }\n  ],\n  \"env\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}","download-a-component#Download a component":"Path\tMethod\tProtected\t/v1/components/{component_id}/download\tGET\tYes\t\nDownloads a specific version of the component's WASM.Query Parameters\nName\tType\tRequired\tDescription\tversion\tinteger\tNo\t-\t\nResponse Body: WASM Binary File","get-the-version-of-a-given-component#Get the version of a given component":"Path\tMethod\tProtected\t/v1/components/{component_id}/versions/{version}\tGET\tYes\t\nGets the version of a component.Example Response JSON\n{\n  \"versionedComponentId\": {\n    \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n    \"version\": 0\n  },\n  \"componentName\": \"string\",\n  \"componentSize\": 0,\n  \"metadata\": {\n    \"exports\": [\n      {\n        \"type\": \"Function\",\n        \"name\": \"string\",\n        \"parameters\": [\n          {\n            \"name\": \"string\",\n            \"typ\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        ],\n        \"result\": {\n          \"typ\": {\n            \"type\": \"Variant\",\n            \"name\": \"string\",\n            \"owner\": \"string\",\n            \"cases\": [\n              {\n                \"name\": \"string\",\n                \"typ\": {}\n              }\n            ]\n          }\n        }\n      }\n    ],\n    \"producers\": [\n      {\n        \"fields\": [\n          {\n            \"name\": \"string\",\n            \"values\": [\n              {\n                \"name\": \"string\",\n                \"version\": \"string\"\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"memories\": [\n      {\n        \"initial\": 0,\n        \"maximum\": 0\n      }\n    ],\n    \"binaryWit\": \"string\",\n    \"rootPackageName\": \"string\",\n    \"rootPackageVersion\": \"string\",\n    \"dynamicLinking\": {\n      \"property1\": {\n        \"type\": \"WasmRpc\",\n        \"targets\": {\n          \"property1\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          },\n          \"property2\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          }\n        }\n      },\n      \"property2\": {\n        \"type\": \"WasmRpc\",\n        \"targets\": {\n          \"property1\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          },\n          \"property2\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          }\n        }\n      }\n    },\n    \"agentTypes\": [\n      {\n        \"typeName\": \"string\",\n        \"description\": \"string\",\n        \"constructor\": {\n          \"name\": \"string\",\n          \"description\": \"string\",\n          \"promptHint\": \"string\",\n          \"inputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        },\n        \"methods\": [\n          {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            },\n            \"outputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          }\n        ],\n        \"dependencies\": [\n          {\n            \"typeName\": \"string\",\n            \"description\": \"string\",\n            \"constructor\": {\n              \"name\": \"string\",\n              \"description\": \"string\",\n              \"promptHint\": \"string\",\n              \"inputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              }\n            },\n            \"methods\": [\n              {\n                \"name\": \"string\",\n                \"description\": \"string\",\n                \"promptHint\": \"string\",\n                \"inputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                },\n                \"outputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                }\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  },\n  \"accountId\": \"string\",\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"createdAt\": \"2019-08-24T14:15:22Z\",\n  \"componentType\": \"Durable\",\n  \"files\": [\n    {\n      \"key\": \"string\",\n      \"path\": \"string\",\n      \"permissions\": \"read-only\"\n    }\n  ],\n  \"installedPlugins\": [\n    {\n      \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n      \"pluginName\": \"string\",\n      \"pluginVersion\": \"string\",\n      \"pluginRegistered\": true,\n      \"priority\": 0,\n      \"parameters\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n      }\n    }\n  ],\n  \"env\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}","get-the-latest-version-of-a-given-component#Get the latest version of a given component":"Path\tMethod\tProtected\t/v1/components/{component_id}/latest\tGET\tYes\t\nGets the latest version of a component.Example Response JSON\n{\n  \"versionedComponentId\": {\n    \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n    \"version\": 0\n  },\n  \"componentName\": \"string\",\n  \"componentSize\": 0,\n  \"metadata\": {\n    \"exports\": [\n      {\n        \"type\": \"Function\",\n        \"name\": \"string\",\n        \"parameters\": [\n          {\n            \"name\": \"string\",\n            \"typ\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        ],\n        \"result\": {\n          \"typ\": {\n            \"type\": \"Variant\",\n            \"name\": \"string\",\n            \"owner\": \"string\",\n            \"cases\": [\n              {\n                \"name\": \"string\",\n                \"typ\": {}\n              }\n            ]\n          }\n        }\n      }\n    ],\n    \"producers\": [\n      {\n        \"fields\": [\n          {\n            \"name\": \"string\",\n            \"values\": [\n              {\n                \"name\": \"string\",\n                \"version\": \"string\"\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"memories\": [\n      {\n        \"initial\": 0,\n        \"maximum\": 0\n      }\n    ],\n    \"binaryWit\": \"string\",\n    \"rootPackageName\": \"string\",\n    \"rootPackageVersion\": \"string\",\n    \"dynamicLinking\": {\n      \"property1\": {\n        \"type\": \"WasmRpc\",\n        \"targets\": {\n          \"property1\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          },\n          \"property2\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          }\n        }\n      },\n      \"property2\": {\n        \"type\": \"WasmRpc\",\n        \"targets\": {\n          \"property1\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          },\n          \"property2\": {\n            \"interfaceName\": \"string\",\n            \"componentName\": \"string\",\n            \"componentType\": \"Durable\"\n          }\n        }\n      }\n    },\n    \"agentTypes\": [\n      {\n        \"typeName\": \"string\",\n        \"description\": \"string\",\n        \"constructor\": {\n          \"name\": \"string\",\n          \"description\": \"string\",\n          \"promptHint\": \"string\",\n          \"inputSchema\": {\n            \"type\": \"Multimodal\",\n            \"elements\": [\n              {\n                \"name\": \"string\",\n                \"schema\": {\n                  \"type\": \"ComponentModel\",\n                  \"elementType\": {\n                    \"type\": \"Variant\",\n                    \"name\": \"string\",\n                    \"owner\": \"string\",\n                    \"cases\": [\n                      {\n                        \"name\": \"string\",\n                        \"typ\": {}\n                      }\n                    ]\n                  }\n                }\n              }\n            ]\n          }\n        },\n        \"methods\": [\n          {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            },\n            \"outputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          }\n        ],\n        \"dependencies\": [\n          {\n            \"typeName\": \"string\",\n            \"description\": \"string\",\n            \"constructor\": {\n              \"name\": \"string\",\n              \"description\": \"string\",\n              \"promptHint\": \"string\",\n              \"inputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              }\n            },\n            \"methods\": [\n              {\n                \"name\": \"string\",\n                \"description\": \"string\",\n                \"promptHint\": \"string\",\n                \"inputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                },\n                \"outputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                }\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  },\n  \"accountId\": \"string\",\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"createdAt\": \"2019-08-24T14:15:22Z\",\n  \"componentType\": \"Durable\",\n  \"files\": [\n    {\n      \"key\": \"string\",\n      \"path\": \"string\",\n      \"permissions\": \"read-only\"\n    }\n  ],\n  \"installedPlugins\": [\n    {\n      \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n      \"pluginName\": \"string\",\n      \"pluginVersion\": \"string\",\n      \"pluginRegistered\": true,\n      \"priority\": 0,\n      \"parameters\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n      }\n    }\n  ],\n  \"env\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}","undefined#undefined":"Path\tMethod\tProtected\t/v1/components/search\tPOST\tYes\t\nExample Request JSON\n{\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"components\": [\n    {\n      \"name\": \"string\",\n      \"version\": 0\n    }\n  ]\n}\nExample Response JSON\n[\n  {\n    \"versionedComponentId\": {\n      \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n      \"version\": 0\n    },\n    \"componentName\": \"string\",\n    \"componentSize\": 0,\n    \"metadata\": {\n      \"exports\": [\n        {\n          \"type\": \"Function\",\n          \"name\": \"string\",\n          \"parameters\": [\n            {\n              \"name\": \"string\",\n              \"typ\": {\n                \"type\": \"Variant\",\n                \"name\": \"string\",\n                \"owner\": \"string\",\n                \"cases\": [\n                  {\n                    \"name\": \"string\",\n                    \"typ\": {}\n                  }\n                ]\n              }\n            }\n          ],\n          \"result\": {\n            \"typ\": {\n              \"type\": \"Variant\",\n              \"name\": \"string\",\n              \"owner\": \"string\",\n              \"cases\": [\n                {\n                  \"name\": \"string\",\n                  \"typ\": {}\n                }\n              ]\n            }\n          }\n        }\n      ],\n      \"producers\": [\n        {\n          \"fields\": [\n            {\n              \"name\": \"string\",\n              \"values\": [\n                {\n                  \"name\": \"string\",\n                  \"version\": \"string\"\n                }\n              ]\n            }\n          ]\n        }\n      ],\n      \"memories\": [\n        {\n          \"initial\": 0,\n          \"maximum\": 0\n        }\n      ],\n      \"binaryWit\": \"string\",\n      \"rootPackageName\": \"string\",\n      \"rootPackageVersion\": \"string\",\n      \"dynamicLinking\": {\n        \"property1\": {\n          \"type\": \"WasmRpc\",\n          \"targets\": {\n            \"property1\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            },\n            \"property2\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            }\n          }\n        },\n        \"property2\": {\n          \"type\": \"WasmRpc\",\n          \"targets\": {\n            \"property1\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            },\n            \"property2\": {\n              \"interfaceName\": \"string\",\n              \"componentName\": \"string\",\n              \"componentType\": \"Durable\"\n            }\n          }\n        }\n      },\n      \"agentTypes\": [\n        {\n          \"typeName\": \"string\",\n          \"description\": \"string\",\n          \"constructor\": {\n            \"name\": \"string\",\n            \"description\": \"string\",\n            \"promptHint\": \"string\",\n            \"inputSchema\": {\n              \"type\": \"Multimodal\",\n              \"elements\": [\n                {\n                  \"name\": \"string\",\n                  \"schema\": {\n                    \"type\": \"ComponentModel\",\n                    \"elementType\": {\n                      \"type\": \"Variant\",\n                      \"name\": \"string\",\n                      \"owner\": \"string\",\n                      \"cases\": [\n                        {\n                          \"name\": \"string\",\n                          \"typ\": {}\n                        }\n                      ]\n                    }\n                  }\n                }\n              ]\n            }\n          },\n          \"methods\": [\n            {\n              \"name\": \"string\",\n              \"description\": \"string\",\n              \"promptHint\": \"string\",\n              \"inputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              },\n              \"outputSchema\": {\n                \"type\": \"Multimodal\",\n                \"elements\": [\n                  {\n                    \"name\": \"string\",\n                    \"schema\": {\n                      \"type\": \"ComponentModel\",\n                      \"elementType\": {\n                        \"type\": \"Variant\",\n                        \"name\": \"string\",\n                        \"owner\": \"string\",\n                        \"cases\": [\n                          {\n                            \"name\": \"string\",\n                            \"typ\": {}\n                          }\n                        ]\n                      }\n                    }\n                  }\n                ]\n              }\n            }\n          ],\n          \"dependencies\": [\n            {\n              \"typeName\": \"string\",\n              \"description\": \"string\",\n              \"constructor\": {\n                \"name\": \"string\",\n                \"description\": \"string\",\n                \"promptHint\": \"string\",\n                \"inputSchema\": {\n                  \"type\": \"Multimodal\",\n                  \"elements\": [\n                    {\n                      \"name\": \"string\",\n                      \"schema\": {\n                        \"type\": \"ComponentModel\",\n                        \"elementType\": {\n                          \"type\": \"Variant\",\n                          \"name\": \"string\",\n                          \"owner\": \"string\",\n                          \"cases\": [\n                            {}\n                          ]\n                        }\n                      }\n                    }\n                  ]\n                }\n              },\n              \"methods\": [\n                {\n                  \"name\": \"string\",\n                  \"description\": \"string\",\n                  \"promptHint\": \"string\",\n                  \"inputSchema\": {\n                    \"type\": \"Multimodal\",\n                    \"elements\": [\n                      {\n                        \"name\": \"string\",\n                        \"schema\": {\n                          \"type\": \"ComponentModel\",\n                          \"elementType\": {\n                            \"type\": \"Variant\",\n                            \"name\": \"string\",\n                            \"owner\": \"string\",\n                            \"cases\": [\n                              null\n                            ]\n                          }\n                        }\n                      }\n                    ]\n                  },\n                  \"outputSchema\": {\n                    \"type\": \"Multimodal\",\n                    \"elements\": [\n                      {\n                        \"name\": \"string\",\n                        \"schema\": {\n                          \"type\": \"ComponentModel\",\n                          \"elementType\": {\n                            \"type\": \"Variant\",\n                            \"name\": \"string\",\n                            \"owner\": \"string\",\n                            \"cases\": [\n                              null\n                            ]\n                          }\n                        }\n                      }\n                    ]\n                  }\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    },\n    \"accountId\": \"string\",\n    \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n    \"createdAt\": \"2019-08-24T14:15:22Z\",\n    \"componentType\": \"Durable\",\n    \"files\": [\n      {\n        \"key\": \"string\",\n        \"path\": \"string\",\n        \"permissions\": \"read-only\"\n      }\n    ],\n    \"installedPlugins\": [\n      {\n        \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n        \"pluginName\": \"string\",\n        \"pluginVersion\": \"string\",\n        \"pluginRegistered\": true,\n        \"priority\": 0,\n        \"parameters\": {\n          \"property1\": \"string\",\n          \"property2\": \"string\"\n        }\n      }\n    ],\n    \"env\": {\n      \"property1\": \"string\",\n      \"property2\": \"string\"\n    }\n  }\n]","gets-the-list-of-plugins-installed-for-the-given-component-version#Gets the list of plugins installed for the given component version":"Path\tMethod\tProtected\t/v1/components/{component_id}/versions/{version}/plugins/installs\tGET\tYes\t\nExample Response JSON\n[\n  {\n    \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n    \"pluginName\": \"string\",\n    \"pluginVersion\": \"string\",\n    \"pluginRegistered\": true,\n    \"priority\": 0,\n    \"parameters\": {\n      \"property1\": \"string\",\n      \"property2\": \"string\"\n    }\n  }\n]","installs-a-new-plugin-for-this-component#Installs a new plugin for this component":"Path\tMethod\tProtected\t/v1/components/{component_id}/latest/plugins/installs\tPOST\tYes\t\nExample Request JSON\n{\n  \"name\": \"string\",\n  \"version\": \"string\",\n  \"priority\": 0,\n  \"parameters\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}\nExample Response JSON\n{\n  \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n  \"pluginName\": \"string\",\n  \"pluginVersion\": \"string\",\n  \"pluginRegistered\": true,\n  \"priority\": 0,\n  \"parameters\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}","updates-the-priority-or-parameters-of-a-plugin-installation#Updates the priority or parameters of a plugin installation":"Path\tMethod\tProtected\t/v1/components/{component_id}/versions/latest/plugins/installs/{installation_id}\tPUT\tYes\t\nExample Request JSON\n{\n  \"priority\": 0,\n  \"parameters\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}\nExample Response JSON\n{}","uninstalls-a-plugin-from-this-component#Uninstalls a plugin from this component":"Path\tMethod\tProtected\t/v1/components/{component_id}/latest/plugins/installs/{installation_id}\tDELETE\tYes\t\nExample Response JSON\n{}","applies-a-batch-of-changes-to-the-installed-plugins-of-a-component#Applies a batch of changes to the installed plugins of a component":"Path\tMethod\tProtected\t/v1/components/{component_id}/versions/latest/plugins/installs/batch\tPOST\tYes\t\nExample Request JSON\n{\n  \"actions\": [\n    {\n      \"type\": \"Install\",\n      \"name\": \"string\",\n      \"version\": \"string\",\n      \"priority\": 0,\n      \"parameters\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n      }\n    }\n  ]\n}\nExample Response JSON\n{}","download-file-in-a-component#Download file in a Component":"Path\tMethod\tProtected\t/v1/components/{component_id}/versions/{version}/file-contents/{file_path}\tGET\tYes\t\nResponse Body: WASM Binary File","component-api-errors#Component API Errors":"Status Code\tDescription\tBody\t400\tInvalid request, returning with a list of issues detected in the request\t{\"errors\":[\"string\"]}\t401\tUnauthorized\t{\"error\":\"string\"}\t403\tMaximum number of components exceeded\t{\"error\":\"string\"}\t404\tComponent not found\t{\"error\":\"string\"}\t409\tComponent already exists\t{\"error\":\"string\"}\t500\tInternal server error\t{\"error\":\"string\"}"}},"/rest-api/limits":{"title":"Limits API","data":{"":"The limits API allows users to query their current resource limits.","get-resource-limits-for-a-given-account#Get resource limits for a given account.":"Path\tMethod\tProtected\t/v1/resource-limits\tGET\tYes\t\nQuery Parameters\nName\tType\tRequired\tDescription\taccount-id\tstring\tYes\tThe Account ID to check resource limits for.\t\nExample Response JSON\n{\n  \"availableFuel\": 0,\n  \"maxMemoryPerWorker\": 0\n}","update-resource-limits-for-a-given-account#Update resource limits for a given account.":"Path\tMethod\tProtected\t/v1/resource-limits\tPOST\tYes\t\nExample Request JSON\n{\n  \"updates\": {\n    \"property1\": 0,\n    \"property2\": 0\n  }\n}\nExample Response JSON\n{}","limits-api-errors#Limits API Errors":"Status Code\tDescription\tBody\t400\tInvalid request, returning with a list of issues detected in the request\t{\"errors\":[\"string\"]}\t401\tUnauthorized request\t{\"error\":\"string\"}\t403\t\t{\"error\":\"string\"}\t500\tInternal server error\t{\"error\":\"string\"}"}},"/rest-api/login":{"title":"Login API","data":{"":"The login endpoints are implementing an OAuth2 flow.","acquire-token-with-oauth2-authorization#Acquire token with OAuth2 authorization":"Path\tMethod\tProtected\t/v1/oauth2\tPOST\tNo\t\nGets a token by authorizing with an external OAuth2 provider. Currently only github is supported.In the response:\nid is the identifier of the token itself\naccountId is the account's identifier, can be used on the account API\nsecret is the secret key to be sent in the Authorization header as a bearer token for all the other endpoints\nQuery Parameters\nName\tType\tRequired\tDescription\tprovider\tstring\tYes\tCurrently only github is supported.\taccess-token\tstring\tYes\tOAuth2 access token\t\nExample Response JSON\n{\n  \"data\": {\n    \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n    \"accountId\": \"string\",\n    \"createdAt\": \"2019-08-24T14:15:22Z\",\n    \"expiresAt\": \"2019-08-24T14:15:22Z\"\n  },\n  \"secret\": {\n    \"value\": \"a860a344-d7b2-406e-828e-8d442f23f344\"\n  }\n}","get-information-about-a-token#Get information about a token":"Path\tMethod\tProtected\t/v1/login/token\tGET\tYes\t\nGets information about a token that is selected by the secret key passed in the Authorization header.\nThe JSON is the same as the data object in the oauth2 endpoint's response.Example Response JSON\n{\n  \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n  \"accountId\": \"string\",\n  \"createdAt\": \"2019-08-24T14:15:22Z\",\n  \"expiresAt\": \"2019-08-24T14:15:22Z\"\n}","start-github-oauth2-interactive-flow#Start GitHub OAuth2 interactive flow":"Path\tMethod\tProtected\t/login/oauth2/device/start\tPOST\tNo\t\nStarts an interactive authorization flow.\nThe user must open the returned url and enter the userCode in a form before the expires deadline.\nThen the finish GitHub OAuth2 interactive flow endpoint must be called with the encoded session to finish the flow.Example Response JSON\n{\n  \"url\": \"string\",\n  \"userCode\": \"string\",\n  \"expires\": \"2019-08-24T14:15:22Z\",\n  \"encodedSession\": \"string\"\n}","finish-github-oauth2-interactive-flow#Finish GitHub OAuth2 interactive flow":"Path\tMethod\tProtected\t/login/oauth2/device/complete\tPOST\tNo\t\nFinishes an interactive authorization flow. The returned JSON is equivalent to the oauth2 endpoint's response.\nReturns a JSON string containing the encodedSession from the start endpoint's response.Example Request JSON\n\"string\"\nExample Response JSON\n{\n  \"data\": {\n    \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n    \"accountId\": \"string\",\n    \"createdAt\": \"2019-08-24T14:15:22Z\",\n    \"expiresAt\": \"2019-08-24T14:15:22Z\"\n  },\n  \"secret\": {\n    \"value\": \"a860a344-d7b2-406e-828e-8d442f23f344\"\n  }\n}","initiate-oauth2-web-flow#Initiate OAuth2 Web Flow":"Path\tMethod\tProtected\t/v1/login/oauth2/web/authorize\tGET\tNo\t\nStarts the OAuth2 web flow authorization process by returning the authorization URL for the given provider.Query Parameters\nName\tType\tRequired\tDescription\tprovider\tstring\tYes\tCurrently only github is supported.\tredirect\tstring\tNo\tThe redirect URL to redirect to after the user has authorized the application\t\nExample Response JSON\n{\n  \"url\": \"string\",\n  \"state\": \"string\"\n}","github-oauth2-web-flow-callback#GitHub OAuth2 Web Flow callback":"Path\tMethod\tProtected\t/v1/login/oauth2/web/callback/github\tGET\tNo\t\nThis endpoint handles the callback from GitHub after the user has authorized the application.\nIt exchanges the code for an access token and then uses that to log the user in.Query Parameters\nName\tType\tRequired\tDescription\tcode\tstring\tYes\tThe authorization code returned by GitHub\tstate\tstring\tYes\tThe state parameter for CSRF protection\t\nExample Response JSON\n{}","poll-for-oauth2-web-flow-token#Poll for OAuth2 Web Flow token":"Path\tMethod\tProtected\t/v1/login/oauth2/web/poll\tGET\tNo\t\nThis endpoint is used by clients to poll for the token after the user has authorized the application via the web flow.Query Parameters\nName\tType\tRequired\tDescription\tstate\tstring\tYes\tThe state parameter for identifying the session\t\nExample Response JSON\n{\n  \"data\": {\n    \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n    \"accountId\": \"string\",\n    \"createdAt\": \"2019-08-24T14:15:22Z\",\n    \"expiresAt\": \"2019-08-24T14:15:22Z\"\n  },\n  \"secret\": {\n    \"value\": \"a860a344-d7b2-406e-828e-8d442f23f344\"\n  }\n}","login-api-errors#Login API Errors":"Status Code\tDescription\tBody\t400\tInvalid request, returning with a list of issues detected in the request\t{\"errors\":[\"string\"]}\t401\tUnauthorized request\t{\"error\":\"string\"}\t403\tForbidden Request\t{\"error\":\"string\"}\t404\tEntity not found\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\tInternal server error\t{\"error\":\"string\"}"}},"/rest-api/plugin":{"title":"Plugin API","data":{"lists-all-the-registered-plugins-including-all-versions-of-each#Lists all the registered plugins (including all versions of each).":"Path\tMethod\tProtected\t/v1/plugins\tGET\tYes\t\nQuery Parameters\nName\tType\tRequired\tDescription\tscope\t#/components/schemas/PluginScope\tYes\t-\t\nExample Response JSON\n[\n  {\n    \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n    \"name\": \"string\",\n    \"version\": \"string\",\n    \"description\": \"string\",\n    \"icon\": [\n      0\n    ],\n    \"homepage\": \"string\",\n    \"specs\": {\n      \"type\": \"ComponentTransformer\",\n      \"providedWitPackage\": \"string\",\n      \"jsonSchema\": \"string\",\n      \"validateUrl\": \"string\",\n      \"transformUrl\": \"string\"\n    },\n    \"scope\": {\n      \"type\": \"Global\"\n    },\n    \"owner\": {\n      \"accountId\": \"string\"\n    },\n    \"deleted\": true\n  }\n]","registers-a-new-plugin#Registers a new plugin":"Path\tMethod\tProtected\t/v1/plugins\tPOST\tYes\t\nExample Request JSON\n{\n  \"name\": \"string\",\n  \"version\": \"string\",\n  \"description\": \"string\",\n  \"icon\": [\n    0\n  ],\n  \"homepage\": \"string\",\n  \"specs\": {\n    \"type\": \"ComponentTransformer\",\n    \"providedWitPackage\": \"string\",\n    \"jsonSchema\": \"string\",\n    \"validateUrl\": \"string\",\n    \"transformUrl\": \"string\"\n  },\n  \"scope\": {\n    \"type\": \"Global\"\n  }\n}\nExample Response JSON\n{}","gets-a-registered-plugin-by-its-name-and-version#Gets a registered plugin by its name and version":"Path\tMethod\tProtected\t/v1/plugins/{account_id}/{name}/{version}\tGET\tYes\t\nExample Response JSON\n{\n  \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n  \"name\": \"string\",\n  \"version\": \"string\",\n  \"description\": \"string\",\n  \"icon\": [\n    0\n  ],\n  \"homepage\": \"string\",\n  \"specs\": {\n    \"type\": \"ComponentTransformer\",\n    \"providedWitPackage\": \"string\",\n    \"jsonSchema\": \"string\",\n    \"validateUrl\": \"string\",\n    \"transformUrl\": \"string\"\n  },\n  \"scope\": {\n    \"type\": \"Global\"\n  },\n  \"owner\": {\n    \"accountId\": \"string\"\n  },\n  \"deleted\": true\n}","deletes-a-registered-plugin-by-its-name-and-version#Deletes a registered plugin by its name and version":"Path\tMethod\tProtected\t/v1/plugins/{account_id}/{name}/{version}\tDELETE\tYes\t\nExample Response JSON\n{}","registers-a-new-library-plugin#Registers a new library plugin":"Path\tMethod\tProtected\t/v1/plugins/library-plugins\tPOST\tYes\t\nRequest Form: multipart/form-data\nMake sure to include Content-Type: multipart/form-data Header\nField name: string undefinedField version: string undefinedField description: string undefinedField icon: string binaryField homepage: string undefinedField scope: JSON\n{\n  \"type\": \"Global\"\n}\nField wasm: string binaryExample Response JSON\n{}","registers-a-new-app-plugin#Registers a new app plugin":"Path\tMethod\tProtected\t/v1/plugins/app-plugins\tPOST\tYes\t\nRequest Form: multipart/form-data\nMake sure to include Content-Type: multipart/form-data Header\nField name: string undefinedField version: string undefinedField description: string undefinedField icon: string binaryField homepage: string undefinedField scope: JSON\n{\n  \"type\": \"Global\"\n}\nField wasm: string binaryExample Response JSON\n{}","plugin-api-errors#Plugin API Errors":"Status Code\tDescription\tBody\t400\tInvalid request, returning with a list of issues detected in the request\t{\"errors\":[\"string\"]}\t401\tUnauthorized\t{\"error\":\"string\"}\t403\tMaximum number of components exceeded\t{\"error\":\"string\"}\t404\tComponent not found\t{\"error\":\"string\"}\t409\tComponent already exists\t{\"error\":\"string\"}\t500\tInternal server error\t{\"error\":\"string\"}"}},"/rest-api/project-policy":{"title":"Project Policy API","data":{"":"Project policies describe a set of actions one account can perform when it was associated with a grant for a project.","get-a-project-policy#Get a project policy":"Path\tMethod\tProtected\t/v1/project-policies/{project_policy_id}\tGET\tYes\t\nReturns a given project policy by it's ID. Project policy identifiers are used in project grants.Example Response JSON\n{\n  \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n  \"name\": \"string\",\n  \"projectActions\": {\n    \"actions\": [\n      \"ViewComponent\"\n    ]\n  }\n}","create-a-project-policy#Create a project policy":"Path\tMethod\tProtected\t/v1/project-policies\tPOST\tYes\t\nCreates a new project policy and returns the object describing it, including the newly created policy's id.Example Request JSON\n{\n  \"name\": \"string\",\n  \"projectActions\": {\n    \"actions\": [\n      \"ViewComponent\"\n    ]\n  }\n}\nExample Response JSON\n{\n  \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n  \"name\": \"string\",\n  \"projectActions\": {\n    \"actions\": [\n      \"ViewComponent\"\n    ]\n  }\n}","project-policy-api-errors#Project Policy API Errors":"Status Code\tDescription\tBody\t400\tInvalid request, returning with a list of issues detected in the request\t{\"errors\":[\"string\"]}\t401\tUnauthorized request\t{\"error\":\"string\"}\t403\tForbidden Request\t{\"error\":\"string\"}\t404\tEntity not found\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\tInternal server error\t{\"error\":\"string\"}"}},"/rest-api/project":{"title":"Project API","data":{"":"Projects are groups of components and their workers, providing both a separate namespace for these entities and allows sharing between accounts.Every account has a default project which is assumed when no specific project ID is passed in some component and worker related APIs.","get-the-default-project#Get the default project":"Path\tMethod\tProtected\t/v1/projects/default\tGET\tYes\t\nname of the project can be used for lookup the project if the ID is now known\ndefaultEnvironmentId is currently always default\nprojectType is either Default\nExample Response JSON\n{\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"projectData\": {\n    \"name\": \"string\",\n    \"ownerAccountId\": \"string\",\n    \"description\": \"string\",\n    \"defaultEnvironmentId\": \"string\",\n    \"projectType\": \"Default\"\n  }\n}","list-all-projects#List all projects":"Path\tMethod\tProtected\t/v1/projects\tGET\tYes\t\nReturns all projects of the account if no project-name is specified.\nOtherwise, returns all projects of the account that has the given name.\nAs unique names are not enforced on the API level, the response may contain multiple entries.Query Parameters\nName\tType\tRequired\tDescription\tproject-name\tstring\tNo\tFilter by project name\t\nExample Response JSON\n[\n  {\n    \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n    \"projectData\": {\n      \"name\": \"string\",\n      \"ownerAccountId\": \"string\",\n      \"description\": \"string\",\n      \"defaultEnvironmentId\": \"string\",\n      \"projectType\": \"Default\"\n    }\n  }\n]","create-project#Create project":"Path\tMethod\tProtected\t/v1/projects\tPOST\tYes\t\nCreates a new project. The ownerAccountId must be the caller's account ID.Example Request JSON\n{\n  \"name\": \"string\",\n  \"ownerAccountId\": \"string\",\n  \"description\": \"string\"\n}\nExample Response JSON\n{\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"projectData\": {\n    \"name\": \"string\",\n    \"ownerAccountId\": \"string\",\n    \"description\": \"string\",\n    \"defaultEnvironmentId\": \"string\",\n    \"projectType\": \"Default\"\n  }\n}","get-project-by-id#Get project by ID":"Path\tMethod\tProtected\t/v1/projects/{project_id}\tGET\tYes\t\nGets a project by its identifier. Response is the same as for the default project.Example Response JSON\n{\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"projectData\": {\n    \"name\": \"string\",\n    \"ownerAccountId\": \"string\",\n    \"description\": \"string\",\n    \"defaultEnvironmentId\": \"string\",\n    \"projectType\": \"Default\"\n  }\n}","delete-project#Delete project":"Path\tMethod\tProtected\t/v1/projects/{project_id}\tDELETE\tYes\t\nDeletes a project given by its identifier.Example Response JSON\n{}","get-project-actions#Get project actions":"Path\tMethod\tProtected\t/v1/projects/{project_id}/actions\tGET\tYes\t\nReturns a list of actions that can be performed on the project.Example Response JSON\n[\n  \"ViewComponent\"\n]","gets-the-list-of-plugins-installed-for-the-given-project#Gets the list of plugins installed for the given project":"Path\tMethod\tProtected\t/v1/projects/{project_id}/plugins/installs\tGET\tYes\t\nExample Response JSON\n[\n  {\n    \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n    \"pluginName\": \"string\",\n    \"pluginVersion\": \"string\",\n    \"pluginRegistered\": true,\n    \"priority\": 0,\n    \"parameters\": {\n      \"property1\": \"string\",\n      \"property2\": \"string\"\n    }\n  }\n]","installs-a-new-plugin-for-this-project#Installs a new plugin for this project":"Path\tMethod\tProtected\t/v1/projects/{project_id}/plugins/installs\tPOST\tYes\t\nExample Request JSON\n{\n  \"name\": \"string\",\n  \"version\": \"string\",\n  \"priority\": 0,\n  \"parameters\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}\nExample Response JSON\n{\n  \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n  \"pluginName\": \"string\",\n  \"pluginVersion\": \"string\",\n  \"pluginRegistered\": true,\n  \"priority\": 0,\n  \"parameters\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}","updates-the-priority-or-parameters-of-a-plugin-installation#Updates the priority or parameters of a plugin installation":"Path\tMethod\tProtected\t/v1/projects/{project_id}/plugins/installs/{installation_id}\tPUT\tYes\t\nExample Request JSON\n{\n  \"priority\": 0,\n  \"parameters\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  }\n}\nExample Response JSON\n{}","uninstalls-a-plugin-from-this-project#Uninstalls a plugin from this project":"Path\tMethod\tProtected\t/v1/projects/{project_id}/latest/plugins/installs/{installation_id}\tDELETE\tYes\t\nExample Response JSON\n{}","applies-a-batch-of-changes-to-the-installed-plugins-of-a-component#Applies a batch of changes to the installed plugins of a component":"Path\tMethod\tProtected\t/v1/projects/{project_id}/latest/plugins/installs/batch\tPOST\tYes\t\nExample Request JSON\n{\n  \"actions\": [\n    {\n      \"type\": \"Install\",\n      \"name\": \"string\",\n      \"version\": \"string\",\n      \"priority\": 0,\n      \"parameters\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n      }\n    }\n  ]\n}\nExample Response JSON\n{}","project-api-errors#Project API Errors":"Status Code\tDescription\tBody\t400\tInvalid request, returning with a list of issues detected in the request\t{\"errors\":[\"string\"]}\t401\tUnauthorized request\t{\"error\":\"string\"}\t403\tForbidden Request\t{\"error\":\"string\"}\t404\tEntity not found\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\tInternal server error\t{\"error\":\"string\"}"}},"/rest-api/project-grant":{"title":"Project Grant API","data":{"":"Projects can have grants providing access to other accounts than the project's owner.The project grant API allows listing, creating and deleting such grants. What the grants allow exactly are defined by policies, covered by the Project policy API.","get-a-projects-grants#Get a project's grants":"Path\tMethod\tProtected\t/v1/projects/{project_id}/grants\tGET\tYes\t\nReturns all projects grants associated with the given project.For each grant:\n`id`` is the identifier of the grant itself\ngranteeAccountId the account that gets access for the project\ngrantorProjectId the project ID\nprojectPolicyId the associated policy - see the project policy API below\nExample Response JSON\n[\n  {\n    \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n    \"data\": {\n      \"granteeAccountId\": \"string\",\n      \"grantorProjectId\": \"fe216e71-e471-414b-9530-d000f4582d33\",\n      \"projectPolicyId\": \"46e8c3fb-5136-4f2a-a8be-e5188bef1348\"\n    }\n  }\n]","create-a-project-grant#Create a project grant":"Path\tMethod\tProtected\t/v1/projects/{project_id}/grants\tPOST\tYes\t\nCreates a new project grant from the following information:\ngranteeAccountId the account that gets access for the project\nprojectPolicyId the associated policy - see the project policy API below\nThe response describes the new project grant including its id that can be used to query specifically this grant in the future.Example Request JSON\n{\n  \"granteeAccountId\": \"string\",\n  \"granteeEmail\": \"string\",\n  \"projectPolicyId\": \"46e8c3fb-5136-4f2a-a8be-e5188bef1348\",\n  \"projectActions\": [\n    \"ViewComponent\"\n  ],\n  \"projectPolicyName\": \"string\"\n}\nExample Response JSON\n{\n  \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n  \"data\": {\n    \"granteeAccountId\": \"string\",\n    \"grantorProjectId\": \"fe216e71-e471-414b-9530-d000f4582d33\",\n    \"projectPolicyId\": \"46e8c3fb-5136-4f2a-a8be-e5188bef1348\"\n  }\n}","get-a-specific-grant-of-a-project#Get a specific grant of a project":"Path\tMethod\tProtected\t/v1/projects/{project_id}/grants/{grant_id}\tGET\tYes\t\nReturns a specific grant of a specific project. The returned object is the same as the elements of the grants endpoint's response described above.Example Response JSON\n{\n  \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n  \"data\": {\n    \"granteeAccountId\": \"string\",\n    \"grantorProjectId\": \"fe216e71-e471-414b-9530-d000f4582d33\",\n    \"projectPolicyId\": \"46e8c3fb-5136-4f2a-a8be-e5188bef1348\"\n  }\n}","delete-a-project-grant#Delete a project grant":"Path\tMethod\tProtected\t/v1/projects/{project_id}/grants/{grant_id}\tDELETE\tYes\t\nDeletes an existing grant of a specific project.Example Response JSON\n{}","project-grant-api-errors#Project Grant API Errors":"Status Code\tDescription\tBody\t400\tInvalid request, returning with a list of issues detected in the request\t{\"errors\":[\"string\"]}\t401\tUnauthorized request\t{\"error\":\"string\"}\t403\tForbidden Request\t{\"error\":\"string\"}\t404\tEntity not found\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\tInternal server error\t{\"error\":\"string\"}"}},"/rest-api/token":{"title":"Token API","data":{"":"The token API allows creating custom access tokens for the Golem Cloud REST API to be used by tools and services.","get-all-tokens#Get all tokens":"Path\tMethod\tProtected\t/v1/accounts/{account_id}/tokens\tGET\tYes\t\nGets all created tokens of an account.\nThe format of each element is the same as the data object in the oauth2 endpoint's response.Example Response JSON\n[\n  {\n    \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n    \"accountId\": \"string\",\n    \"createdAt\": \"2019-08-24T14:15:22Z\",\n    \"expiresAt\": \"2019-08-24T14:15:22Z\"\n  }\n]","create-new-token#Create new token":"Path\tMethod\tProtected\t/v1/accounts/{account_id}/tokens\tPOST\tYes\t\nCreates a new token with a given expiration date.\nThe response not only contains the token data but also the secret which can be passed as a bearer token to the Authorization header to the Golem Cloud REST API.Example Request JSON\n{\n  \"expiresAt\": \"2019-08-24T14:15:22Z\"\n}\nExample Response JSON\n{\n  \"data\": {\n    \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n    \"accountId\": \"string\",\n    \"createdAt\": \"2019-08-24T14:15:22Z\",\n    \"expiresAt\": \"2019-08-24T14:15:22Z\"\n  },\n  \"secret\": {\n    \"value\": \"a860a344-d7b2-406e-828e-8d442f23f344\"\n  }\n}","get-a-specific-token#Get a specific token":"Path\tMethod\tProtected\t/v1/accounts/{account_id}/tokens/{token_id}\tGET\tYes\t\nGets information about a token given by its identifier.\nThe JSON is the same as the data object in the oauth2 endpoint's response.Example Response JSON\n{\n  \"id\": \"497f6eca-6276-4993-bfeb-53cbbbba6f08\",\n  \"accountId\": \"string\",\n  \"createdAt\": \"2019-08-24T14:15:22Z\",\n  \"expiresAt\": \"2019-08-24T14:15:22Z\"\n}","delete-a-token#Delete a token":"Path\tMethod\tProtected\t/v1/accounts/{account_id}/tokens/{token_id}\tDELETE\tYes\t\nDeletes a previously created token given by its identifier.Example Response JSON\n{}","token-api-errors#Token API Errors":"Status Code\tDescription\tBody\t400\tInvalid request, returning with a list of issues detected in the request\t{\"errors\":[\"string\"]}\t401\tUnauthorized request\t{\"error\":\"string\"}\t403\tForbidden Request\t{\"error\":\"string\"}\t404\tEntity not found\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\tInternal server error\t{\"error\":\"string\"}"}},"/rest-api/worker":{"title":"Worker API","data":{"get-metadata-of-multiple-workers#Get metadata of multiple workers":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers\tGET\tYes","filters#Filters":"Property\tComparator\tDescription\tExample\tname\tStringFilterComparator\tName of worker\tname = worker-name\tversion\tFilterComparator\tVersion of worker\tversion >= 0\tstatus\tFilterComparator\tStatus of worker\tstatus = Running\tenv.[key]\tStringFilterComparator\tEnvironment variable of worker\tenv.var1 = value\tcreatedAt\tFilterComparator\tCreation time of worker\tcreatedAt > 2024-04-01T12:10:00Z","comparators#Comparators":"StringFilterComparator: eq|equal|=|==, ne|notequal|!=, like, notlike\nFilterComparator: eq|equal|=|==, ne|notequal|!=, ge|greaterequal|>=, gt|greater|>, le|lessequal|<=, lt|less|<\nReturns metadata about an existing component workers:\nworkers list of workers metadata\ncursor cursor for next request, if cursor is empty/null, there are no other values\nQuery Parameters\nName\tType\tRequired\tDescription\tfilter\tarray\tNo\tFilter for worker metadata in form of property op value. Can be used multiple times (AND condition is applied between them)\tcursor\tstring\tNo\tCount of listed values, default: 50\tcount\tinteger\tNo\tPosition where to start listing, if not provided, starts from the beginning. It is used to get the next page of results. To get next page, use the cursor returned in the response\tprecise\tboolean\tNo\tPrecision in relation to worker status, if true, calculate the most up-to-date status for each worker, default is false\t\nExample Response JSON\n{\n  \"workers\": [\n    {\n      \"workerId\": {\n        \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n        \"workerName\": \"string\"\n      },\n      \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n      \"createdBy\": \"string\",\n      \"args\": [\n        \"string\"\n      ],\n      \"env\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n      },\n      \"wasiConfigVars\": [\n        {\n          \"key\": \"string\",\n          \"value\": \"string\"\n        }\n      ],\n      \"status\": \"Running\",\n      \"componentVersion\": 0,\n      \"retryCount\": 0,\n      \"pendingInvocationCount\": 0,\n      \"updates\": [\n        {\n          \"type\": \"pendingUpdate\",\n          \"timestamp\": \"2019-08-24T14:15:22Z\",\n          \"targetVersion\": 0\n        }\n      ],\n      \"createdAt\": \"2019-08-24T14:15:22Z\",\n      \"lastError\": \"string\",\n      \"componentSize\": 0,\n      \"totalLinearMemorySize\": 0,\n      \"exportedResourceInstances\": [\n        {\n          \"key\": 0,\n          \"description\": {\n            \"createdAt\": \"2019-08-24T14:15:22Z\",\n            \"resourceOwner\": \"string\",\n            \"resourceName\": \"string\"\n          }\n        }\n      ],\n      \"activePlugins\": [\n        \"497f6eca-6276-4993-bfeb-53cbbbba6f08\"\n      ],\n      \"skippedRegions\": [\n        {\n          \"start\": 0,\n          \"end\": 0\n        }\n      ],\n      \"deletedRegions\": [\n        {\n          \"start\": 0,\n          \"end\": 0\n        }\n      ]\n    }\n  ],\n  \"cursor\": {\n    \"cursor\": 0,\n    \"layer\": 0\n  }\n}","launch-a-new-worker#Launch a new worker.":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers\tPOST\tYes\t\nCreates a new worker. The worker initially is in `Idle`` status, waiting to be invoked.The parameters in the request are the following:\nname is the name of the created worker. This has to be unique, but only for a given component\nargs is a list of strings which appear as command line arguments for the worker\nenv is a list of key-value pairs (represented by arrays) which appear as environment variables for the worker\nExample Request JSON\n{\n  \"name\": \"string\",\n  \"args\": [\n    \"string\"\n  ],\n  \"env\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  },\n  \"wasiConfigVars\": []\n}\nExample Response JSON\n{\n  \"workerId\": {\n    \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n    \"workerName\": \"string\"\n  },\n  \"componentVersion\": 0\n}","get-metadata-of-a-worker#Get metadata of a worker":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}\tGET\tYes\t\nReturns metadata about an existing worker:\nworkerId is a combination of the used component and the worker's user specified name\naccountId the account the worker is created by\nargs is the provided command line arguments passed to the worker\nenv is the provided map of environment variables passed to the worker\ncomponentVersion is the version of the component used by the worker\nretryCount is the number of retries the worker did in case of a failure\nstatus is the worker's current status, one of the following:\nRunning if the worker is currently executing\nIdle if the worker is waiting for an invocation\nSuspended if the worker was running but is now waiting to be resumed by an event (such as end of a sleep, a promise, etc)\nInterrupted if the worker was interrupted by the user\nRetrying if the worker failed, and an automatic retry was scheduled for it\nFailed if the worker failed and there are no more retries scheduled for it\nExited if the worker explicitly exited using the exit WASI function\nExample Response JSON\n{\n  \"workerId\": {\n    \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n    \"workerName\": \"string\"\n  },\n  \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n  \"createdBy\": \"string\",\n  \"args\": [\n    \"string\"\n  ],\n  \"env\": {\n    \"property1\": \"string\",\n    \"property2\": \"string\"\n  },\n  \"wasiConfigVars\": [\n    {\n      \"key\": \"string\",\n      \"value\": \"string\"\n    }\n  ],\n  \"status\": \"Running\",\n  \"componentVersion\": 0,\n  \"retryCount\": 0,\n  \"pendingInvocationCount\": 0,\n  \"updates\": [\n    {\n      \"type\": \"pendingUpdate\",\n      \"timestamp\": \"2019-08-24T14:15:22Z\",\n      \"targetVersion\": 0\n    }\n  ],\n  \"createdAt\": \"2019-08-24T14:15:22Z\",\n  \"lastError\": \"string\",\n  \"componentSize\": 0,\n  \"totalLinearMemorySize\": 0,\n  \"exportedResourceInstances\": [\n    {\n      \"key\": 0,\n      \"description\": {\n        \"createdAt\": \"2019-08-24T14:15:22Z\",\n        \"resourceOwner\": \"string\",\n        \"resourceName\": \"string\"\n      }\n    }\n  ],\n  \"activePlugins\": [\n    \"497f6eca-6276-4993-bfeb-53cbbbba6f08\"\n  ],\n  \"skippedRegions\": [\n    {\n      \"start\": 0,\n      \"end\": 0\n    }\n  ],\n  \"deletedRegions\": [\n    {\n      \"start\": 0,\n      \"end\": 0\n    }\n  ]\n}","delete-a-worker#Delete a worker":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}\tDELETE\tYes\t\nInterrupts and deletes an existing worker.Example Response JSON\n{}","invoke-a-function-and-await-its-resolution#Invoke a function and await its resolution":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/invoke-and-await\tPOST\tYes\t\nSupply the parameters in the request body as JSON.Query Parameters\nName\tType\tRequired\tDescription\tfunction\tstring\tYes\t-\t\nExample Request JSON\n{\n  \"params\": [\n    {\n      \"typ\": {\n        \"type\": \"Variant\",\n        \"name\": \"string\",\n        \"owner\": \"string\",\n        \"cases\": [\n          {\n            \"name\": \"string\",\n            \"typ\": {}\n          }\n        ]\n      },\n      \"value\": null\n    }\n  ]\n}\nExample Response JSON\n{\n  \"result\": {\n    \"typ\": {\n      \"type\": \"Variant\",\n      \"name\": \"string\",\n      \"owner\": \"string\",\n      \"cases\": [\n        {\n          \"name\": \"string\",\n          \"typ\": {}\n        }\n      ]\n    },\n    \"value\": null\n  }\n}","invoke-a-function#Invoke a function":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/invoke\tPOST\tYes\t\nA simpler version of the previously defined invoke and await endpoint just triggers the execution of a function and immediately returns.Query Parameters\nName\tType\tRequired\tDescription\tfunction\tstring\tYes\tname of the exported function to be invoked\t\nExample Request JSON\n{\n  \"params\": [\n    {\n      \"typ\": {\n        \"type\": \"Variant\",\n        \"name\": \"string\",\n        \"owner\": \"string\",\n        \"cases\": [\n          {\n            \"name\": \"string\",\n            \"typ\": {}\n          }\n        ]\n      },\n      \"value\": null\n    }\n  ]\n}\nExample Response JSON\n{}","complete-a-promise#Complete a promise":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/complete\tPOST\tYes\t\nCompletes a promise with a given custom array of bytes.\nThe promise must be previously created from within the worker, and it's identifier (a combination of a worker identifier and an oplogIdx ) must be sent out to an external caller so it can use this endpoint to mark the promise completed.\nThe data field is sent back to the worker, and it has no predefined meaning.Example Request JSON\n{\n  \"oplogIdx\": 0,\n  \"data\": [\n    0\n  ]\n}\nExample Response JSON\ntrue","interrupt-a-worker#Interrupt a worker":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/interrupt\tPOST\tYes\t\nInterrupts the execution of a worker.\nThe worker's status will be Interrupted unless the recover-immediately parameter was used, in which case it remains as it was.\nAn interrupted worker can be still used, and it is going to be automatically resumed the first time it is used.\nFor example in case of a new invocation, the previously interrupted invocation is continued before the new one gets processed.Query Parameters\nName\tType\tRequired\tDescription\trecovery-immediately\tboolean\tNo\tif true will simulate a worker recovery. Defaults to false.\t\nExample Response JSON\n{}","advanced-search-for-workers#Advanced search for workers":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/find\tPOST\tYes","filter-types#Filter types":"Type\tComparator\tDescription\tExample\tName\tStringFilterComparator\tName of worker\t{ \"type\": \"Name\", \"comparator\": \"Equal\", \"value\": \"worker-name\" }\tVersion\tFilterComparator\tVersion of worker\t{ \"type\": \"Version\", \"comparator\": \"GreaterEqual\", \"value\": 0 }\tStatus\tFilterComparator\tStatus of worker\t{ \"type\": \"Status\", \"comparator\": \"Equal\", \"value\": \"Running\" }\tEnv\tStringFilterComparator\tEnvironment variable of worker\t{ \"type\": \"Env\", \"name\": \"var1\", \"comparator\": \"Equal\", \"value\": \"value\" }\tCreatedAt\tFilterComparator\tCreation time of worker\t{ \"type\": \"CreatedAt\", \"comparator\": \"Greater\", \"value\": \"2024-04-01T12:10:00Z\" }\tAnd\t\tAnd filter combinator\t{ \"type\": \"And\", \"filters\": [ ... ] }\tOr\t\tOr filter combinator\t{ \"type\": \"Or\", \"filters\": [ ... ] }\tNot\t\tNegates the specified filter\t{ \"type\": \"Not\", \"filter\": { \"type\": \"Version\", \"comparator\": \"GreaterEqual\", \"value\": 0 } }","comparators-1#Comparators":"StringFilterComparator: Equal, NotEqual, Like, NotLike\nFilterComparator: Equal, NotEqual, GreaterEqual, Greater, LessEqual, Less\nReturns metadata about an existing component workers:\nworkers list of workers metadata\ncursor cursor for next request, if cursor is empty/null, there are no other values\nExample Request JSON\n{\n  \"filter\": {\n    \"type\": \"Name\",\n    \"comparator\": \"Equal\",\n    \"value\": \"string\"\n  },\n  \"cursor\": {\n    \"cursor\": 0,\n    \"layer\": 0\n  },\n  \"count\": 0,\n  \"precise\": true\n}\nExample Response JSON\n{\n  \"workers\": [\n    {\n      \"workerId\": {\n        \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n        \"workerName\": \"string\"\n      },\n      \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n      \"createdBy\": \"string\",\n      \"args\": [\n        \"string\"\n      ],\n      \"env\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n      },\n      \"wasiConfigVars\": [\n        {\n          \"key\": \"string\",\n          \"value\": \"string\"\n        }\n      ],\n      \"status\": \"Running\",\n      \"componentVersion\": 0,\n      \"retryCount\": 0,\n      \"pendingInvocationCount\": 0,\n      \"updates\": [\n        {\n          \"type\": \"pendingUpdate\",\n          \"timestamp\": \"2019-08-24T14:15:22Z\",\n          \"targetVersion\": 0\n        }\n      ],\n      \"createdAt\": \"2019-08-24T14:15:22Z\",\n      \"lastError\": \"string\",\n      \"componentSize\": 0,\n      \"totalLinearMemorySize\": 0,\n      \"exportedResourceInstances\": [\n        {\n          \"key\": 0,\n          \"description\": {\n            \"createdAt\": \"2019-08-24T14:15:22Z\",\n            \"resourceOwner\": \"string\",\n            \"resourceName\": \"string\"\n          }\n        }\n      ],\n      \"activePlugins\": [\n        \"497f6eca-6276-4993-bfeb-53cbbbba6f08\"\n      ],\n      \"skippedRegions\": [\n        {\n          \"start\": 0,\n          \"end\": 0\n        }\n      ],\n      \"deletedRegions\": [\n        {\n          \"start\": 0,\n          \"end\": 0\n        }\n      ]\n    }\n  ],\n  \"cursor\": {\n    \"cursor\": 0,\n    \"layer\": 0\n  }\n}","resume-a-worker#Resume a worker":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/resume\tPOST\tYes\t\nExample Response JSON\n{}","update-a-worker#Update a worker":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/update\tPOST\tYes\t\nExample Request JSON\n{\n  \"mode\": \"Automatic\",\n  \"targetVersion\": 0\n}\nExample Response JSON\n{}","get-the-oplog-of-a-worker#Get the oplog of a worker":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/oplog\tGET\tYes\t\nQuery Parameters\nName\tType\tRequired\tDescription\tfrom\tinteger\tNo\t-\tcount\tinteger\tYes\t-\tcursor\t#/components/schemas/OplogCursor\tNo\t-\tquery\tstring\tNo\t-\t\nExample Response JSON\n{\n  \"entries\": [\n    {\n      \"oplogIndex\": 0,\n      \"entry\": {\n        \"type\": \"Create\",\n        \"timestamp\": \"2019-08-24T14:15:22Z\",\n        \"workerId\": {\n          \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n          \"workerName\": \"string\"\n        },\n        \"componentVersion\": 0,\n        \"args\": [\n          \"string\"\n        ],\n        \"env\": {\n          \"property1\": \"string\",\n          \"property2\": \"string\"\n        },\n        \"projectId\": \"5a8591dd-4039-49df-9202-96385ba3eff8\",\n        \"createdBy\": \"string\",\n        \"wasiConfigVars\": [\n          {\n            \"key\": \"string\",\n            \"value\": \"string\"\n          }\n        ],\n        \"parent\": {\n          \"componentId\": \"616ccd92-d666-4180-8349-8d125b269fac\",\n          \"workerName\": \"string\"\n        },\n        \"componentSize\": 0,\n        \"initialTotalLinearMemorySize\": 0,\n        \"initialActivePlugins\": [\n          {\n            \"installationId\": \"7a1bf939-4d70-4439-9ced-a3dbbce12bd7\",\n            \"pluginName\": \"string\",\n            \"pluginVersion\": \"string\",\n            \"registered\": true,\n            \"parameters\": {\n              \"property1\": \"string\",\n              \"property2\": \"string\"\n            }\n          }\n        ]\n      }\n    }\n  ],\n  \"next\": {\n    \"nextOplogIndex\": 0,\n    \"currentComponentVersion\": 0\n  },\n  \"firstIndexInChunk\": 0,\n  \"lastIndex\": 0\n}","list-files-in-a-worker#List files in a worker":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/files/{file_name}\tGET\tYes\t\nExample Response JSON\n{\n  \"nodes\": [\n    {\n      \"name\": \"string\",\n      \"lastModified\": 0,\n      \"kind\": \"directory\",\n      \"permissions\": \"read-only\",\n      \"size\": 0\n    }\n  ]\n}","get-contents-of-a-file-in-a-worker#Get contents of a file in a worker":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/file-contents/{file_name}\tGET\tYes\t\nResponse Body: WASM Binary File","activate-a-plugin#Activate a plugin":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/activate-plugin\tPOST\tYes\t\nThe plugin must be one of the installed plugins for the worker's current component version.Query Parameters\nName\tType\tRequired\tDescription\tplugin-installation-id\tstring\tYes\t-\t\nExample Response JSON\n{}","deactivate-a-plugin#Deactivate a plugin":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/deactivate-plugin\tPOST\tYes\t\nThe plugin must be one of the installed plugins for the worker's current component version.Query Parameters\nName\tType\tRequired\tDescription\tplugin-installation-id\tstring\tYes\t-\t\nExample Response JSON\n{}","revert-a-worker#Revert a worker":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/revert\tPOST\tYes\t\nReverts a worker by undoing either the last few invocations or the last few recorded oplog entries.Example Request JSON\n{\n  \"type\": \"revertToOplogIndex\",\n  \"lastOplogIndex\": 0\n}\nExample Response JSON\n{}","cancels-a-pending-invocation-if-it-has-not-started-yet#Cancels a pending invocation if it has not started yet":"Path\tMethod\tProtected\t/v1/components/{component_id}/workers/{worker_name}/invocations/{idempotency_key}\tDELETE\tYes\t\nThe invocation to be cancelled is identified by the idempotency key passed to the invoke API.Example Response JSON\n{\n  \"canceled\": true\n}","worker-api-errors#Worker API Errors":"Status Code\tDescription\tBody\t400\t\t{\"errors\":[\"string\"]}\t401\t\t{\"error\":\"string\"}\t403\t\t{\"error\":\"string\"}\t404\t\t{\"error\":\"string\"}\t409\t\t{\"error\":\"string\"}\t500\t\t{\"error\":\"string\",\"workerError\":{\"cause\":\"string\",\"stderr\":\"string\"}}"}},"/type-mapping":{"title":"Type mapping","data":{"":"The types used in the component's code are mapped to the types of Rib (WebAssembly value encoding or WAVE) and to JSON (when used in the invocation REST API). This page lists all the supported types and how they are mapped.","user-types-to-rib#User types to Rib":"This section describes how various types of the used programming language are mapping to types used by the Rib scripting language and the CLI invoke functions. These are WebAssembly component-model types, and their values are described using the WAVE (WebAssembly Value Encoding) format.\nThe following TypeScript types are supported:\nTypeScript type\tWIT type\tExample Rib value\tRemarks\tstring\tstring\t\"hello world\"\t\tboolean\tbool\ttrue, false\t\tnumber\tf64\t1234.0\t\tobject\trecord { ... }\t{ a: \"hello\", b: 1234 }\t\tMap<K, V>\tlist<tuple<K, V>>\t[(\"key1\", 100), (\"key2\", -2)]\t\tArray<T>\tlist<T>\t[\"one\", \"two\", \"three\"]\t\tInterface with value fields\trecord { ... }\t{ field1: \"value\", field2: 42 }\t\t{ tag: \"x\", val: T1 } | { tag: \"y\", val: T2 } | ...\tvariant { x(T1), y(T2), ... }\tx(\"hello\")\tThe val is optional, if missing it's a case without value\t\"x\" | \"y\" | ...\tenum { x, y, ... }\tx\t\tOther union\tvariant { ... }\tcase1(value)\tThe case names are case1, case2, etc. For example for `string\tnumber\tCustomRecordthere will becase1, case2andcase3`\ttuple\ttuple<...>\t(\"hello\", 1234, true)\t\tT | undefined\toption<T>\tsome(value), none\t\tT | null\toption<T>\tsome(value), none\t\tfield?: T\toption<T>\tsome(value), none\tOptional fields in records are mapped to options\tUInt8Array\tlist<u8>\t[104, 101, 108, 108, 111]\t\tInt8Array\tlist<s8>\t[-1, 0, 1]\t\tUInt16Array\tlist<u16>\t[65535, 0, 1]\t\tInt16Array\tlist<s16>\t[-32768, 0, 32767]\tUInt32Array\tlist<u32>\t[4294967295, 0, 1]\t\tInt32Array\tlist<s32>\t[-2147483648, 0, 2147483647]\t\tBigUint64Array\tlist<u64>\t[18446744073709551615, 0, 1]\t\t\tBigInt64Array\tlist<s64>\t[-9223372036854775808, 0, 9223372036854775807]\t\tFloat32Array\tlist<f32>\t[3.4028235e+38, 1.175494e-38, 0, -1.175494e-38, -3.4028235e+38]\t\tFloat64Array\tlist<f64>\t[1.7976931348623157e+308, 2.2250738585072014e-308, 0, -2.2250738585072014e-308, -1.7976931348623157e+308]\t\t\nThere are some special, Golem agent specific types that can be used in the agent constructor and methods as well:","unstructured-text#Unstructured text":"Unstructured text is an arbitrary string, optionally annotated with a language code, that is either passed directly to/from the agent, or as an URL reference. The agent can optionally specify the set of supported language codes.\nimport {\n  UnstructuredText,\n} from '@golemcloud/golem-ts-sdk';\nasync exampleMethod(\n    unstructuredTextWithLanguageCode: UnstructuredText<[\"en\"]>,\n): Promise<void> {\n    // ...\n}\nThe type parameter is optional; if missing, there will be no restrictions for the language of the text. It's possible\nto list multiple language codes that are accepted by the agent.The type itself represents either an inline string or a remote reference:\nexport type UnstructuredText<LC extends LanguageCode[] = []> =\n  | {\n      tag: 'url';\n      val: string;\n    }\n  | {\n      tag: 'inline';\n      val: string;\n      languageCode?: LC[number];\n    };","unstructured-binary#Unstructured binary":"Unstructured binary data is similar to unstructured text, but it is annotated (and restricted by) MIME types.\nimport {\n  UnstructuredText,\n} from '@golemcloud/golem-ts-sdk';\nasync exampleMethod(\n  unstructuredBinaryWithMimeType: UnstructuredBinary<['application/json']>,\n): Promise<void> {\n    // ...\n}\nThe type parameter specifies the set of allowed MIME types for the binary data.\nThe type itself represents either an inline byte array or a remote reference:\nexport type UnstructuredBinary<MT extends MimeType[]> =\n  | {\n      tag: 'url';\n      val: string;\n    }\n  | {\n      tag: 'inline';\n      val: Uint8Array;\n      mimeType?: MT[number];\n    };","multimodal-values#Multimodal values":"Agents can work with multimodal values as input or output. When defining a parameter or return value as multimodal, we define the possible data types that can be used in that position, and the actual values will be an arbitrary number of values of these types, in any combination.\nIn TypeScript, the Multimodal generic type can be used in both input and output position, where the type parameter is a union of all the possible types of the multimodal value. As there is no constraint on the number of values for each type, every parameter of the multimodal method is going to be an array of values of the corresponding type:\nasync exampleMethod(\n  input: Multimodal<MyStructuredData[] | UnstructuredText<['en', 'de']> | UnstructuredBinary<['image/jpeg', 'image/png']>>,\n): Promise<void> {\n  // ...\n}","rib-types-to-json#Rib types to JSON":"The invocation API uses a special JSON format to describe invocation parameters and results.When using the REST API, the JSON-encoded values must be extended with a JSON-encoded type information as well. This is described in details in the Invoke via HTTP page.The following sections define how each WASM type and it's corresponding WAVE value encoding is mapped to Golem's value JSON format.","primitive-types#Primitive types":"WIT type\tJSON type\tDescription\tbool\tJSON boolean\tPrimitive boolean type\tu8\tJSON number\tUnsigned 8-bit integer\ts8\tJSON number\tSigned 8-bit integer\tu16\tJSON number\tUnsigned 16-bit integer\ts16\tJSON number\tSigned 16-bit integer\tu32\tJSON number\tUnsigned 32-bit integer\ts32\tJSON number\tSigned 32-bit integer\tu64\tJSON number\tUnsigned 64-bit integer\ts64\tJSON number\tSigned 64-bit integer\tf32\tJSON number\t32-bit floating point number\tf64\tJSON number\t64-bit floating point number\tchar\tJSON number\tUTF-8 character\tstring\tJSON string\tString","tuples#Tuples":"The following WIT type:\ntuple<u32, string, char>\nis encoded in WAVE as\n(1234, \"hello world\", 'g')\nand in JSON as an array of the items:\n[1234, \"hello world\", 103]","lists#Lists":"The following WIT type:\nlist<string>\nis encoded in WAVE as\n[\"one\", \"two\", \"three\"]\nand in JSON as an array of the items:\n[\"one\", \"two\", \"three\"]","options#Options":"The following WIT type:\noption<string>\nis encoded in WAVE by one of the following:\n\"implicit some\", some(\"explicit some\"), none\nIn the JSON representation we use null to reprsent none and the inner value if defined:\n\"implicit some\"\nnull","results#Results":"For the following WIT type:\nresult<string, string>\nThe WAVE representation is\n\"implicit ok\", ok(\"explicit ok\"), err(\"explicit err\")\nThe result type is represented in JSON by an object with either an ok or an err field:\n{ \"ok\": \"explicit ok\" }\n{ \"err\": \"explicit err\" }\nIf the type is unit in the WIT definition, the JSON representation should use null:\nresult<_, string>\n{ \"ok\": null }","handles#Handles":"Handles are identifying resources and returned by invoking resource constructors through the Golem invocation API. Handles are represented as strings in the JSON format\nand they are not supported by WAVE.Handles must not be constructed by hand, just forwarded to method invocations as they were returned from the constructors.Example handle value in JSON representation:\n\"urn:worker:component-id/worker-name/resource-id\"","records#Records":"Records are a collection of named fields. The JSON representation uses the same names as they appear in the WIT definition:\nrecord {\n    a: string,\n    b: u32\n}\nAn example WAVE encoding for such a record is:\n{ a: \"hello\", b: 1234 }\nThe JSON representation is just an object with the same field names:\n{ \"a\": \"hello\", \"b\": 1234 }","variants#Variants":"Variants are encoded in JSON by an object with a single field, where the field's name matches one of the variant's cases:\nvariant allowed-destinations {\n    none,\n    any,\n    restricted(list<string>),\n}\nThe WAVE encoding for such a variant is\nnone, any, restricted([\"one\", \"two\", \"three\"])\nIn JSON the object's single field encodes the case, and the value is null if it has no inner value in the type:\n{ \"none\": null }\n{ \"any\": null }\n{ \"restricted\": [\"one\", \"two\", \"three\"] }","enums#Enums":"Enums are simply encoded by the case name as a JSON string.For example:\nenum {\n    low,\n    medium,\n    high\n}\nThe WAVE encoding for such an enum is:\nlow, medium high\nand in JSON:\n\"low\"\n\"medium\"\n\"high\"","flags#Flags":"Flags represent a set of selected values.Take the following example WIT type:\nflags allowed-methods {\n    get,\n    post,\n    put,\n    delete,\n}\nThe WAVE encoding lists zero or more elements of the flags within {}:\n{get, put}\nThe JSON representation is an array of the selected values, each represented by a string:\n[\"get\", \"put\"]"}},"/usage":{"title":"Usage","data":{"":"Learn about deploying, invoking and debugging agents, using the command line interface and more."}},"/concepts":{"title":"Concepts","data":{"":"This page will teach you how to think about Golem so you can build correct, reliable TypeScript agents. You'll find the core jargon, how execution actually works, what the runtime guarantees, and what still belongs in your code.","agents-briefly#Agents, Briefly":"On Golem, an agent is a durable, stateful unit of execution you write in TypeScript. You publish an Agent Type (a versioned definition of code + config). Each running instance of that type is an agent with its own durable state and identity. Agents talk to the outside world through capabilities you grant them: calling HTTP APIs, using tools (including MCP), or messaging other agents.","the-runtime-promise#The Runtime Promise":"While your code looks like straight-line TypeScript, the runtime quietly does a lot: it persists state and history, mediates external calls, guarantees agent-to-agent delivery, parks idle agents at zero compute, and records a full trace you can search and replay. The outcome is an agent that keeps its place, doesn't double-fire effects, and can explain itself after the fact.","terminology#Terminology":"Agent Type  Your versioned TypeScript definition for a class of agents.\nAgent  A running instance with its own durable state.\nCapability  A granted permission to call an API/tool or message another agent.\nMessage  A durable, once-delivered communication between agents, ordered per stream.\nEffect  An external side-effect (charge a card, post a webhook) issued via the runtime's I/O mediation.\nIdempotency key  A unique key the runtime automatically attaches to each outbound request so cooperative endpoints process the effect exactly once.\nCheckpoint (snapshot)  A durable save-point of agent state used for recovery and safe replay.\nDurable log (oplog)  An append-only record of inputs, messages, effects, and decisions, powering observability and replay.\nTrigger  How you start or talk to agents via platform APIs.\nScheduler  Places, suspends, and resumes agents across the cluster; enables suspend-to-zero.","the-lifecycle-from-trigger-to-completion#The Lifecycle: From Trigger to Completion":"Every interaction begins with a trigger. You create an agent or send a command to an existing one. The runtime loads its state and starts executing your TypeScript code.When you call an external API (say, to take a payment), the call goes through Golem's mediated I/O. Before anything leaves your process, the runtime records the intent in the durable log and adds an idempotency key to the request. If the downstream system is cooperativewhich most modern APIs areit will deduplicate on that key. When the response comes back, Golem commits the effect exactly once and takes a checkpoint.If the next step needs to waitperhaps for a human approval or a webhook callbackthe agent suspends. While parked, it consumes zero compute. The scheduler resumes the agent when the event arrives or a timer fires, and execution continues with state intact.If the node running your agent fails mid-execution, the scheduler detects the failure, restores state from the last checkpoint, and replays from there. Replay skips completed steps and reconciles already-committed effects, so you don't re-bill a customer or re-open a ticket. Finally, the agent either completes or waits for the next trigger.","a-simple-example-makes-this-concrete#A Simple Example Makes This Concrete:":"Order flow. Charge the card, then send the receipt. If email delivery fails after the charge succeeded, the runtime retries the \"send receipt\" step. The charge will not be executed againthe idempotency key and effect commit prevent iteven if the agent had crashed between the two steps.","semantics-you-can-rely-on#Semantics You Can Rely On":"","inside-the-runtime#Inside the Runtime":"Execution is exactly-once with deterministic recovery from checkpoints and the durable log. Messages between agents are persisted and delivered once, preserving order per senderreceiver stream.","outside-the-runtime#Outside the Runtime":"External effects are exactly-once when you call through the mediated I/O. Golem automatically attaches an idempotency key and commits effects atomically with the log. On replay, Golem consults prior commits and downstream receipts to avoid re-doing work. For endpoints that don't support idempotency, you can still wrap them behind a thin service that does.","suspend--resume#Suspend & Resume":"Agents can wait minutes or months without burning CPU. Resumes are instant, with full context.","upgrades#Upgrades":"Agent Types are versioned. You can run versions side-by-side, route new creations to the new version, and migrate live agents forward without downtime.","observability--replay#Observability & Replay":"Every prompt, tool call, message, and effect is recorded. You can search the trace and replay to reproduce behavior without re-firing effects. Snapshots let you mark \"known-good\" points and safely rewind or fork investigations.","state-what-lives-in-the-agent-vs-your-databases#State: What Lives in the Agent vs. Your Databases":"Keep live decision context in the agent: conversation history, in-flight workflow state, pointers to authoritative records, and results you'll immediately use. It's durable and consistent with execution; you don't write persistence code to keep it safe.Keep cold data in your existing stores: analytics, reporting, bulk queries, and compliance archives. Store stable identifiers in the agent and hydrate as needed.\nA good heuristic: what the agent needs to make its next decision belongs with the agent; everything else belongs where your organization already manages long-lived data.","human-in-the-loop#Human-in-the-Loop":"Agents can pause anywhere for a human decision. The wait is durable, with deadlines and fallbacks (auto-cancel, escalate, choose defaults). When the decision arrives, the runtime applies it exactly once, records it in the log, and continues. You don't need polling loops or extra schedulers.","resilience-and-retries#Resilience and Retries":"The runtime handles the gritty parts of distributed life: network blips, timeouts, 429s, and transient 5xx responses. Retries use back-off and jitter and are governed by policy at the Agent Type level.There's one area where your domain logic matters: semantic soft errors. If a downstream returns HTTP 200 but the body means \"try again later\" or \"needs human\", signal that explicitly in your code so the runtime can either retry it or branch to a HITL path. The runtime can only treat as retryable what you indicate is retryable.","security-isolation-and-audit#Security, Isolation, and Audit":"Agents run in strict isolation and can only use capabilities you grant. Those capabilities scope access to external APIs, tools, and other agents. Every access and effect is captured in the durable log for a clear audit trail.","scaling-and-availability#Scaling and Availability":"Idle agents scale to zero. The scheduler spreads active agents across the cluster for throughput and resumes parked agents on demand. If a node fails, agents that were hosted there are briefly unavailable while they're recovered; new agent creations and agents on other nodes continue uninterrupted. Recovery is automatic and state-correct.","responsibilities-the-runtime-vs-you#Responsibilities: The Runtime vs. You":"Golem guarantees: durable state and history, exactly-once messaging, exactly-once external effects via automatic idempotency keys, suspend/resume, side-by-side upgrades, and full observability with safe replay.You own: your domain logicmodeling state, deciding what constitutes a retryable condition vs. a human decision, scoping capabilities with least privilege, and setting timeouts/SLOs that reflect downstream reality. When an external API can't honor idempotency, add a thin faade that does; Golem will still mediate and log the effect.","more-details#More details":""}},"/develop/defining-components":{"title":"Defining Golem Components","data":{"creating-a-project#Creating a project":"Golem's command line interface provides a set of predefined, Golem-specific templates to choose from as a starting point.\nTo get started from scratch, first create a new application using the TS template:\ngolem app new my-app ts\ncd my-app\nAn application can consist of multiple components. Add a new component by choosing from one of the available templates. To see the list of available templates, run:\ngolem component new\nThen create a new component using the chosen template:\ngolem component new ts my:component","defining-agents#Defining agents":"Defining Golem agents is done using the Golem SDK, which is included in all the templates provided by golem.\nAn agent is a TypeScript class that extends BaseAgent and has the @agent decorator:\nimport {\n    BaseAgent,\n    agent,\n    description,\n    prompt\n} from '@golemcloud/golem-ts-sdk';\n@agent\nclass MyAgent extends BaseAgent {\n    // ...\n}\nA component must define at least one agent, but can also define multiple ones.","agent-constructors#Agent constructors":"Every agent must define a constructor with an arbitrary number of parameters. These parameters form the agent identifier. Every possible parameter value combination identifies a particular agent instance.For example, an agent working on a particular user's particular request could be defined as:\n@agent()\nclass RequestHandler extends BaseAgent {\n    private readonly userId: string;\n    private readonly requestId: string;\n    constructor(userId: string, requestId: string) {\n        super();\n        this.userId = userId;\n        this.requestId = requestId;\n    }\n}\nAn agent with a constructor like this can be identified by request-handler(\"user-123\", \"request-456\").\nNote that the agent name is converted to kebab-case (request-handler) when referred to in an agent identifier. This is due to some technical implementation details of the underlying Golem runtime. You can learn more about these mappings on the name mapping page.","agent-methods#Agent methods":"Every public method of an agent class is an agent method, which can be called by other remote agents, externally through Golem's invocation API, and can also be mapped to HTTP APIs.Agent methods can (and should) be also annotated with the @prompt and @description decorators:\nprompt should provide information for an external AI to understand what needs to be passed to the method as parameters\ndescription should be a human-readable description of what the method does\nThis metadata is stored in the Golem component and can be used when exposing the agents through MCP, for example.The following example shows the use of the decorators on a simple agent method:\n@agent()\ntype TaskDetails = // ...;\ntype RequestHandlerStatus = // ...;\nclass RequestHandler extends BaseAgent {\n    // ...\n    @prompt(\"Enter new details about the task\")\n    @description(\"Adds some more details to the request handler about the task being performed. The result is an update of the current status.\")\n   async addDetails(details: TaskDetails): Promise<RequestHandlerStatus> {\n       // ...\n   }\n}","supported-data-types#Supported data types":"The SDK supports a large variety of data types to be used in agent constructors and agent methods, both in parameter and return type position. When a type is not supported, it will report an error at compile time.Check the page about data type mapping to learn how each type is mapped to Rib (when calling the agent methods from the API gateway or the REPL) and JSON (when using the invocation API).","agent-configuration#Agent configuration":"It is often required to pass configuration values to agents when they are started.In general Golem supports three different ways of doing this:\nDefining a list of string arguments passed to the agent, available as command line arguments\nDefining a list of key-value pairs passed to the agent, available as environment variables.\nDefining dedicated configuration key-value pairs (experimental).","command-line-arguments-and-environment-variables#Command line arguments and environment variables":"Command line arguments and environment variables are accessible through the node:process module:\nimport { argv, env } from \"node:process\";\nEnvironment variables can be specified when an agent is explicitly created, but there are some environment variables that are always set by Golem:\nGOLEM_AGENT_ID - the ID of the agent\nGOLEM_AGENT_TYPE - the agent type (first part of the agent ID)\nGOLEM_COMPONENT_ID - the ID of the agent's component\nGOLEM_COMPONENT_VERSION - the version of the component used for this agent\nIn addition to these, when using Agent to Agent communication, agents created by remote calls inherit the environment variables of the caller.This feature makes environment variables a good fit for passing configuration such as hostnames, ports, or access tokens to trees of agents.","default-environment-variables#Default environment variables":"It is possible to define default environment values and config key-value pairs for a component using the app manifest. These values are automatically set for each agent created from the component, but can be overridden when creating the agent.To set component level environment variables, use the env section of the golem.yaml:\ncomponents:\n    my:component:\n        env:\n            MY_ENV_VAR: \"some value\"\n            ANOTHER_ENV_VAR: \"another value\""}},"/develop/transactions":{"title":"High level transactions","data":{"":"On top of the durability controls and retry controls, the SDKs also provide high level functions for defining transactions supporting compensation actions in case of getting reverted.Although Golem's automatic retry policies and low-level atomic regions provide a lot of power automatically, many times a set of external operations such as HTTP requests needs to be executed transactionally; if one of the operations fails, the whole transaction need to be rolled back by executing some compensation actions.The SDK provides support for two different types of transactions:\nfallible transactions are only dealing with domain errors\ninfallible transactions must always succeed, and Golem applies its active retry policy to it","fallible-transactions#Fallible transactions":"Many times external operations (such as HTTP calls to remote hosts) need to be executed transactionally. If some operations failed, the transaction needs to be rolled back; compensation actions need to undo whatever the already successfully performed operations did.A fallible transaction only deals with domain errors. Within the transaction every operation that succeeds gets recorded. If an operation fails, all the recorded operations get compensated in reverse order before the transaction block returns with a failure.\nA fallible transaction can be executed using the fallibleTransaction function, by passing a closure that can\nexecute operations on the open transaction (see below).","infallible-transactions#Infallible transactions":"An infallible transaction must always succeed; in case of a failure or interruption, it gets retried. If there is a domain error, the compensation actions are executed before the retry.\nAn infallible transaction can be executed using the infallibleTransaction function, by passing a closure that\ncan execute operations on the open transaction (see below).","operations#Operations":"Both transaction types require the definition of operations.It is defined with the following interface:\n/**\n* Represents an atomic operation of the transaction which has a rollback action.\n*\n* Implement this interface and use it within a `transaction` block.\n* Operations can also be constructed from closures using `operation`.\n*/\nexport interface Operation<In, Out, Err> {\n/**\n * The action to execute.\n * @param input - The input to the operation.\n * @returns The result of the operation.\n */\nexecute(input: In): Result<Out, Err>\n/**\n * Compensation to perform in case of failure.\n * Compensations should not throw errors.\n * @param input - The input to the operation.\n * @param result - The result of the operation.\n * @returns The result of the compensation.\n */\ncompensate(input: In, result: Out): Result<void, Err>\n}\nThere are two ways to define an operation:\nImplement the Operation interface manually\nUse the operation function to create an operation from a pair of closures\nexport declare function operation<In, Out, Err>(\n    execute: (input: In) => Result<Out, Err>,\n    compensate: (input: In, result: Out) => Result<void, Err>\n): Operation<In, Out, Err>","executing-operations#Executing operations":"The defined operations can be executed in fallible or infallible mode:\nimport { fallibleTransaction, infallibleTransaction, operation, Result } from \"@golemcloud/golem-ts-sdk\"\n// example operation with compensation\nconst op = operation(\n  (idx: number) => {\n    // the operation / side effect\n    return Result.ok(\"id-\" + idx)\n  },\n  (id, idx) => {\n    // compensation\n    console.log(`reverting ${id}, ${idx}`)\n    return Result.unit()\n  }\n)\n// with fallibleTransaction errors have to be handled and propagated using the Result type\nconst resultFallible = fallibleTransaction(tx => {\n  return tx\n    .execute(op, 1)\n    .flatMap(firstId => tx.execute(op, 2).map(secondId => [firstId, secondId]))\n})\n// with infallibleTransaction no explicit error handling is needed, as it is handled by Golem retries\nconst resultInfallible = infallibleTransaction(tx => {\n  const firstId = tx.execute(op, 1)\n  const secondId = tx.execute(op, 1)\n  return [firstId, secondId]\n})"}},"/develop/rdbms":{"title":"Using Relational Databases","data":{"":"Golem provides an API to integrate with popular relational database systems from any of the supported languages.\nThe currently supported databases are:\nPostgreSQL\nMySQL\nSee the full API definition\ndeclare module 'golem:rdbms/types@0.0.1' {\n  export type Uuid = {\n    highBits: bigint;\n    lowBits: bigint;\n  };\n  export type IpAddress = {\n    tag: 'ipv4'\n    val: [number, number, number, number]\n  } |\n  {\n    tag: 'ipv6'\n    val: [number, number, number, number, number, number, number, number]\n  };\n  export type MacAddress = {\n    octets: [number, number, number, number, number, number];\n  };\n  export type Date = {\n    year: number;\n    month: number;\n    day: number;\n  };\n  export type Time = {\n    hour: number;\n    minute: number;\n    second: number;\n    nanosecond: number;\n  };\n  export type Timestamp = {\n    date: Date;\n    time: Time;\n  };\n  export type Timestamptz = {\n    timestamp: Timestamp;\n    offset: number;\n  };\n  export type Timetz = {\n    time: Time;\n    offset: number;\n  };\n}\ndeclare module 'golem:rdbms/postgres@0.0.1' {\n  import * as golemRdbms001Types from 'golem:rdbms/types@0.0.1';\n  export class LazyDbValue {\n    constructor(value: DbValue);\n    get(): DbValue;\n  }\n  export class LazyDbColumnType {\n    constructor(value: DbColumnType);\n    get(): DbColumnType;\n  }\n  export class DbResultStream {\n    getColumns(): DbColumn[];\n    getNext(): DbRow[] | undefined;\n  }\n  export class DbConnection {\n    static open(address: string): Result<DbConnection, Error>;\n    query(statement: string, params: DbValue[]): Result<DbResult, Error>;\n    queryStream(statement: string, params: DbValue[]): Result<DbResultStream, Error>;\n    execute(statement: string, params: DbValue[]): Result<bigint, Error>;\n    beginTransaction(): Result<DbTransaction, Error>;\n  }\n  export class DbTransaction {\n    query(statement: string, params: DbValue[]): Result<DbResult, Error>;\n    queryStream(statement: string, params: DbValue[]): Result<DbResultStream, Error>;\n    execute(statement: string, params: DbValue[]): Result<bigint, Error>;\n    commit(): Result<void, Error>;\n    rollback(): Result<void, Error>;\n  }\n  export type Date = golemRdbms001Types.Date;\n  export type Time = golemRdbms001Types.Time;\n  export type Timetz = golemRdbms001Types.Timetz;\n  export type Timestamp = golemRdbms001Types.Timestamp;\n  export type Timestamptz = golemRdbms001Types.Timestamptz;\n  export type Uuid = golemRdbms001Types.Uuid;\n  export type IpAddress = golemRdbms001Types.IpAddress;\n  export type MacAddress = golemRdbms001Types.MacAddress;\n  export type Error = {\n    tag: 'connection-failure'\n    val: string\n  } |\n  {\n    tag: 'query-parameter-failure'\n    val: string\n  } |\n  {\n    tag: 'query-execution-failure'\n    val: string\n  } |\n  {\n    tag: 'query-response-failure'\n    val: string\n  } |\n  {\n    tag: 'other'\n    val: string\n  };\n  export type Interval = {\n    months: number;\n    days: number;\n    microseconds: bigint;\n  };\n  export type Int4bound = {\n    tag: 'included'\n    val: number\n  } |\n  {\n    tag: 'excluded'\n    val: number\n  } |\n  {\n    tag: 'unbounded'\n  };\n  export type Int8bound = {\n    tag: 'included'\n    val: bigint\n  } |\n  {\n    tag: 'excluded'\n    val: bigint\n  } |\n  {\n    tag: 'unbounded'\n  };\n  export type Numbound = {\n    tag: 'included'\n    val: string\n  } |\n  {\n    tag: 'excluded'\n    val: string\n  } |\n  {\n    tag: 'unbounded'\n  };\n  export type Tsbound = {\n    tag: 'included'\n    val: Timestamp\n  } |\n  {\n    tag: 'excluded'\n    val: Timestamp\n  } |\n  {\n    tag: 'unbounded'\n  };\n  export type Tstzbound = {\n    tag: 'included'\n    val: Timestamptz\n  } |\n  {\n    tag: 'excluded'\n    val: Timestamptz\n  } |\n  {\n    tag: 'unbounded'\n  };\n  export type Datebound = {\n    tag: 'included'\n    val: Date\n  } |\n  {\n    tag: 'excluded'\n    val: Date\n  } |\n  {\n    tag: 'unbounded'\n  };\n  export type Int4range = {\n    start: Int4bound;\n    end: Int4bound;\n  };\n  export type Int8range = {\n    start: Int8bound;\n    end: Int8bound;\n  };\n  export type Numrange = {\n    start: Numbound;\n    end: Numbound;\n  };\n  export type Tsrange = {\n    start: Tsbound;\n    end: Tsbound;\n  };\n  export type Tstzrange = {\n    start: Tstzbound;\n    end: Tstzbound;\n  };\n  export type Daterange = {\n    start: Datebound;\n    end: Datebound;\n  };\n  export type EnumerationType = {\n    name: string;\n  };\n  export type Enumeration = {\n    name: string;\n    value: string;\n  };\n  export type Composite = {\n    name: string;\n    values: LazyDbValue[];\n  };\n  export type Domain = {\n    name: string;\n    value: LazyDbValue;\n  };\n  export type ValueBound = {\n    tag: 'included'\n    val: LazyDbValue\n  } |\n  {\n    tag: 'excluded'\n    val: LazyDbValue\n  } |\n  {\n    tag: 'unbounded'\n  };\n  export type ValuesRange = {\n    start: ValueBound;\n    end: ValueBound;\n  };\n  export type Range = {\n    name: string;\n    value: ValuesRange;\n  };\n  export type DbValue = {\n    tag: 'character'\n    val: number\n  } |\n  {\n    tag: 'int2'\n    val: number\n  } |\n  {\n    tag: 'int4'\n    val: number\n  } |\n  {\n    tag: 'int8'\n    val: bigint\n  } |\n  {\n    tag: 'float4'\n    val: number\n  } |\n  {\n    tag: 'float8'\n    val: number\n  } |\n  {\n    tag: 'numeric'\n    val: string\n  } |\n  {\n    tag: 'boolean'\n    val: boolean\n  } |\n  {\n    tag: 'text'\n    val: string\n  } |\n  {\n    tag: 'varchar'\n    val: string\n  } |\n  {\n    tag: 'bpchar'\n    val: string\n  } |\n  {\n    tag: 'timestamp'\n    val: Timestamp\n  } |\n  {\n    tag: 'timestamptz'\n    val: Timestamptz\n  } |\n  {\n    tag: 'date'\n    val: Date\n  } |\n  {\n    tag: 'time'\n    val: Time\n  } |\n  {\n    tag: 'timetz'\n    val: Timetz\n  } |\n  {\n    tag: 'interval'\n    val: Interval\n  } |\n  {\n    tag: 'bytea'\n    val: Uint8Array\n  } |\n  {\n    tag: 'json'\n    val: string\n  } |\n  {\n    tag: 'jsonb'\n    val: string\n  } |\n  {\n    tag: 'jsonpath'\n    val: string\n  } |\n  {\n    tag: 'xml'\n    val: string\n  } |\n  {\n    tag: 'uuid'\n    val: Uuid\n  } |\n  {\n    tag: 'inet'\n    val: IpAddress\n  } |\n  {\n    tag: 'cidr'\n    val: IpAddress\n  } |\n  {\n    tag: 'macaddr'\n    val: MacAddress\n  } |\n  {\n    tag: 'bit'\n    val: boolean[]\n  } |\n  {\n    tag: 'varbit'\n    val: boolean[]\n  } |\n  {\n    tag: 'int4range'\n    val: Int4range\n  } |\n  {\n    tag: 'int8range'\n    val: Int8range\n  } |\n  {\n    tag: 'numrange'\n    val: Numrange\n  } |\n  {\n    tag: 'tsrange'\n    val: Tsrange\n  } |\n  {\n    tag: 'tstzrange'\n    val: Tstzrange\n  } |\n  {\n    tag: 'daterange'\n    val: Daterange\n  } |\n  {\n    tag: 'money'\n    val: bigint\n  } |\n  {\n    tag: 'oid'\n    val: number\n  } |\n  {\n    tag: 'enumeration'\n    val: Enumeration\n  } |\n  {\n    tag: 'composite'\n    val: Composite\n  } |\n  {\n    tag: 'domain'\n    val: Domain\n  } |\n  {\n    tag: 'array'\n    val: LazyDbValue[]\n  } |\n  {\n    tag: 'range'\n    val: Range\n  } |\n  {\n    tag: 'null'\n  };\n  export type CompositeType = {\n    name: string;\n    attributes: [string, LazyDbColumnType][];\n  };\n  export type DomainType = {\n    name: string;\n    baseType: LazyDbColumnType;\n  };\n  export type RangeType = {\n    name: string;\n    baseType: LazyDbColumnType;\n  };\n  export type DbColumnType = {\n    tag: 'character'\n  } |\n  {\n    tag: 'int2'\n  } |\n  {\n    tag: 'int4'\n  } |\n  {\n    tag: 'int8'\n  } |\n  {\n    tag: 'float4'\n  } |\n  {\n    tag: 'float8'\n  } |\n  {\n    tag: 'numeric'\n  } |\n  {\n    tag: 'boolean'\n  } |\n  {\n    tag: 'text'\n  } |\n  {\n    tag: 'varchar'\n  } |\n  {\n    tag: 'bpchar'\n  } |\n  {\n    tag: 'timestamp'\n  } |\n  {\n    tag: 'timestamptz'\n  } |\n  {\n    tag: 'date'\n  } |\n  {\n    tag: 'time'\n  } |\n  {\n    tag: 'timetz'\n  } |\n  {\n    tag: 'interval'\n  } |\n  {\n    tag: 'bytea'\n  } |\n  {\n    tag: 'uuid'\n  } |\n  {\n    tag: 'xml'\n  } |\n  {\n    tag: 'json'\n  } |\n  {\n    tag: 'jsonb'\n  } |\n  {\n    tag: 'jsonpath'\n  } |\n  {\n    tag: 'inet'\n  } |\n  {\n    tag: 'cidr'\n  } |\n  {\n    tag: 'macaddr'\n  } |\n  {\n    tag: 'bit'\n  } |\n  {\n    tag: 'varbit'\n  } |\n  {\n    tag: 'int4range'\n  } |\n  {\n    tag: 'int8range'\n  } |\n  {\n    tag: 'numrange'\n  } |\n  {\n    tag: 'tsrange'\n  } |\n  {\n    tag: 'tstzrange'\n  } |\n  {\n    tag: 'daterange'\n  } |\n  {\n    tag: 'money'\n  } |\n  {\n    tag: 'oid'\n  } |\n  {\n    tag: 'enumeration'\n    val: EnumerationType\n  } |\n  {\n    tag: 'composite'\n    val: CompositeType\n  } |\n  {\n    tag: 'domain'\n    val: DomainType\n  } |\n  {\n    tag: 'array'\n    val: LazyDbColumnType\n  } |\n  {\n    tag: 'range'\n    val: RangeType\n  };\n  export type DbColumn = {\n    ordinal: bigint;\n    name: string;\n    dbType: DbColumnType;\n    dbTypeName: string;\n  };\n  /**\n   * A single row of values\n   */\n  export type DbRow = {\n    values: DbValue[];\n  };\n  export type DbResult = {\n    columns: DbColumn[];\n    rows: DbRow[];\n  };\n  export type Result<T, E> = { tag: 'ok', val: T } | { tag: 'err', val: E };\n}\ndeclare module 'golem:rdbms/mysql@0.0.1' {\n  import * as golemRdbms001Types from 'golem:rdbms/types@0.0.1';\n  export class DbResultStream {\n    getColumns(): DbColumn[];\n    getNext(): DbRow[] | undefined;\n  }\n  export class DbConnection {\n    static open(address: string): Result<DbConnection, Error>;\n    query(statement: string, params: DbValue[]): Result<DbResult, Error>;\n    queryStream(statement: string, params: DbValue[]): Result<DbResultStream, Error>;\n    execute(statement: string, params: DbValue[]): Result<bigint, Error>;\n    beginTransaction(): Result<DbTransaction, Error>;\n  }\n  export class DbTransaction {\n    query(statement: string, params: DbValue[]): Result<DbResult, Error>;\n    queryStream(statement: string, params: DbValue[]): Result<DbResultStream, Error>;\n    execute(statement: string, params: DbValue[]): Result<bigint, Error>;\n    commit(): Result<void, Error>;\n    rollback(): Result<void, Error>;\n  }\n  export type Date = golemRdbms001Types.Date;\n  export type Time = golemRdbms001Types.Time;\n  export type Timestamp = golemRdbms001Types.Timestamp;\n  export type Error = {\n    tag: 'connection-failure'\n    val: string\n  } |\n  {\n    tag: 'query-parameter-failure'\n    val: string\n  } |\n  {\n    tag: 'query-execution-failure'\n    val: string\n  } |\n  {\n    tag: 'query-response-failure'\n    val: string\n  } |\n  {\n    tag: 'other'\n    val: string\n  };\n  export type DbColumnType = {\n    tag: 'boolean'\n  } |\n  {\n    tag: 'tinyint'\n  } |\n  {\n    tag: 'smallint'\n  } |\n  {\n    tag: 'mediumint'\n  } |\n  {\n    tag: 'int'\n  } |\n  {\n    tag: 'bigint'\n  } |\n  {\n    tag: 'tinyint-unsigned'\n  } |\n  {\n    tag: 'smallint-unsigned'\n  } |\n  {\n    tag: 'mediumint-unsigned'\n  } |\n  {\n    tag: 'int-unsigned'\n  } |\n  {\n    tag: 'bigint-unsigned'\n  } |\n  {\n    tag: 'float'\n  } |\n  {\n    tag: 'double'\n  } |\n  {\n    tag: 'decimal'\n  } |\n  {\n    tag: 'date'\n  } |\n  {\n    tag: 'datetime'\n  } |\n  {\n    tag: 'timestamp'\n  } |\n  {\n    tag: 'time'\n  } |\n  {\n    tag: 'year'\n  } |\n  {\n    tag: 'fixchar'\n  } |\n  {\n    tag: 'varchar'\n  } |\n  {\n    tag: 'tinytext'\n  } |\n  {\n    tag: 'text'\n  } |\n  {\n    tag: 'mediumtext'\n  } |\n  {\n    tag: 'longtext'\n  } |\n  {\n    tag: 'binary'\n  } |\n  {\n    tag: 'varbinary'\n  } |\n  {\n    tag: 'tinyblob'\n  } |\n  {\n    tag: 'blob'\n  } |\n  {\n    tag: 'mediumblob'\n  } |\n  {\n    tag: 'longblob'\n  } |\n  {\n    tag: 'enumeration'\n  } |\n  {\n    tag: 'set'\n  } |\n  {\n    tag: 'bit'\n  } |\n  {\n    tag: 'json'\n  };\n  export type DbColumn = {\n    ordinal: bigint;\n    name: string;\n    dbType: DbColumnType;\n    dbTypeName: string;\n  };\n  /**\n   * Value descriptor for a single database value\n   */\n  export type DbValue = {\n    tag: 'boolean'\n    val: boolean\n  } |\n  {\n    tag: 'tinyint'\n    val: number\n  } |\n  {\n    tag: 'smallint'\n    val: number\n  } |\n  {\n    tag: 'mediumint'\n    val: number\n  } |\n  {\n    tag: 'int'\n    val: number\n  } |\n  {\n    tag: 'bigint'\n    val: bigint\n  } |\n  {\n    tag: 'tinyint-unsigned'\n    val: number\n  } |\n  {\n    tag: 'smallint-unsigned'\n    val: number\n  } |\n  {\n    tag: 'mediumint-unsigned'\n    val: number\n  } |\n  {\n    tag: 'int-unsigned'\n    val: number\n  } |\n  {\n    tag: 'bigint-unsigned'\n    val: bigint\n  } |\n  {\n    tag: 'float'\n    val: number\n  } |\n  {\n    tag: 'double'\n    val: number\n  } |\n  {\n    tag: 'decimal'\n    val: string\n  } |\n  {\n    tag: 'date'\n    val: Date\n  } |\n  {\n    tag: 'datetime'\n    val: Timestamp\n  } |\n  {\n    tag: 'timestamp'\n    val: Timestamp\n  } |\n  {\n    tag: 'time'\n    val: Time\n  } |\n  {\n    tag: 'year'\n    val: number\n  } |\n  {\n    tag: 'fixchar'\n    val: string\n  } |\n  {\n    tag: 'varchar'\n    val: string\n  } |\n  {\n    tag: 'tinytext'\n    val: string\n  } |\n  {\n    tag: 'text'\n    val: string\n  } |\n  {\n    tag: 'mediumtext'\n    val: string\n  } |\n  {\n    tag: 'longtext'\n    val: string\n  } |\n  {\n    tag: 'binary'\n    val: Uint8Array\n  } |\n  {\n    tag: 'varbinary'\n    val: Uint8Array\n  } |\n  {\n    tag: 'tinyblob'\n    val: Uint8Array\n  } |\n  {\n    tag: 'blob'\n    val: Uint8Array\n  } |\n  {\n    tag: 'mediumblob'\n    val: Uint8Array\n  } |\n  {\n    tag: 'longblob'\n    val: Uint8Array\n  } |\n  {\n    tag: 'enumeration'\n    val: string\n  } |\n  {\n    tag: 'set'\n    val: string\n  } |\n  {\n    tag: 'bit'\n    val: boolean[]\n  } |\n  {\n    tag: 'json'\n    val: string\n  } |\n  {\n    tag: 'null'\n  };\n  /**\n   * A single row of values\n   */\n  export type DbRow = {\n    values: DbValue[];\n  };\n  export type DbResult = {\n    columns: DbColumn[];\n    rows: DbRow[];\n  };\n  export type Result<T, E> = { tag: 'ok', val: T } | { tag: 'err', val: E };\n}","executing-sql-statements#Executing SQL statements":"To execute an SQL statement with golem-rdbms, first crete a db-connection resource and call execute on it:","mysql#MySQL":"import { DbConnection } from \"golem:rdbms/mysql@0.0.1\";\n// Connecting to the database called 'test' with user 'root'\nconst conn = DbConnection.open(\"mysql://root@localhost:3306/test\");\nconn.execute(\n  `CREATE TABLE IF NOT EXISTS test_users\n    (\n        user_id             varchar(25)    NOT NULL,\n        name                varchar(255)    NOT NULL,\n        created_on          timestamp NOT NULL DEFAULT NOW(),\n        PRIMARY KEY (user_id)\n          );`, [])\nThe functions in the golem:rdbms/mysql@0.0.1 module are not async. This is due to a limitation of the current Golem runtime, and are subject to change in future releases.","postgresql#PostgreSQL":"import { DbConnection } from \"golem:rdbms/postgres@0.0.1\";\n// Connecting to the database called 'test' with user 'user'\nconst conn = DbConnection.open(\"postgres://user@localhost:5432/test\");\nconn.execute(\n  `CREATE TABLE IF NOT EXISTS test_users\n    (\n        user_id             varchar(25)    NOT NULL,\n        name                varchar(255)    NOT NULL,\n        created_on          timestamp NOT NULL DEFAULT NOW(),\n        PRIMARY KEY (user_id)\n          );`, [])\nThe functions in the golem:rdbms/postgres@0.0.1 module are not async. This is due to a limitation of the current Golem runtime, and are subject to change in future releases.","api#API":"Additionally you can:\nquery executes a SQL statement and returns a result\nquery-stream executs a SQL statement and returns a streaming result\nbegin-transaction creates a transaction resource on which, in addition to the query and execute functions, there is also a commit and a rollback method."}},"/rib":{"title":"Rib","data":{"":"Rib is the language used by the API Gateway that enables users to write programs capable of manipulating worker responses, which are WebAssembly (WASM) values.Rib uses the WAVE (WebAssembly Value Encoding) syntax for encoding values.","rib-grammar#Rib Grammar":"rib-expr below defines the grammar of Rib.\nrib_expr          ::= rib_expr_untyped (\":\" type_name)?\nrib_expr_untyped  ::= simple_expr rib_expr_rest\nsimple_expr       ::= simple_expr_untyped (\":\" type_name)?\nsimple_expr_untyped ::=\n      list_comprehension\n    | list_reduce\n    | pattern_match\n    | let_binding\n    | conditional\n    | flag\n    | record\n    | code_block\n    | tuple\n    | sequence\n    | boolean_literal\n    | literal\n    | not\n    | option\n    | result\n    | identifier\n    | call\n    | signed_num\nrib_expr_rest       ::= binary_rest | method_invocation | select_field_rest | select_index_res | number_rest  |  range_rest\nselect_field_rest   ::=  (\".\" select_field)*\nbinary_rest         ::=  (binary_op simple_expr)*\nnumber_rest         ::=  \".\" fraction\nmethod_invocation   ::= \".\" call\ncall                ::= function_name (\"(\" argument (\",\" argument)* \")\")?\nfunction_name       ::= variant | enum | worker_function_call\nselect_index_rest   ::= (\"[\" select_index \"]\")*\nbinary_op           ::=  \">=\" | \"<=\" | \"==\" | \"<\" | \">\" | \"&&\" | \"||\" | \"+\" | \"-\" | \"*\" | \"/\"\nrange_rest          ::= \"..\" (\"=\"? pos_num | pos_num? )\nfraction            ::= digits (('e' | 'E') ('+' | '-')? digits)?\nlet_binding         ::= \"let\" let_variable (\":\" type_name)? \"=\" rib_expr\nconditional         ::= \"if\" rib_expr \"then\" rib_expr \"else\" rib_expr\nselection_expr      ::= select_field | select_index\nselect_field        ::= selection_base_expr \".\" identifier\nselect_index        ::= pos_num\nnested_indices      ::= \"[\" pos_num \"]\" (\",\" \"[\" pos_num \"]\")*\nflag                ::= \"{\" flag_names \"}\"\nflag_names          ::= flag_name (\",\" flag_name)*\nflag_name           ::= (letter | \"_\" | digit | \"-\")+\nrecord              ::= \"{\" record_fields \"}\"\nrecord_fields       ::= field (\",\" field)*\nfield               ::= field_key \":\" rib_expr\nfield_key           ::= (letter | \"_\" | digit | \"-\")+\ncode_block          ::= rib_expr (\";\" rib_expr)*\ncode_block_unit     ::= code_block \";\"\nselection_base_expr ::= select_index | select_field | identifier | sequence | tuple\ntuple               ::= \"(\"  ib_expr (\",\" rib_expr)* \")\"\nsequence            ::= \"[\"  rib_expr (\",\" rib_expr)* \"]\"\nenum                ::= identifier\nvariant             ::= identifier ( \"(\" rib_expr \")\" )   ?\nargument            ::= rib_expr\nlist_comprehension  ::= \"for\" identifier_text \"in\" expr \"{\"\n                           code_block_unit?\n                           \"yield\" expr \";\"\n                         \"}\"\nlist_reduce         ::= \"reduce\" identifier_text\",\" identifier_text \"in\" expr \"from\" expr \"{\"\n                       code_block_unit?\n                       \"yield\" expr \";\"\n                     \"}\"\ntext                ::= letter (letter | digit | \"_\" | \"-\")*\npos_num             ::= digit+\ndigits              ::= [0-9]+\nsigned_num          ::= (\"+\" | \"-\")? pos_num\nliteral             ::= \"\\\"\" (static_term | dynamic_term)* \"\\\"\"\nstatic_term         ::= (letter | space | digit | \"_\" | \"-\" | \".\" | \"/\" | \":\" | \"@\")+\ndynamic_term        ::= \"${\" rib_expr \"}\"\nboolean_literal     ::= \"true\" | \"false\"\nnot                 ::= \"!\" rib_expr\noption              ::= \"some\" \"(\" rib_expr \")\" | \"none\"\nresult              ::= \"ok\" \"(\" rib_expr \")\" | \"error\" \"(\" rib_expr \")\"\nidentifier          ::= any_text\nfunction_name       ::= variant | enum | instance | text\ninstance            ::= \"instance\"\nany_text            ::= letter (letter | digit | \"_\" | \"-\")*\ntype_name           := basic_type | list_type | tuple_type | option_type | result_type\nbasic_type          ::= \"bool\" | \"s8\" | \"u8\" | \"s16\" | \"u16\" | \"s32\" | \"u32\" | \"s64\" | \"u64\" | \"f32\" | \"f64\" | \"char\" | \"string\"\nlist_type           ::= \"list\" \"<\" (basic_type | list_type | tuple_type | option_type | result_type) \">\"\ntuple_type          ::= \"tuple\" \"<\" (basic_type | list_type | tuple_type | option_type | result_type) (\",\" (basic_type | list_type | tuple_type | option_type | result_type))* \">\"\noption_type         ::= \"option\" \"<\" (basic_type | list_type | tuple_type | option_type | result_type) \">\"\nresult_type         ::= \"result\" \"<\" (basic_type | list_type | tuple_type | option_type | result_type) \",\" (basic_type | list_type | tuple_type | option_type | result_type) \">\"\nThe grammar is mainly to give a high level overview of the syntax of Rib.The following sections show some examples of each construct.Rib scripts can be multiline, and it should be separated by ;.","return-type-of-a-rib-script#Return type of a Rib script":"The last expression in the Rib script is the return value of the script. The last line in Rib script\nshouldn't end with a ;, as this is a syntax error.Let's see how we can write Rib corresponding to the types supported by the WebAssembly Component Model","core-language-elements#Core Language Elements":"","identifier#Identifier":"foo\nHere foo is an identifier. Note that identifiers are not wrapped with quotes.Rib will fail at compilation if variable foo is not available in the context.This implies, if you are running Rib specifying a wasm component through api-gateway in golem, then Rib has the access to look at component metadata.\nIf Rib finds this variable foo in the component metadata,then it tries to infer its types.If such a variable is not present in the wasm component (i.e, you can cross check this in WIT file of the component),\nthen technically there are two possibilities. Rib will choose to fail the compilation or consider it as a global variable input.\nA global input is nothing but Rib expects foo to be passed in to the evaluator of Rib script (somehow).Since you are using Rib from the api-gateway part of golem the only valid global variable supported is request and nothing else.\nThis would mean, it will fail compilation.Example:\nmy-worker-function(request)\nrequest here is a global input and Rib knows the type of request if my-worker-function is a valid function in the component (which acts as dependencies to Rib)Here are a few other examples of identifiers:\nfoo-bar\nFOO-BAR\nMore on global inputs to follow.","primitives#Primitives":"https://component-model.bytecodealliance.org/design/wit.html#primitive-types","numbers#Numbers":"1\nYou can annotate a type to Rib expression to make it specific, otherwise, it will get inferred as u64\nfor a positive integer, s64 for a signed integer, and f64 for a floating point number.\n1: u64","boolean#Boolean":"true\nfalse","string#String":"\"foo\"","lists#Lists":"# Sequence of numbers\n[1, 2, 3]\nYou can annotate the type of the list as follows:\nlet x: list<s32> = [1, 2, 3];\n[\"foo\", \"bar\", \"baz\"]\n# Sequence of record\n[{a: \"foo\"}, {b : \"bar\"}]","options#Options":"Option in corresponding to WASM , which can take the shape of Some or None. This is similar to Option type in std Rust.An Option can be Some of a value, or None.\n some(1)\n none\nYou can annotate the type of option as follows, if needed.\nlet x: option<u32> = none;\nThe syntax is inspired from wasm wave.","results#Results":"Resultin Rib is WASM Result, which can take the shape of ok or err. This is similar to Result type in std Rust.A Result can be Ok of a value, or an Err of a value.\n ok(1)\n err(\"error\")\n{\n  \"user\": \"ok(Alice)\",\n  \"age\": 30u32\n}\nNote that there are various possibilities of result in Web Assembly component model.If there is no data associated with the error case, you can do the following:\nlet my-result: result<_, string> = err(\"foo\")\nmy-result\nIf there are no data associated with the success case, you can do the following:\nlet my-result: result<string> = ok(\"foo\")\nIf you don't care the type of success and error.\nlet my-result: result = ok(\"foo\")\nWhen using rib, we recommend using the mostly used pattern which is to know both the success and error case (i.e, result<u32, string>)","tuples#Tuples":"A tuple type is an ordered fixed length sequence of values of specified types. It is similar to a record,\nexcept that the fields are identified by their order instead of by names.\n(1, 20.1, \"foo\")\nThis is also equivalent to the following in Rib.\nYou can be specific about the types just like in any rib expression.\nlet my-tuple: tuple<u64, f64, string> = (1, 20.1, \"foo\");\nmy-tuple\nUnlike list, the values in a tuple can be of different types.Here is another example:\n(\"foo\", 1, {a: \"bar\"})","record#Record":"{ name: \"John\", age: 30 }\n{ city: \"New York\", population: 8000000 }\n{ name: \"John\", age: 30, { country: \"France\", capital: \"Paris\" } }\nThis is parsed as a WASM Record. The syntax is inspired from WASM-WAVE.Note that, sometimes you will need to annotate the type of the number. It depends on the compilation context.Note that keys are not considered as variables. Also note that keys in a WASM record don't have quotes. Example: {\"foo\" : \"bar\"} is wrong.","variants#Variants":"Let say your WIT file has the following variant\nvariant bid-result {\n   success,\n   failure(string),\n}\nbid: func() -> bid-result;\nprocess-result: func(res: bid-result) -> string\nThen, in Rib, all you need to is simply use the variant terms directly. Example:\nlet x = failure(\"its failed\");\nx\nYou can pattern match (more on this patter-match below) on variants as follows:\nlet x = failure(\"its failed\");\nlet result = match x { success => \"its success\", failure(msg) => msg }\nresult\nThis will return \"its failed\".Here is the example WIT file and the corresponding rib scripts that shows how to pass\nvariants as arguments to agent methods. More explanation on how to invoke agent methods using\nrib is explained further down below.\n  variant bid-result {\n    success(string),\n    failure(string)\n  }\n  handle: func(res: bid-result) -> string;\nlet agent = my-agent(\"something\");\nagent.handle(failure(\"it's failed\"));\nlet agent = my-agent(\"something\");\nagent.handle(success);\nlet agent = my-agent(\"something\");\nlet bid-result = worker.bid();\nlet result = agent.handle(bid-result);\nresult\nNote that rib script should have the dependency to the component that defines the variant.\nOtherwise, Rib will fail with compilation.\nfailure(\"its failed\")\n[invalid script] error in the following rib found at line 1, column 203\n`failure(\"its failed\")`\ncause: invalid function call `failure`\nunknown function\nIf Rib is used through API gateway and not directly, this dependency is already added automatically as you\nspecify component name when defining API definition.","enums#Enums":"Let's say your WIT file has the following enum types,\n  enum status {\n    backlog,\n    in-progress,\n    done,\n  }\n  enum priority {\n    low,\n    medium,\n    high,\n  }\nThen, in Rib, all you need to do is to simply specify the name of the term. Example by typing in backlog, it knows its an enum type\nwhich can be any of backlog, in-progress and done.\nlet my-status = backlog;\nlet my-priory = priority;\n{s: my-status, p: my-priority}\nYou can pattern match (more on this pattern-match below) on enum values as follows\nlet my-priority = low;\nlet result = match my-priority {\n  low => \"its low\",\n  medium => \"its medium\",\n  high => \"its high\"\n};\nresult\nThis will return the result \"its low\".Here is the example WIT file and the corresponding rib scripts that shows how to pass\nvariants as arguments to agent method. More explanation on how to invoke worker function using\nrib is explained further down below.\n  enum status {\n    backlog,\n    in-progress,\n    done,\n  }\n  enum priority {\n    low,\n    medium,\n    high,\n  }\n  process-user: func(status: status, priority: priority, user-id: string) -> string;\nlet agent = my-agent(\"something\");\nlet result = agent.process-user(backlog, low, \"jon\");\nresult\nlet agent = my-agent(\"something\");\nlet status = in-progress;\nlet priority = medium;\nlet result = agent.process-user(status, priority, \"jon\");\nresult\nNote that rib script should have the dependency to the component that defines the enum.\nOtherwise, Rib will fail with compilation.If Rib is used through API gateway and not directly, this dependency is already added automatically as you\nspecify component name when defining API definition.","flags#Flags":"{ Foo, Bar, Baz }\nThis is of a flag type.","expressions-and-syntax-features#Expressions and Syntax Features":"","assign-to-a-variable#Assign to a variable":"This can be done using let binding which we have already seen in the above examples\nlet x = 1;\nWe can annotate the type of the variable as well.\nlet x: u64 = 1;\nIf you are passing this variable to an agent method, then you may not need to specify the type of the variable.","string-interpolation-concatenation#String Interpolation (concatenation)":"This is similar to languages like scala where you start with ${ and end with }\nlet x = \"foo\";\nlet y = \"bar\";\nlet z = \"${x}-and-${y}\";\nEvaluating this Rib will result in \"foo-and-bar\". The type of z is a string.","selection-of-field#Selection of Field":"A field can be selected from an Rib expression if it is a Record type. For example, foo.user\nis a valid selection given foo is a variable that gets evaluated to a record value.\nlet foo = { name: \"John\", age: 30 };\nfoo.name","selection-of-index#Selection of Index":"This is selecting an index from a sequence value.\nlet x = [1, 2, 3];\nx[0]\nYou can also inline as given below\n[1, 2, 3][0]","comparison-boolean#Comparison (Boolean)":"let x: u8 = 1;\nlet y: u8 = 2;\nx == y\nSimilarly, we can use other comparison operators like >=, <=, ==, < etc.\nBoth operands should be a valid Rib code that points/evaluated to a number or string.","arithmetic#Arithmetic":"let x: u8 = 1;\nlet y: u8 = 2;\nx + y\n+, -, / and * are supported.","collections-and-control-structures#Collections and Control Structures":"","list-comprehension#List Comprehension":"let x = [\"foo\", \"bar\"];\n for p in x {\n   yield p;\n }","list-aggregation#List Aggregation":"let ages: list<u16> = [1, 2, 3];\n reduce z, a in ages from 0 {\n   yield z + a;\n }","ranges#Ranges":"Ranges can be right exclusive or right inclusive. The right exclusive range is denoted by .. and right inclusive range is denoted by ..=.\n1..10;\nlet initial: u32 = 1;\nlet final: u32 = 10;\nlet x = initial..final;\nfor i in x {\n  yield i\n}\nSimilarly, you can use ..= to include the last number in the range.\n1..=10;\nlet initial: u32 = 1;\nlet final: u32 = 10;\nlet x = initial..=final;\nfor i in x {\n  yield i\n}\nPlease note that, you may need to help Rib compiler with type annotations for the numbers involved in the range.\nThis depends on the context. We will improve these aspects as we go.You can also create infinite range, where you skip the right side of ..\n1..;\nHowever, note that as of now Rib interpreter (runtime) will spot any infinite loop and will throw an error.\nExample: The following will throw an error.\nlet x = 1:u8..;\nfor i in x {\n  yield i\n}\nHowever, you can use infinite ranges to select a segment of the list without worrying about the end index.\nlet x: list<u32> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nfor i in x[1..] {\n  yield i\n}","pattern-matching#Pattern Matching":"let res: result<str, str> = ok(\"foo\");\nmatch res {\n    ok(v) => v,\n    err(msg) => msg\n}\nThis would probably be your go-to construct when you are dealing with complex data structures like result or option or other custom variant (WASM Variant)\nthat comes out as the response of an agent method\n  let agent-result = my-agent.my-method(1, \"jon\");\n  match agent-result {\n     ok(x) => \"foo\",\n     err(msg) => \"error\"\n  }","exhaustive-pattern-matching#Exhaustive pattern matching":"If the pattern match is not exhaustive, then it will throw compilation errorsExample: The following pattern matching is invalid\n  match agent-result {\n    some(x) => \"found\",\n  }\nThis will result in following error:\nError: Non-exhaustive pattern match. The following patterns are not covered: `none`.\nTo ensure a complete match, add these patterns or cover them with a wildcard (`_`) or an identifier.\nNow, let's say your agent responded with a variant.\nNote on variant: A variant statement defines a new type where instances of the type match exactly one of the variants listed for the type.\nThis is similar to a \"sum\" type in algebraic datatype (or an enum in Rust if you're familiar with it).\nVariants can be thought of as tagged unions as well.","pattern-match-on-variants#Pattern Match on Variants":"Given you are using Rib through worker bridge, which knows about component metadata,\nthen, let's say we have a variant of type as given below responded from the agent, when invoking a function called foo:\nvariant my_variant {\n    bar( {a: u32,b: string }),\n    foo(list<string>),\n}\nthen, the following will work:\nlet x = foo(\"abc\");\nmatch x {\n  bar({a: _, b: _}) => \"success\",\n  foo(some_list) => some_list[0]\n}","variables-in-the-context-of-pattern-matching#Variables in the context of pattern matching":"In all of the above, there exist a variable in the context of pattern.\nExample x in ok(x) or msg in err(msg) or x in some(x) or x in bar(x) or x in foo(x).These variables are bound to the value that is being matched.Example, given the agent response is ok(1), the following match expression will result in 2.\n   let result = my-agent.my-method(\"foo\");\n   match result {\n    ok(x) => x + 1,\n    err(msg) => 0\n  }\nThe following match expression will result in \"c\", if the agent response was variant value foo([\"a\", \"b\", \"c\"]),\nand will result in \"a\" if it was variant value bar({a: 1, b: \"a\"}).\n  let result = my-agent.my-method();\n  match result {\n    bar(x) => x.b,\n    foo(x) => x[1]\n  }","wild-card-patterns#Wild card patterns":"In some of the above examples, the binding variables are unused. We can use _ as a wildcard pattern to indicate that we don't care about the value.\n  match response {\n    bar(_) => \"bar\",\n    foo(_) => \"foo\"\n  }","conditional-statement#Conditional Statement":"let id: u32 = 10;\n if id > 3 then \"higher\" else \"lower\"\nThe structure of the conditional statement is if <condition> then <then-rib-expr> else <else-rib-expr>,\nwhere condition-expr is an expr that should get evaluated to boolean.\nThe then-rib-expr or else-rib-expr can be an any valid rib code, which could be another if else itself\n let id: u32 = request.user.id;\n if id > 3 then \"higher\" else if id == 3 then \"equal\" else \"lower\"\nYou must ensure that the branches (then branch and else branch) resolve to the same type. Otherwise, Rib\nwill fail to compile.","external-interactions#External Interactions":"","http-request-input-and-field-selection#HTTP Request Input and Field Selection":"Rib is currently mainly used in worker-gateway which will allow us to expose HTTP APIs on top of worker functions.\nIf you are using Rib in the context of worker-gateway then\nyou can use the variable request in your Rib script, which allows you to access various parameters of an input HTTP request.\nIn other words, request is a global input to the Rib script when used in API definitions, and\nworker-gateway will ensure to pass the value of request to the rib evaluator internally.Please refer to worker-gateway documents for more details.request will hold all the details of an input HTTP request in gateway,\nsuch as headers, path, query parameters and body.","request-body-parameters#Request Body Parameters":"To select the body field in request,\nrequest.body.user","request-header-parameters#Request Header Parameters":"To select a header from the request\nrequest.headers.user","request-path-parameters#Request Path Parameters":"To select the value of a path variable in your HTTP request /v4/{user-id}/get-cart-contents\nrequest.path.user-id","request-query-parameters#Request Query Parameters":"To select the value of a query variable in your HTTP request /v4/{user-id}/get-cart-contents?{country}\nrequest.query.country\nThe request.path.* and request.headers.* will be inferred as string unless you specify it using type annotation.Example:\nlet user-id: u8 = request.path.user-id;\nTo select the value of a query variable in your HTTP request /v4/{user-id}/get-cart-contents?{country}\nlet country: string = request.query.country;","a-typical-rib-script-in-api-definition-worker-gateway#A typical Rib script in API definition (worker gateway)":"Here is a full example of a Rib script that looks up various elements in an HTTP request.Given the route is /v4/{user-id}/get-cart-contents?{country} , which is a POST request,\nwhich has a body, then the following Rib script can be valid, and has a dependency to a component\nthat has a function my-function that takes two arguments of type {foo: string, bar: string} and string\nlet user-id: u8 = request.path.user-id;\nlet country: string = request.query.country;\nlet input = request.body;\nlet agent = my-agent(\"my-worker-${user-id}\");\nlet result = agent.my-method(input, country);\nresult\nThis Rib script will be part of an API definition (please refer to worker-gateway for more details)\nWhen registering this API definition, it already keeps track of the requirements of the input HTTP request.\nIn this case, the input request is a POST request with a body, and the body is of type {foo: string, bar: string},\nand the path variable is user-id of type u8, and the query parameter is country of type string.Once the API is deployed and the API is invoked, worker gateway will validate the input request against these requirements,\nand if they don't satisfy, it results in a BadRequest error.Please note that the Rib language by itself does not support keywords such as request, path, body, or headers.\nThe above examples are valid only when using Rib through worker-gateway.\nIf a Rib script is evaluated in the context of an HTTP request, these values are available in the context of the Rib evaluator.Currently, there are two ways to use Rib in golem. One is worker-gateway\nand the other is golem REPL. In the case of REPL, request is not available, since we are not executing Rib in the context of an HTTP request.Here is an example of an invalid Rib script\nrequest\nrequest.body\nIn the above case, compiler is not able to infer the type of request or request.body\nas it is not passed as an argument to an agent method.","invoke-agent-methods#Invoke agent methods":"Rib is mainly used to write scripts to manipulate the input and call agent methods.\nRefer to the worker-gateway documentation for more on how you use Rib to invoke agent methods.\nThis is useful to expose some HTTP APIs on top of these agents running in the Golem platform, and you don't want to keep\nupdating or change the components and expose additional APIs, as you can write a simple Rib script to do the necessary changes to the input\nand pass it to the agent methods functions. Invoking functions is similar to any other languages.","agent-method-invocation#Agent method invocation":"let agent = my-agent(\"something\");\nlet result = agent.get-cart-contents();\nresult\nRib is evaluated in the context of a particular component (this is taken care by worker-gateway that it evaluates Rib in the context of a wasm component).In this script, first you create an instance (instance of an agent) using the agent type (my-agent) and specifying values for the constructor parameters. With this instance, the agent methods are available to call.","agent-method-invocation-with-arguments#Agent method invocation with arguments":"Let's say there exists a  function add-to-cart which takes a product as the argument, where product is a wasm record\nlet agent = my-agent(\"something\");\nlet product = {product-id: 1, quantity: 2, name: \"mac\"};\nagent.add-to-cart(input);\nSimilarly you can pass multiple arguments to the agent method and they should be separated by ,.Say you need to pass the username along with with the product details.\nlet agent = my-agent(\"something\");\nlet product = {product-id: 1, quantity: 2, name: \"mac\"};\nlet username = \"foo\";\nagent.add-to-cart(username, product);\nYou can inline the arguments as well.\nlet agent = my-agent(\"something\");\nlet product = {product-id: 1, quantity: 2, name: \"mac\"};\nagent.add-to-cart(\"foo\", {product-id: 1, quantity: 2, name: \"mac\"});","multiple-invocations#Multiple invocations":"Rib allows you to invoke a function multiple times, or invoke multiple functions across multiple agents in a single script.\nThat said, it is important to note that Rib by itself is not durable and is stateless. The next time you invoke Rib (through worker-gateway for example),\nthese functions will get executed on the agent again and doesn't cache any result in anyway.Let's say we want to accumulate the contents of a shopping cart from user-id 1 to user-id 5.\n  let agent = my-agent(\"something\");\n  let initial = 1: u64;\n  let final = 5: u64;\n  let range = initial..final;\n  let result = for i in range {\n     yield agent.get-cart-contents(\"user-id-${i}\");\n  };\n  result","type-inference#Type Inference":"Rib is mainly used to write script to manipulate the input and call agent methods. In this case, for the most part, most of the types\nwill be automatically inferred. Otherwise, there will be a compilation error, asking the developer to annotate the types and help the compiler.\nlet x: string = request.body;\nx\nSay the request body is a record in Json, as given below. Rib sees it as a WASM Record type.\n{\n  \"user\": \"Alice\",\n  \"age\": 30u32\n}\nThen we can use Rib language to select the field user, as it considers this request's body as a WASM Record type.\nlet x: string = request.body.user;\nx","limitations#Limitations":"We recommend the users of golem to not rely on Rib for complex business logic as of now.\nIt's better to write it in standard languages that works with golem such as Rust, Python etc,\nmaking sure your logic or workflow is durable. We will be expanding the usability and reliability of Rib as we go.","issues-and-trouble-shooting#Issues and Trouble Shooting":"If you bump into compilation errors, annotating the types will help the compiler to infer the types properly.\nIf you bump into internal runtime errors, please report to us and we will try to fix it as soon as possible.We are making improvements in this space continuously."}},"/why-golem":{"title":"Why Golem","data":{"why-golem#Why Golem?":"Because agents are distributed systems.Most \"agent frameworks\" stop at prompt chaining. Real agents run for minutes to months, cross many tools and APIs, pause for people, and must never lose state or double-fire.Golem is an agent-native runtime that gives you durability, exactly-once effects, full observability, and suspend-to-zero  without the need to build queues, schedulers, or idempotency plumbing.","what-you-get-day-one#What You Get (Day One)":"","production-guarantees-built-in#Production Guarantees Built In":"Durable state: After a crash or restart, an agent resumes at the last successful pointno lost context or rework.\nExactly-once external effects: Retries won't double-charge cards, re-open tickets, or post duplicate webhooks.\nDurable internal delivery: Agent-to-agent messages are persisted and delivered once.\nSuspend & resume: Park idle agents (human approval, scheduled wake, long waits) at zero compute; resume instantly.\nAutomatic recovery & back-off: Transient failures are retried to policy; agents are rescheduled on healthy nodes.\nIsolation & permissions: Per-agent sandboxes and scoped capabilities prevent cross-talk or privilege bleed.\nObservability with rewind: Inspect the full history of prompts, tools, and data and replay safelyno duplicate effects.\nZero-downtime upgrades: Run versions side-by-side or migrate live agents forward.","the-code-you-write-the-runtime-you-dont#The Code You Write; The Runtime You Don't":"Use normal TypeScript to write agents and tools. Beneath it, Golem runs a complete runtimepersistence, exactly-once I/O, observability, autoscaling, isolation, and safe upgradesso your agents survive reality without bespoke infra.","what-you-stop-building#What You Stop Building":"Durable queues & outboxes\nIdempotency keys & dedupe logic\nCron catch-ups & retry schedulers\nLong-poll loops & timeout workarounds\nAd-hoc audit logs & incident recon tooling\nDIY \"workflow engines\" glued to lambdas\nFrameworks chain steps; Golem makes those steps durable, replayable, and exactly-once.","where-golem-shines#Where Golem Shines":"","use-cases#Use Cases":"Human-in-the-Loop Workflows\nAgents pause for review, capture the outcome, and resume with full stateno repeated actions.\nIntelligent Incident Response\nInvestigate, coordinate remediation, and escalate without losing track or duplicating fixes.\nReliable Data & Transactions Across Systems\nSynchronize CRMs/ERPs/APIs/payments with exactly-once guarantees.\nPersonalized Content & Offers at Scale\nAssemble and deliver tailored experiences with no duplicates or misseseven during spikes.\nMulti-Agent Research & Analysis\nCollaborating agents that run for hours to weeks, preserving context and avoiding re-work.\nContinuous Risk Monitoring & Alerting\nReal-time detection and actions without false repeats or missed alerts.\nIf your workflows are long-running, stateful, cross many tools, or HITL, Golem turns fragile prototypes into production-grade agents.","is-golem-a-fit-for-you#Is Golem a Fit for You?":"","-strong-fit-if-you-need# Strong Fit If You Need:":"Agents that must never lose progress or repeat side-effects\nHITL pauses, external API waits, or long-tail tasks (minutes  months)\nAuditable execution with full traces of prompts, tools, and data\nMulti-agent coordination with guaranteed messaging\nTo ship now without building durable infra yourself","-probably-not-a-fit-right-now-if# Probably Not a Fit Right Now If:":"Your app is stateless or completes in a single request/response\nYou only need a prompt library or a light orchestration DSL and reliability doesn't matter to you\nYou require a programming language other than TypeScript today (more languages are on the way)\nYou already run on a durable runtime that guarantees exactly-once and you're satisfied with its ops/tooling\nOur goal is to help you decide quickly  even if the answer is \"not yet.\"","how-golem-fits-your-stack#How Golem Fits Your Stack":"Build agents and tools in TypeScript.\nGrant capabilities (APIs, tools, other agents).\nDeploy agent types to the runtime.\nTrigger via secure APIs; send commands or messages.\nObserve execution with searchable traces and safe replay.\nInterop: Agents call your services over HTTP under exactly-once mediation. Connect tools (including MCP) and other agents with durable delivery. Start with one use case; retire bespoke queues and schedulers over time.","why-a-runtime-not-just-a-library#Why a Runtime (Not Just a Library)?":"Libraries help you write flows; runtimes keep them correct under failures, retries, and upgrades.\nFailure semantics: Exactly-once effects and durable delivery are properties of the runtime, not application glue.\nState correctness: Snapshots + durable logs let agents resume exactly where they left off.\nOperate at scale: Millions of agents can suspend to zero and wake as events arrivewithout cost spikes.\nDebug the truth: Full, replayable traces beat partial logs stitched across services.\nIf you like, use your favorite agent libraries for control flow; but run them on Golem for durability and correctness.","what-changes-in-your-day-to-day#What Changes in Your Day-to-Day":"Fewer incidents about \"what ran twice?\" or \"where did we lose state?\"\nFaster iterationupgrade logic without draining in-flight agents\nStraight-line agent code instead of scattered jobs and compensations\nReal root-cause analysis at 2 a.m. with full, searchable history","faqs#FAQs":"Do I have to re-write everything?No. Start by running the stateful, failure-sensitive parts of your agents on Golem. Keep your existing APIs and data stores.What languages are supported?TypeScript today, with more languages on the way.How does Golem prevent duplicate effects?An I/O gateway mediates external calls with durable logs and idempotent commits to ensure exactly-once behavioreven under retries and failover.Can agents pause for humans or slow APIs?Yes. Agents suspend & resume with full state intact and zero compute while waiting.","next-steps#Next Steps":"Check the Quickstart guide to learn how to install and build your first Golem agent\nExplore the Develop section to learn in details how to write Golem agents\nThe Usage section contains detailed information about deploying, invoking and debugging agents, using the command line interface and more.\nAgents that don't forget. Actions that don't repeat.\nShip agents you can trustwithout rebuilding distributed systems infrastructure."}}}
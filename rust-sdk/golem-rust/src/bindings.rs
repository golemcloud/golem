// Generated by `wit-bindgen` 0.16.0. DO NOT EDIT!
pub mod golem {
    pub mod api {

        #[allow(clippy::all)]
        pub mod host {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
            pub type Uri = super::super::super::golem::rpc::types::Uri;
            pub type Duration = super::super::super::wasi::clocks::monotonic_clock::Duration;
            /// An index into the persistent log storing all performed operations of a worker
            pub type OplogIndex = u64;
            /// UUID
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Uuid {
                pub high_bits: u64,
                pub low_bits: u64,
            }
            impl ::core::fmt::Debug for Uuid {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Uuid")
                        .field("high-bits", &self.high_bits)
                        .field("low-bits", &self.low_bits)
                        .finish()
                }
            }
            /// Represents a Golem template
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct TemplateId {
                pub uuid: Uuid,
            }
            impl ::core::fmt::Debug for TemplateId {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("TemplateId")
                        .field("uuid", &self.uuid)
                        .finish()
                }
            }
            /// Represents a Golem worker
            #[derive(Clone)]
            pub struct WorkerId {
                pub template_id: TemplateId,
                pub worker_name: wit_bindgen::rt::string::String,
            }
            impl ::core::fmt::Debug for WorkerId {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("WorkerId")
                        .field("template-id", &self.template_id)
                        .field("worker-name", &self.worker_name)
                        .finish()
                }
            }
            /// A promise ID is a value that can be passed to an external Golem API to complete that promise
            /// from an arbitrary external source, while Golem workers can await for this completion.
            #[derive(Clone)]
            pub struct PromiseId {
                pub worker_id: WorkerId,
                pub oplog_idx: OplogIndex,
            }
            impl ::core::fmt::Debug for PromiseId {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("PromiseId")
                        .field("worker-id", &self.worker_id)
                        .field("oplog-idx", &self.oplog_idx)
                        .finish()
                }
            }
            /// Configures how the executor retries failures
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct RetryPolicy {
                /// The maximum number of retries before the worker becomes permanently failed
                pub max_attempts: u32,
                /// The minimum delay between retries (applied to the first retry)
                pub min_delay: Duration,
                /// The maximum delay between retries
                pub max_delay: Duration,
                /// Multiplier applied to the delay on each retry to implement exponential backoff
                pub multiplier: u32,
            }
            impl ::core::fmt::Debug for RetryPolicy {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("RetryPolicy")
                        .field("max-attempts", &self.max_attempts)
                        .field("min-delay", &self.min_delay)
                        .field("max-delay", &self.max_delay)
                        .field("multiplier", &self.multiplier)
                        .finish()
                }
            }
            /// Configurable persistence level for workers
            #[derive(Clone, Copy)]
            pub enum PersistenceLevel {
                PersistNothing,
                PersistRemoteSideEffects,
                Smart,
            }
            impl ::core::fmt::Debug for PersistenceLevel {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        PersistenceLevel::PersistNothing => {
                            f.debug_tuple("PersistenceLevel::PersistNothing").finish()
                        }
                        PersistenceLevel::PersistRemoteSideEffects => f
                            .debug_tuple("PersistenceLevel::PersistRemoteSideEffects")
                            .finish(),
                        PersistenceLevel::Smart => {
                            f.debug_tuple("PersistenceLevel::Smart").finish()
                        }
                    }
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub enum FilterComparator {
                Equal,
                NotEqual,
                GreaterEqual,
                Greater,
                LessEqual,
                Less,
            }
            impl ::core::fmt::Debug for FilterComparator {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        FilterComparator::Equal => {
                            f.debug_tuple("FilterComparator::Equal").finish()
                        }
                        FilterComparator::NotEqual => {
                            f.debug_tuple("FilterComparator::NotEqual").finish()
                        }
                        FilterComparator::GreaterEqual => {
                            f.debug_tuple("FilterComparator::GreaterEqual").finish()
                        }
                        FilterComparator::Greater => {
                            f.debug_tuple("FilterComparator::Greater").finish()
                        }
                        FilterComparator::LessEqual => {
                            f.debug_tuple("FilterComparator::LessEqual").finish()
                        }
                        FilterComparator::Less => f.debug_tuple("FilterComparator::Less").finish(),
                    }
                }
            }

            impl FilterComparator {
                pub(crate) unsafe fn _lift(val: u8) -> FilterComparator {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => FilterComparator::Equal,
                        1 => FilterComparator::NotEqual,
                        2 => FilterComparator::GreaterEqual,
                        3 => FilterComparator::Greater,
                        4 => FilterComparator::LessEqual,
                        5 => FilterComparator::Less,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub enum StringFilterComparator {
                Equal,
                NotEqual,
                Like,
                NotLike,
            }
            impl ::core::fmt::Debug for StringFilterComparator {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        StringFilterComparator::Equal => {
                            f.debug_tuple("StringFilterComparator::Equal").finish()
                        }
                        StringFilterComparator::NotEqual => {
                            f.debug_tuple("StringFilterComparator::NotEqual").finish()
                        }
                        StringFilterComparator::Like => {
                            f.debug_tuple("StringFilterComparator::Like").finish()
                        }
                        StringFilterComparator::NotLike => {
                            f.debug_tuple("StringFilterComparator::NotLike").finish()
                        }
                    }
                }
            }

            impl StringFilterComparator {
                pub(crate) unsafe fn _lift(val: u8) -> StringFilterComparator {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => StringFilterComparator::Equal,
                        1 => StringFilterComparator::NotEqual,
                        2 => StringFilterComparator::Like,
                        3 => StringFilterComparator::NotLike,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[repr(u8)]
            #[derive(Clone, Copy, Eq, PartialEq)]
            pub enum WorkerStatus {
                /// The worker is running an invoked function
                Running,
                /// The worker is ready to run an invoked function
                Idle,
                /// An invocation is active but waiting for something (sleeping, waiting for a promise)
                Suspended,
                /// The last invocation was interrupted but will be resumed
                Interrupted,
                /// The last invocation failed and a retry was scheduled
                Retrying,
                /// The last invocation failed and the worker can no longer be used
                Failed,
                /// The worker exited after a successful invocation and can no longer be invoked
                Exited,
            }
            impl ::core::fmt::Debug for WorkerStatus {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        WorkerStatus::Running => f.debug_tuple("WorkerStatus::Running").finish(),
                        WorkerStatus::Idle => f.debug_tuple("WorkerStatus::Idle").finish(),
                        WorkerStatus::Suspended => {
                            f.debug_tuple("WorkerStatus::Suspended").finish()
                        }
                        WorkerStatus::Interrupted => {
                            f.debug_tuple("WorkerStatus::Interrupted").finish()
                        }
                        WorkerStatus::Retrying => f.debug_tuple("WorkerStatus::Retrying").finish(),
                        WorkerStatus::Failed => f.debug_tuple("WorkerStatus::Failed").finish(),
                        WorkerStatus::Exited => f.debug_tuple("WorkerStatus::Exited").finish(),
                    }
                }
            }

            impl WorkerStatus {
                pub(crate) unsafe fn _lift(val: u8) -> WorkerStatus {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }

                    match val {
                        0 => WorkerStatus::Running,
                        1 => WorkerStatus::Idle,
                        2 => WorkerStatus::Suspended,
                        3 => WorkerStatus::Interrupted,
                        4 => WorkerStatus::Retrying,
                        5 => WorkerStatus::Failed,
                        6 => WorkerStatus::Exited,

                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }

            #[derive(Clone)]
            pub struct WorkerNameFilter {
                pub comparator: StringFilterComparator,
                pub value: wit_bindgen::rt::string::String,
            }
            impl ::core::fmt::Debug for WorkerNameFilter {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("WorkerNameFilter")
                        .field("comparator", &self.comparator)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct WorkerStatusFilter {
                pub comparator: FilterComparator,
                pub value: WorkerStatus,
            }
            impl ::core::fmt::Debug for WorkerStatusFilter {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("WorkerStatusFilter")
                        .field("comparator", &self.comparator)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct WorkerVersionFilter {
                pub comparator: FilterComparator,
                pub value: u64,
            }
            impl ::core::fmt::Debug for WorkerVersionFilter {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("WorkerVersionFilter")
                        .field("comparator", &self.comparator)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct WorkerCreatedAtFilter {
                pub comparator: FilterComparator,
                pub value: u64,
            }
            impl ::core::fmt::Debug for WorkerCreatedAtFilter {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("WorkerCreatedAtFilter")
                        .field("comparator", &self.comparator)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct WorkerEnvFilter {
                pub name: wit_bindgen::rt::string::String,
                pub comparator: StringFilterComparator,
                pub value: wit_bindgen::rt::string::String,
            }
            impl ::core::fmt::Debug for WorkerEnvFilter {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("WorkerEnvFilter")
                        .field("name", &self.name)
                        .field("comparator", &self.comparator)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum WorkerPropertyFilter {
                Name(WorkerNameFilter),
                Status(WorkerStatusFilter),
                Version(WorkerVersionFilter),
                CreatedAt(WorkerCreatedAtFilter),
                Env(WorkerEnvFilter),
            }
            impl ::core::fmt::Debug for WorkerPropertyFilter {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        WorkerPropertyFilter::Name(e) => f
                            .debug_tuple("WorkerPropertyFilter::Name")
                            .field(e)
                            .finish(),
                        WorkerPropertyFilter::Status(e) => f
                            .debug_tuple("WorkerPropertyFilter::Status")
                            .field(e)
                            .finish(),
                        WorkerPropertyFilter::Version(e) => f
                            .debug_tuple("WorkerPropertyFilter::Version")
                            .field(e)
                            .finish(),
                        WorkerPropertyFilter::CreatedAt(e) => f
                            .debug_tuple("WorkerPropertyFilter::CreatedAt")
                            .field(e)
                            .finish(),
                        WorkerPropertyFilter::Env(e) => {
                            f.debug_tuple("WorkerPropertyFilter::Env").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct WorkerAllFilter {
                pub filters: wit_bindgen::rt::vec::Vec<WorkerPropertyFilter>,
            }
            impl ::core::fmt::Debug for WorkerAllFilter {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("WorkerAllFilter")
                        .field("filters", &self.filters)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct WorkerAnyFilter {
                pub filters: wit_bindgen::rt::vec::Vec<WorkerAllFilter>,
            }
            impl ::core::fmt::Debug for WorkerAnyFilter {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("WorkerAnyFilter")
                        .field("filters", &self.filters)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct WorkerMetadata {
                pub worker_id: WorkerId,
                pub args: wit_bindgen::rt::vec::Vec<wit_bindgen::rt::string::String>,
                pub env: wit_bindgen::rt::vec::Vec<(
                    wit_bindgen::rt::string::String,
                    wit_bindgen::rt::string::String,
                )>,
                pub status: WorkerStatus,
                pub template_version: u64,
                pub retry_count: u64,
            }
            impl ::core::fmt::Debug for WorkerMetadata {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("WorkerMetadata")
                        .field("worker-id", &self.worker_id)
                        .field("args", &self.args)
                        .field("env", &self.env)
                        .field("status", &self.status)
                        .field("template-version", &self.template_version)
                        .field("retry-count", &self.retry_count)
                        .finish()
                }
            }

            #[derive(Debug)]
            #[repr(transparent)]
            pub struct GetWorkers {
                handle: wit_bindgen::rt::Resource<GetWorkers>,
            }

            impl GetWorkers {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: wit_bindgen::rt::Resource::from_handle(handle),
                    }
                }

                #[doc(hidden)]
                pub fn into_handle(self) -> u32 {
                    wit_bindgen::rt::Resource::into_handle(self.handle)
                }

                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    wit_bindgen::rt::Resource::handle(&self.handle)
                }
            }

            unsafe impl wit_bindgen::rt::WasmResource for GetWorkers {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();

                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "golem:api/host@0.2.0")]
                        extern "C" {
                            #[link_name = "[resource-drop]get-workers"]
                            fn drop(_: u32);
                        }

                        drop(_handle);
                    }
                }
            }

            impl GetWorkers {
                #[allow(unused_unsafe, clippy::all)]
                pub fn new(
                    template_id: TemplateId,
                    filter: Option<&WorkerAnyFilter>,
                    precise: bool,
                ) -> Self {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        let mut cleanup_list = Vec::new();
                        let TemplateId { uuid: uuid0 } = template_id;
                        let Uuid {
                            high_bits: high_bits1,
                            low_bits: low_bits1,
                        } = uuid0;
                        let (result14_0, result14_1, result14_2) = match filter {
                            Some(e) => {
                                let WorkerAnyFilter { filters: filters2 } = e;
                                let vec13 = filters2;
                                let len13 = vec13.len() as i32;
                                let layout13 =
                                    alloc::Layout::from_size_align_unchecked(vec13.len() * 8, 4);
                                let result13 = if layout13.size() != 0 {
                                    let ptr = alloc::alloc(layout13);
                                    if ptr.is_null() {
                                        alloc::handle_alloc_error(layout13);
                                    }
                                    ptr
                                } else {
                                    {
                                        ::core::ptr::null_mut()
                                    }
                                };
                                for (i, e) in vec13.into_iter().enumerate() {
                                    let base = result13 as i32 + (i as i32) * 8;
                                    {
                                        let WorkerAllFilter { filters: filters3 } = e;
                                        let vec12 = filters3;
                                        let len12 = vec12.len() as i32;
                                        let layout12 = alloc::Layout::from_size_align_unchecked(
                                            vec12.len() * 32,
                                            8,
                                        );
                                        let result12 = if layout12.size() != 0 {
                                            let ptr = alloc::alloc(layout12);
                                            if ptr.is_null() {
                                                alloc::handle_alloc_error(layout12);
                                            }
                                            ptr
                                        } else {
                                            {
                                                ::core::ptr::null_mut()
                                            }
                                        };
                                        for (i, e) in vec12.into_iter().enumerate() {
                                            let base = result12 as i32 + (i as i32) * 32;
                                            {
                                                match e {
                                                    WorkerPropertyFilter::Name(e) => {
                                                        *((base + 0) as *mut u8) = (0i32) as u8;
                                                        let WorkerNameFilter {
                                                            comparator: comparator4,
                                                            value: value4,
                                                        } = e;
                                                        *((base + 8) as *mut u8) =
                                                            (comparator4.clone() as i32) as u8;
                                                        let vec5 = value4;
                                                        let ptr5 = vec5.as_ptr() as i32;
                                                        let len5 = vec5.len() as i32;
                                                        *((base + 16) as *mut i32) = len5;
                                                        *((base + 12) as *mut i32) = ptr5;
                                                    }
                                                    WorkerPropertyFilter::Status(e) => {
                                                        *((base + 0) as *mut u8) = (1i32) as u8;
                                                        let WorkerStatusFilter {
                                                            comparator: comparator6,
                                                            value: value6,
                                                        } = e;
                                                        *((base + 8) as *mut u8) =
                                                            (comparator6.clone() as i32) as u8;
                                                        *((base + 9) as *mut u8) =
                                                            (value6.clone() as i32) as u8;
                                                    }
                                                    WorkerPropertyFilter::Version(e) => {
                                                        *((base + 0) as *mut u8) = (2i32) as u8;
                                                        let WorkerVersionFilter {
                                                            comparator: comparator7,
                                                            value: value7,
                                                        } = e;
                                                        *((base + 8) as *mut u8) =
                                                            (comparator7.clone() as i32) as u8;
                                                        *((base + 16) as *mut i64) =
                                                            wit_bindgen::rt::as_i64(value7);
                                                    }
                                                    WorkerPropertyFilter::CreatedAt(e) => {
                                                        *((base + 0) as *mut u8) = (3i32) as u8;
                                                        let WorkerCreatedAtFilter {
                                                            comparator: comparator8,
                                                            value: value8,
                                                        } = e;
                                                        *((base + 8) as *mut u8) =
                                                            (comparator8.clone() as i32) as u8;
                                                        *((base + 16) as *mut i64) =
                                                            wit_bindgen::rt::as_i64(value8);
                                                    }
                                                    WorkerPropertyFilter::Env(e) => {
                                                        *((base + 0) as *mut u8) = (4i32) as u8;
                                                        let WorkerEnvFilter {
                                                            name: name9,
                                                            comparator: comparator9,
                                                            value: value9,
                                                        } = e;
                                                        let vec10 = name9;
                                                        let ptr10 = vec10.as_ptr() as i32;
                                                        let len10 = vec10.len() as i32;
                                                        *((base + 12) as *mut i32) = len10;
                                                        *((base + 8) as *mut i32) = ptr10;
                                                        *((base + 16) as *mut u8) =
                                                            (comparator9.clone() as i32) as u8;
                                                        let vec11 = value9;
                                                        let ptr11 = vec11.as_ptr() as i32;
                                                        let len11 = vec11.len() as i32;
                                                        *((base + 24) as *mut i32) = len11;
                                                        *((base + 20) as *mut i32) = ptr11;
                                                    }
                                                }
                                            }
                                        }
                                        *((base + 4) as *mut i32) = len12;
                                        *((base + 0) as *mut i32) = result12 as i32;
                                        cleanup_list.extend_from_slice(&[(result12, layout12)]);
                                    }
                                }
                                cleanup_list.extend_from_slice(&[(result13, layout13)]);

                                (1i32, result13 as i32, len13)
                            }
                            None => (0i32, 0i32, 0i32),
                        };
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:api/host@0.2.0")]
                        extern "C" {
                            #[link_name = "[constructor]get-workers"]
                            fn wit_import(_: i64, _: i64, _: i32, _: i32, _: i32, _: i32) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i64, _: i64, _: i32, _: i32, _: i32, _: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import(
                            wit_bindgen::rt::as_i64(high_bits1),
                            wit_bindgen::rt::as_i64(low_bits1),
                            result14_0,
                            result14_1,
                            result14_2,
                            match precise {
                                true => 1,
                                false => 0,
                            },
                        );
                        for (ptr, layout) in cleanup_list {
                            if layout.size() != 0 {
                                alloc::dealloc(ptr, layout);
                            }
                        }
                        GetWorkers::from_handle(ret as u32)
                    }
                }
            }
            impl GetWorkers {
                #[allow(unused_unsafe, clippy::all)]
                pub fn get_next(&self) -> Option<wit_bindgen::rt::vec::Vec<WorkerMetadata>> {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        #[repr(align(4))]
                        struct RetArea([u8; 12]);
                        let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                        let ptr0 = ret_area.as_mut_ptr() as i32;
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:api/host@0.2.0")]
                        extern "C" {
                            #[link_name = "[method]get-workers.get-next"]
                            fn wit_import(_: i32, _: i32);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: i32) {
                            unreachable!()
                        }
                        wit_import((self).handle() as i32, ptr0);
                        let l1 = i32::from(*((ptr0 + 0) as *const u8));
                        match l1 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l2 = *((ptr0 + 4) as *const i32);
                                    let l3 = *((ptr0 + 8) as *const i32);
                                    let base27 = l2;
                                    let len27 = l3;
                                    let mut result27 = Vec::with_capacity(len27 as usize);
                                    for i in 0..len27 {
                                        let base = base27 + i * 64;
                                        let e27 = {
                                            let l4 = *((base + 0) as *const i64);
                                            let l5 = *((base + 8) as *const i64);
                                            let l6 = *((base + 16) as *const i32);
                                            let l7 = *((base + 20) as *const i32);
                                            let len8 = l7 as usize;
                                            let bytes8 =
                                                Vec::from_raw_parts(l6 as *mut _, len8, len8);
                                            let l9 = *((base + 24) as *const i32);
                                            let l10 = *((base + 28) as *const i32);
                                            let base14 = l9;
                                            let len14 = l10;
                                            let mut result14 = Vec::with_capacity(len14 as usize);
                                            for i in 0..len14 {
                                                let base = base14 + i * 8;
                                                let e14 = {
                                                    let l11 = *((base + 0) as *const i32);
                                                    let l12 = *((base + 4) as *const i32);
                                                    let len13 = l12 as usize;
                                                    let bytes13 = Vec::from_raw_parts(
                                                        l11 as *mut _,
                                                        len13,
                                                        len13,
                                                    );

                                                    wit_bindgen::rt::string_lift(bytes13)
                                                };
                                                result14.push(e14);
                                            }
                                            wit_bindgen::rt::dealloc(
                                                base14,
                                                (len14 as usize) * 8,
                                                4,
                                            );
                                            let l15 = *((base + 32) as *const i32);
                                            let l16 = *((base + 36) as *const i32);
                                            let base23 = l15;
                                            let len23 = l16;
                                            let mut result23 = Vec::with_capacity(len23 as usize);
                                            for i in 0..len23 {
                                                let base = base23 + i * 16;
                                                let e23 = {
                                                    let l17 = *((base + 0) as *const i32);
                                                    let l18 = *((base + 4) as *const i32);
                                                    let len19 = l18 as usize;
                                                    let bytes19 = Vec::from_raw_parts(
                                                        l17 as *mut _,
                                                        len19,
                                                        len19,
                                                    );
                                                    let l20 = *((base + 8) as *const i32);
                                                    let l21 = *((base + 12) as *const i32);
                                                    let len22 = l21 as usize;
                                                    let bytes22 = Vec::from_raw_parts(
                                                        l20 as *mut _,
                                                        len22,
                                                        len22,
                                                    );

                                                    (
                                                        wit_bindgen::rt::string_lift(bytes19),
                                                        wit_bindgen::rt::string_lift(bytes22),
                                                    )
                                                };
                                                result23.push(e23);
                                            }
                                            wit_bindgen::rt::dealloc(
                                                base23,
                                                (len23 as usize) * 16,
                                                4,
                                            );
                                            let l24 = i32::from(*((base + 40) as *const u8));
                                            let l25 = *((base + 48) as *const i64);
                                            let l26 = *((base + 56) as *const i64);

                                            WorkerMetadata {
                                                worker_id: WorkerId {
                                                    template_id: TemplateId {
                                                        uuid: Uuid {
                                                            high_bits: l4 as u64,
                                                            low_bits: l5 as u64,
                                                        },
                                                    },
                                                    worker_name: wit_bindgen::rt::string_lift(
                                                        bytes8,
                                                    ),
                                                },
                                                args: result14,
                                                env: result23,
                                                status: WorkerStatus::_lift(l24 as u8),
                                                template_version: l25 as u64,
                                                retry_count: l26 as u64,
                                            }
                                        };
                                        result27.push(e27);
                                    }
                                    wit_bindgen::rt::dealloc(base27, (len27 as usize) * 64, 8);

                                    result27
                                };
                                Some(e)
                            }
                            _ => wit_bindgen::rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Create a new promise
            pub fn golem_create_promise() -> PromiseId {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([u8; 32]);
                    let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                    let ptr0 = ret_area.as_mut_ptr() as i32;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "golem-create-promise"]
                        fn wit_import(_: i32);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = *((ptr0 + 0) as *const i64);
                    let l2 = *((ptr0 + 8) as *const i64);
                    let l3 = *((ptr0 + 16) as *const i32);
                    let l4 = *((ptr0 + 20) as *const i32);
                    let len5 = l4 as usize;
                    let bytes5 = Vec::from_raw_parts(l3 as *mut _, len5, len5);
                    let l6 = *((ptr0 + 24) as *const i64);
                    PromiseId {
                        worker_id: WorkerId {
                            template_id: TemplateId {
                                uuid: Uuid {
                                    high_bits: l1 as u64,
                                    low_bits: l2 as u64,
                                },
                            },
                            worker_name: wit_bindgen::rt::string_lift(bytes5),
                        },
                        oplog_idx: l6 as u64,
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Suspends execution until the given promise gets completed, and returns the payload passed to
            /// the promise completion.
            pub fn golem_await_promise(promise_id: &PromiseId) -> wit_bindgen::rt::vec::Vec<u8> {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([u8; 8]);
                    let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                    let PromiseId {
                        worker_id: worker_id0,
                        oplog_idx: oplog_idx0,
                    } = promise_id;
                    let WorkerId {
                        template_id: template_id1,
                        worker_name: worker_name1,
                    } = worker_id0;
                    let TemplateId { uuid: uuid2 } = template_id1;
                    let Uuid {
                        high_bits: high_bits3,
                        low_bits: low_bits3,
                    } = uuid2;
                    let vec4 = worker_name1;
                    let ptr4 = vec4.as_ptr() as i32;
                    let len4 = vec4.len() as i32;
                    let ptr5 = ret_area.as_mut_ptr() as i32;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "golem-await-promise"]
                        fn wit_import(_: i64, _: i64, _: i32, _: i32, _: i64, _: i32);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64, _: i64, _: i32, _: i32, _: i64, _: i32) {
                        unreachable!()
                    }
                    wit_import(
                        wit_bindgen::rt::as_i64(high_bits3),
                        wit_bindgen::rt::as_i64(low_bits3),
                        ptr4,
                        len4,
                        wit_bindgen::rt::as_i64(oplog_idx0),
                        ptr5,
                    );
                    let l6 = *((ptr5 + 0) as *const i32);
                    let l7 = *((ptr5 + 4) as *const i32);
                    let len8 = l7 as usize;
                    Vec::from_raw_parts(l6 as *mut _, len8, len8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Completes the given promise with the given payload. Returns true if the promise was completed, false
            /// if the promise was already completed. The payload is passed to the worker that is awaiting the promise.
            pub fn golem_complete_promise(promise_id: &PromiseId, data: &[u8]) -> bool {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    let PromiseId {
                        worker_id: worker_id0,
                        oplog_idx: oplog_idx0,
                    } = promise_id;
                    let WorkerId {
                        template_id: template_id1,
                        worker_name: worker_name1,
                    } = worker_id0;
                    let TemplateId { uuid: uuid2 } = template_id1;
                    let Uuid {
                        high_bits: high_bits3,
                        low_bits: low_bits3,
                    } = uuid2;
                    let vec4 = worker_name1;
                    let ptr4 = vec4.as_ptr() as i32;
                    let len4 = vec4.len() as i32;
                    let vec5 = data;
                    let ptr5 = vec5.as_ptr() as i32;
                    let len5 = vec5.len() as i32;

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "golem-complete-promise"]
                        fn wit_import(
                            _: i64,
                            _: i64,
                            _: i32,
                            _: i32,
                            _: i64,
                            _: i32,
                            _: i32,
                        ) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64, _: i64, _: i32, _: i32, _: i64, _: i32, _: i32) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(
                        wit_bindgen::rt::as_i64(high_bits3),
                        wit_bindgen::rt::as_i64(low_bits3),
                        ptr4,
                        len4,
                        wit_bindgen::rt::as_i64(oplog_idx0),
                        ptr5,
                        len5,
                    );
                    wit_bindgen::rt::bool_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Deletes the given promise
            pub fn golem_delete_promise(promise_id: &PromiseId) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    let PromiseId {
                        worker_id: worker_id0,
                        oplog_idx: oplog_idx0,
                    } = promise_id;
                    let WorkerId {
                        template_id: template_id1,
                        worker_name: worker_name1,
                    } = worker_id0;
                    let TemplateId { uuid: uuid2 } = template_id1;
                    let Uuid {
                        high_bits: high_bits3,
                        low_bits: low_bits3,
                    } = uuid2;
                    let vec4 = worker_name1;
                    let ptr4 = vec4.as_ptr() as i32;
                    let len4 = vec4.len() as i32;

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "golem-delete-promise"]
                        fn wit_import(_: i64, _: i64, _: i32, _: i32, _: i64);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64, _: i64, _: i32, _: i32, _: i64) {
                        unreachable!()
                    }
                    wit_import(
                        wit_bindgen::rt::as_i64(high_bits3),
                        wit_bindgen::rt::as_i64(low_bits3),
                        ptr4,
                        len4,
                        wit_bindgen::rt::as_i64(oplog_idx0),
                    );
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns a Golem worker URI that can be used to invoke a given function on the current worker
            pub fn get_self_uri(function_name: &str) -> Uri {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([u8; 8]);
                    let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                    let vec0 = function_name;
                    let ptr0 = vec0.as_ptr() as i32;
                    let len0 = vec0.len() as i32;
                    let ptr1 = ret_area.as_mut_ptr() as i32;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "get-self-uri"]
                        fn wit_import(_: i32, _: i32, _: i32);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: i32, _: i32) {
                        unreachable!()
                    }
                    wit_import(ptr0, len0, ptr1);
                    let l2 = *((ptr1 + 0) as *const i32);
                    let l3 = *((ptr1 + 4) as *const i32);
                    let len4 = l3 as usize;
                    let bytes4 = Vec::from_raw_parts(l2 as *mut _, len4, len4);
                    super::super::super::golem::rpc::types::Uri {
                        value: wit_bindgen::rt::string_lift(bytes4),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the current position in the persistent op log
            pub fn get_oplog_index() -> OplogIndex {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "get-oplog-index"]
                        fn wit_import() -> i64;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i64 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Makes the current worker travel back in time and continue execution from the given position in the persistent
            /// op log.
            pub fn set_oplog_index(oplog_idx: OplogIndex) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "set-oplog-index"]
                        fn wit_import(_: i64);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64) {
                        unreachable!()
                    }
                    wit_import(wit_bindgen::rt::as_i64(oplog_idx));
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Blocks the execution until the oplog has been written to at least the specified number of replicas,
            /// or the maximum number of replicas if the requested number is higher.
            pub fn oplog_commit(replicas: u8) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "oplog-commit"]
                        fn wit_import(_: i32);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32) {
                        unreachable!()
                    }
                    wit_import(wit_bindgen::rt::as_i32(replicas));
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Marks the beginning of an atomic operation.
            /// In case of a failure within the region selected by `mark-begin-operation` and `mark-end-operation`
            /// the whole region will be reexecuted on retry.
            /// The end of the region is when `mark-end-operation` is called with the returned oplog-index.
            pub fn mark_begin_operation() -> OplogIndex {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "mark-begin-operation"]
                        fn wit_import() -> i64;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i64 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Commits this atomic operation. After `mark-end-operation` is called for a given index, further calls
            /// with the same parameter will do nothing.
            pub fn mark_end_operation(begin: OplogIndex) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "mark-end-operation"]
                        fn wit_import(_: i64);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64) {
                        unreachable!()
                    }
                    wit_import(wit_bindgen::rt::as_i64(begin));
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Gets the current retry policy associated with the worker
            pub fn get_retry_policy() -> RetryPolicy {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([u8; 32]);
                    let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                    let ptr0 = ret_area.as_mut_ptr() as i32;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "get-retry-policy"]
                        fn wit_import(_: i32);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = *((ptr0 + 0) as *const i32);
                    let l2 = *((ptr0 + 8) as *const i64);
                    let l3 = *((ptr0 + 16) as *const i64);
                    let l4 = *((ptr0 + 24) as *const i32);
                    RetryPolicy {
                        max_attempts: l1 as u32,
                        min_delay: l2 as u64,
                        max_delay: l3 as u64,
                        multiplier: l4 as u32,
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Overrides the current retry policy associated with the worker. Following this call, `get-retry-policy` will return the
            /// new retry policy.
            pub fn set_retry_policy(new_retry_policy: RetryPolicy) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    let RetryPolicy {
                        max_attempts: max_attempts0,
                        min_delay: min_delay0,
                        max_delay: max_delay0,
                        multiplier: multiplier0,
                    } = new_retry_policy;

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "set-retry-policy"]
                        fn wit_import(_: i32, _: i64, _: i64, _: i32);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: i64, _: i64, _: i32) {
                        unreachable!()
                    }
                    wit_import(
                        wit_bindgen::rt::as_i32(max_attempts0),
                        wit_bindgen::rt::as_i64(min_delay0),
                        wit_bindgen::rt::as_i64(max_delay0),
                        wit_bindgen::rt::as_i32(multiplier0),
                    );
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Gets the worker's current persistence level.
            pub fn get_oplog_persistence_level() -> PersistenceLevel {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "get-oplog-persistence-level"]
                        fn wit_import() -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    let v0 = match ret {
                        0 => PersistenceLevel::PersistNothing,
                        1 => PersistenceLevel::PersistRemoteSideEffects,
                        n => {
                            debug_assert_eq!(n, 2, "invalid enum discriminant");
                            PersistenceLevel::Smart
                        }
                    };
                    v0
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Sets the worker's current persistence level. This can increase the performance of execution in cases where durable
            /// execution is not required.
            pub fn set_oplog_persistence_level(new_persistence_level: PersistenceLevel) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    let result0 = match new_persistence_level {
                        PersistenceLevel::PersistNothing => 0i32,
                        PersistenceLevel::PersistRemoteSideEffects => 1i32,
                        PersistenceLevel::Smart => 2i32,
                    };

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "set-oplog-persistence-level"]
                        fn wit_import(_: i32);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32) {
                        unreachable!()
                    }
                    wit_import(result0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Gets the current idempotence mode. See `set-idempotence-mode` for details.
            pub fn get_idempotence_mode() -> bool {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "get-idempotence-mode"]
                        fn wit_import() -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    wit_bindgen::rt::bool_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Sets the current idempotence mode. The default is true.
            /// True means side-effects are treated idempotent and Golem guarantees at-least-once semantics.
            /// In case of false the executor provides at-most-once semantics, failing the worker in case it is
            /// not known if the side effect was already executed.
            pub fn set_idempotence_mode(idempotent: bool) {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "set-idempotence-mode"]
                        fn wit_import(_: i32);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32) {
                        unreachable!()
                    }
                    wit_import(match idempotent {
                        true => 1,
                        false => 0,
                    });
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Generates an idempotency key. This operation will never be replayed 
            /// i.e. not only is this key generated, but it is persisted and committed, such that the key can be used in third-party systems (e.g. payment processing)
            /// to introduce idempotence.
            pub fn generate_idempotency_key() -> Uuid {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([u8; 16]);
                    let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                    let ptr0 = ret_area.as_mut_ptr() as i32;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "golem:api/host@0.2.0")]
                    extern "C" {
                        #[link_name = "generate-idempotency-key"]
                        fn wit_import(_: i32);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = *((ptr0 + 0) as *const i64);
                    let l2 = *((ptr0 + 8) as *const i64);
                    Uuid {
                        high_bits: l1 as u64,
                        low_bits: l2 as u64,
                    }
                }
            }
        }
    }
    pub mod rpc {

        #[allow(clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
            pub type NodeIndex = i32;
            #[derive(Clone)]
            pub enum WitNode {
                RecordValue(wit_bindgen::rt::vec::Vec<NodeIndex>),
                VariantValue((u32, Option<NodeIndex>)),
                EnumValue(u32),
                FlagsValue(wit_bindgen::rt::vec::Vec<bool>),
                TupleValue(wit_bindgen::rt::vec::Vec<NodeIndex>),
                ListValue(wit_bindgen::rt::vec::Vec<NodeIndex>),
                OptionValue(Option<NodeIndex>),
                ResultValue(Result<Option<NodeIndex>, Option<NodeIndex>>),
                PrimU8(u8),
                PrimU16(u16),
                PrimU32(u32),
                PrimU64(u64),
                PrimS8(i8),
                PrimS16(i16),
                PrimS32(i32),
                PrimS64(i64),
                PrimFloat32(f32),
                PrimFloat64(f64),
                PrimChar(char),
                PrimBool(bool),
                PrimString(wit_bindgen::rt::string::String),
            }
            impl ::core::fmt::Debug for WitNode {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        WitNode::RecordValue(e) => {
                            f.debug_tuple("WitNode::RecordValue").field(e).finish()
                        }
                        WitNode::VariantValue(e) => {
                            f.debug_tuple("WitNode::VariantValue").field(e).finish()
                        }
                        WitNode::EnumValue(e) => {
                            f.debug_tuple("WitNode::EnumValue").field(e).finish()
                        }
                        WitNode::FlagsValue(e) => {
                            f.debug_tuple("WitNode::FlagsValue").field(e).finish()
                        }
                        WitNode::TupleValue(e) => {
                            f.debug_tuple("WitNode::TupleValue").field(e).finish()
                        }
                        WitNode::ListValue(e) => {
                            f.debug_tuple("WitNode::ListValue").field(e).finish()
                        }
                        WitNode::OptionValue(e) => {
                            f.debug_tuple("WitNode::OptionValue").field(e).finish()
                        }
                        WitNode::ResultValue(e) => {
                            f.debug_tuple("WitNode::ResultValue").field(e).finish()
                        }
                        WitNode::PrimU8(e) => f.debug_tuple("WitNode::PrimU8").field(e).finish(),
                        WitNode::PrimU16(e) => f.debug_tuple("WitNode::PrimU16").field(e).finish(),
                        WitNode::PrimU32(e) => f.debug_tuple("WitNode::PrimU32").field(e).finish(),
                        WitNode::PrimU64(e) => f.debug_tuple("WitNode::PrimU64").field(e).finish(),
                        WitNode::PrimS8(e) => f.debug_tuple("WitNode::PrimS8").field(e).finish(),
                        WitNode::PrimS16(e) => f.debug_tuple("WitNode::PrimS16").field(e).finish(),
                        WitNode::PrimS32(e) => f.debug_tuple("WitNode::PrimS32").field(e).finish(),
                        WitNode::PrimS64(e) => f.debug_tuple("WitNode::PrimS64").field(e).finish(),
                        WitNode::PrimFloat32(e) => {
                            f.debug_tuple("WitNode::PrimFloat32").field(e).finish()
                        }
                        WitNode::PrimFloat64(e) => {
                            f.debug_tuple("WitNode::PrimFloat64").field(e).finish()
                        }
                        WitNode::PrimChar(e) => {
                            f.debug_tuple("WitNode::PrimChar").field(e).finish()
                        }
                        WitNode::PrimBool(e) => {
                            f.debug_tuple("WitNode::PrimBool").field(e).finish()
                        }
                        WitNode::PrimString(e) => {
                            f.debug_tuple("WitNode::PrimString").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub struct WitValue {
                pub nodes: wit_bindgen::rt::vec::Vec<WitNode>,
            }
            impl ::core::fmt::Debug for WitValue {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("WitValue")
                        .field("nodes", &self.nodes)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Uri {
                pub value: wit_bindgen::rt::string::String,
            }
            impl ::core::fmt::Debug for Uri {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Uri").field("value", &self.value).finish()
                }
            }
            #[derive(Clone)]
            pub enum RpcError {
                ProtocolError(wit_bindgen::rt::string::String),
                Denied(wit_bindgen::rt::string::String),
                NotFound(wit_bindgen::rt::string::String),
                RemoteInternalError(wit_bindgen::rt::string::String),
            }
            impl ::core::fmt::Debug for RpcError {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    match self {
                        RpcError::ProtocolError(e) => {
                            f.debug_tuple("RpcError::ProtocolError").field(e).finish()
                        }
                        RpcError::Denied(e) => f.debug_tuple("RpcError::Denied").field(e).finish(),
                        RpcError::NotFound(e) => {
                            f.debug_tuple("RpcError::NotFound").field(e).finish()
                        }
                        RpcError::RemoteInternalError(e) => f
                            .debug_tuple("RpcError::RemoteInternalError")
                            .field(e)
                            .finish(),
                    }
                }
            }
            impl ::core::fmt::Display for RpcError {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }

            impl std::error::Error for RpcError {}

            #[derive(Debug)]
            #[repr(transparent)]
            pub struct WasmRpc {
                handle: wit_bindgen::rt::Resource<WasmRpc>,
            }

            impl WasmRpc {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: wit_bindgen::rt::Resource::from_handle(handle),
                    }
                }

                #[doc(hidden)]
                pub fn into_handle(self) -> u32 {
                    wit_bindgen::rt::Resource::into_handle(self.handle)
                }

                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    wit_bindgen::rt::Resource::handle(&self.handle)
                }
            }

            unsafe impl wit_bindgen::rt::WasmResource for WasmRpc {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();

                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "golem:rpc/types@0.1.0")]
                        extern "C" {
                            #[link_name = "[resource-drop]wasm-rpc"]
                            fn drop(_: u32);
                        }

                        drop(_handle);
                    }
                }
            }

            impl WasmRpc {
                #[allow(unused_unsafe, clippy::all)]
                pub fn new(location: &Uri) -> Self {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        let Uri { value: value0 } = location;
                        let vec1 = value0;
                        let ptr1 = vec1.as_ptr() as i32;
                        let len1 = vec1.len() as i32;

                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.1.0")]
                        extern "C" {
                            #[link_name = "[constructor]wasm-rpc"]
                            fn wit_import(_: i32, _: i32) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import(ptr1, len1);
                        WasmRpc::from_handle(ret as u32)
                    }
                }
            }
            impl WasmRpc {
                #[allow(unused_unsafe, clippy::all)]
                pub fn invoke_and_await(
                    &self,
                    function_name: &str,
                    function_params: &[WitValue],
                ) -> Result<WitValue, RpcError> {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        let mut cleanup_list = Vec::new();

                        #[repr(align(4))]
                        struct RetArea([u8; 16]);
                        let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                        let vec0 = function_name;
                        let ptr0 = vec0.as_ptr() as i32;
                        let len0 = vec0.len() as i32;
                        let vec9 = function_params;
                        let len9 = vec9.len() as i32;
                        let layout9 = alloc::Layout::from_size_align_unchecked(vec9.len() * 8, 4);
                        let result9 = if layout9.size() != 0 {
                            let ptr = alloc::alloc(layout9);
                            if ptr.is_null() {
                                alloc::handle_alloc_error(layout9);
                            }
                            ptr
                        } else {
                            {
                                ::core::ptr::null_mut()
                            }
                        };
                        for (i, e) in vec9.into_iter().enumerate() {
                            let base = result9 as i32 + (i as i32) * 8;
                            {
                                let WitValue { nodes: nodes1 } = e;
                                let vec8 = nodes1;
                                let len8 = vec8.len() as i32;
                                let layout8 =
                                    alloc::Layout::from_size_align_unchecked(vec8.len() * 24, 8);
                                let result8 = if layout8.size() != 0 {
                                    let ptr = alloc::alloc(layout8);
                                    if ptr.is_null() {
                                        alloc::handle_alloc_error(layout8);
                                    }
                                    ptr
                                } else {
                                    {
                                        ::core::ptr::null_mut()
                                    }
                                };
                                for (i, e) in vec8.into_iter().enumerate() {
                                    let base = result8 as i32 + (i as i32) * 24;
                                    {
                                        match e {
                                            WitNode::RecordValue(e) => {
                                                *((base + 0) as *mut u8) = (0i32) as u8;
                                                let vec2 = e;
                                                let ptr2 = vec2.as_ptr() as i32;
                                                let len2 = vec2.len() as i32;
                                                *((base + 12) as *mut i32) = len2;
                                                *((base + 8) as *mut i32) = ptr2;
                                            }
                                            WitNode::VariantValue(e) => {
                                                *((base + 0) as *mut u8) = (1i32) as u8;
                                                let (t3_0, t3_1) = e;
                                                *((base + 8) as *mut i32) =
                                                    wit_bindgen::rt::as_i32(t3_0);
                                                match t3_1 {
                                                    Some(e) => {
                                                        *((base + 12) as *mut u8) = (1i32) as u8;
                                                        *((base + 16) as *mut i32) =
                                                            wit_bindgen::rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *((base + 12) as *mut u8) = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::EnumValue(e) => {
                                                *((base + 0) as *mut u8) = (2i32) as u8;
                                                *((base + 8) as *mut i32) =
                                                    wit_bindgen::rt::as_i32(e);
                                            }
                                            WitNode::FlagsValue(e) => {
                                                *((base + 0) as *mut u8) = (3i32) as u8;
                                                let vec4 = e;
                                                let len4 = vec4.len() as i32;
                                                let layout4 =
                                                    alloc::Layout::from_size_align_unchecked(
                                                        vec4.len() * 1,
                                                        1,
                                                    );
                                                let result4 = if layout4.size() != 0 {
                                                    let ptr = alloc::alloc(layout4);
                                                    if ptr.is_null() {
                                                        alloc::handle_alloc_error(layout4);
                                                    }
                                                    ptr
                                                } else {
                                                    {
                                                        ::core::ptr::null_mut()
                                                    }
                                                };
                                                for (i, e) in vec4.into_iter().enumerate() {
                                                    let base = result4 as i32 + (i as i32) * 1;
                                                    {
                                                        *((base + 0) as *mut u8) = (match e {
                                                            true => 1,
                                                            false => 0,
                                                        })
                                                            as u8;
                                                    }
                                                }
                                                *((base + 12) as *mut i32) = len4;
                                                *((base + 8) as *mut i32) = result4 as i32;
                                                cleanup_list
                                                    .extend_from_slice(&[(result4, layout4)]);
                                            }
                                            WitNode::TupleValue(e) => {
                                                *((base + 0) as *mut u8) = (4i32) as u8;
                                                let vec5 = e;
                                                let ptr5 = vec5.as_ptr() as i32;
                                                let len5 = vec5.len() as i32;
                                                *((base + 12) as *mut i32) = len5;
                                                *((base + 8) as *mut i32) = ptr5;
                                            }
                                            WitNode::ListValue(e) => {
                                                *((base + 0) as *mut u8) = (5i32) as u8;
                                                let vec6 = e;
                                                let ptr6 = vec6.as_ptr() as i32;
                                                let len6 = vec6.len() as i32;
                                                *((base + 12) as *mut i32) = len6;
                                                *((base + 8) as *mut i32) = ptr6;
                                            }
                                            WitNode::OptionValue(e) => {
                                                *((base + 0) as *mut u8) = (6i32) as u8;
                                                match e {
                                                    Some(e) => {
                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                        *((base + 12) as *mut i32) =
                                                            wit_bindgen::rt::as_i32(e);
                                                    }
                                                    None => {
                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                    }
                                                };
                                            }
                                            WitNode::ResultValue(e) => {
                                                *((base + 0) as *mut u8) = (7i32) as u8;
                                                match e {
                                                    Ok(e) => {
                                                        *((base + 8) as *mut u8) = (0i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *((base + 12) as *mut u8) =
                                                                    (1i32) as u8;
                                                                *((base + 16) as *mut i32) =
                                                                    wit_bindgen::rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *((base + 12) as *mut u8) =
                                                                    (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                    Err(e) => {
                                                        *((base + 8) as *mut u8) = (1i32) as u8;
                                                        match e {
                                                            Some(e) => {
                                                                *((base + 12) as *mut u8) =
                                                                    (1i32) as u8;
                                                                *((base + 16) as *mut i32) =
                                                                    wit_bindgen::rt::as_i32(e);
                                                            }
                                                            None => {
                                                                *((base + 12) as *mut u8) =
                                                                    (0i32) as u8;
                                                            }
                                                        };
                                                    }
                                                };
                                            }
                                            WitNode::PrimU8(e) => {
                                                *((base + 0) as *mut u8) = (8i32) as u8;
                                                *((base + 8) as *mut u8) =
                                                    (wit_bindgen::rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimU16(e) => {
                                                *((base + 0) as *mut u8) = (9i32) as u8;
                                                *((base + 8) as *mut u16) =
                                                    (wit_bindgen::rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimU32(e) => {
                                                *((base + 0) as *mut u8) = (10i32) as u8;
                                                *((base + 8) as *mut i32) =
                                                    wit_bindgen::rt::as_i32(e);
                                            }
                                            WitNode::PrimU64(e) => {
                                                *((base + 0) as *mut u8) = (11i32) as u8;
                                                *((base + 8) as *mut i64) =
                                                    wit_bindgen::rt::as_i64(e);
                                            }
                                            WitNode::PrimS8(e) => {
                                                *((base + 0) as *mut u8) = (12i32) as u8;
                                                *((base + 8) as *mut u8) =
                                                    (wit_bindgen::rt::as_i32(e)) as u8;
                                            }
                                            WitNode::PrimS16(e) => {
                                                *((base + 0) as *mut u8) = (13i32) as u8;
                                                *((base + 8) as *mut u16) =
                                                    (wit_bindgen::rt::as_i32(e)) as u16;
                                            }
                                            WitNode::PrimS32(e) => {
                                                *((base + 0) as *mut u8) = (14i32) as u8;
                                                *((base + 8) as *mut i32) =
                                                    wit_bindgen::rt::as_i32(e);
                                            }
                                            WitNode::PrimS64(e) => {
                                                *((base + 0) as *mut u8) = (15i32) as u8;
                                                *((base + 8) as *mut i64) =
                                                    wit_bindgen::rt::as_i64(e);
                                            }
                                            WitNode::PrimFloat32(e) => {
                                                *((base + 0) as *mut u8) = (16i32) as u8;
                                                *((base + 8) as *mut f32) =
                                                    wit_bindgen::rt::as_f32(e);
                                            }
                                            WitNode::PrimFloat64(e) => {
                                                *((base + 0) as *mut u8) = (17i32) as u8;
                                                *((base + 8) as *mut f64) =
                                                    wit_bindgen::rt::as_f64(e);
                                            }
                                            WitNode::PrimChar(e) => {
                                                *((base + 0) as *mut u8) = (18i32) as u8;
                                                *((base + 8) as *mut i32) =
                                                    wit_bindgen::rt::as_i32(e);
                                            }
                                            WitNode::PrimBool(e) => {
                                                *((base + 0) as *mut u8) = (19i32) as u8;
                                                *((base + 8) as *mut u8) = (match e {
                                                    true => 1,
                                                    false => 0,
                                                })
                                                    as u8;
                                            }
                                            WitNode::PrimString(e) => {
                                                *((base + 0) as *mut u8) = (20i32) as u8;
                                                let vec7 = e;
                                                let ptr7 = vec7.as_ptr() as i32;
                                                let len7 = vec7.len() as i32;
                                                *((base + 12) as *mut i32) = len7;
                                                *((base + 8) as *mut i32) = ptr7;
                                            }
                                        }
                                    }
                                }
                                *((base + 4) as *mut i32) = len8;
                                *((base + 0) as *mut i32) = result8 as i32;
                                cleanup_list.extend_from_slice(&[(result8, layout8)]);
                            }
                        }
                        let ptr10 = ret_area.as_mut_ptr() as i32;
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "golem:rpc/types@0.1.0")]
                        extern "C" {
                            #[link_name = "[method]wasm-rpc.invoke-and-await"]
                            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32) {
                            unreachable!()
                        }
                        wit_import(
                            (self).handle() as i32,
                            ptr0,
                            len0,
                            result9 as i32,
                            len9,
                            ptr10,
                        );
                        let l11 = i32::from(*((ptr10 + 0) as *const u8));
                        if layout9.size() != 0 {
                            alloc::dealloc(result9, layout9);
                        }
                        for (ptr, layout) in cleanup_list {
                            if layout.size() != 0 {
                                alloc::dealloc(ptr, layout);
                            }
                        }
                        match l11 {
                            0 => {
                                let e = {
                                    let l12 = *((ptr10 + 4) as *const i32);
                                    let l13 = *((ptr10 + 8) as *const i32);
                                    let base55 = l12;
                                    let len55 = l13;
                                    let mut result55 = Vec::with_capacity(len55 as usize);
                                    for i in 0..len55 {
                                        let base = base55 + i * 24;
                                        let e55 = {
                                            let l14 = i32::from(*((base + 0) as *const u8));
                                            let v54 = match l14 {
                                                0 => {
                                                    let e54 = {
                                                        let l15 = *((base + 8) as *const i32);
                                                        let l16 = *((base + 12) as *const i32);
                                                        let len17 = l16 as usize;

                                                        Vec::from_raw_parts(
                                                            l15 as *mut _,
                                                            len17,
                                                            len17,
                                                        )
                                                    };
                                                    WitNode::RecordValue(e54)
                                                }
                                                1 => {
                                                    let e54 = {
                                                        let l18 = *((base + 8) as *const i32);
                                                        let l19 =
                                                            i32::from(*((base + 12) as *const u8));

                                                        (l18 as u32, match l19 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l20 = *((base + 16) as *const i32);
                                            
                                            l20
                                          };
                                          Some(e)
                                        }
                                        _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                      })
                                                    };
                                                    WitNode::VariantValue(e54)
                                                }
                                                2 => {
                                                    let e54 = {
                                                        let l21 = *((base + 8) as *const i32);

                                                        l21 as u32
                                                    };
                                                    WitNode::EnumValue(e54)
                                                }
                                                3 => {
                                                    let e54 = {
                                                        let l22 = *((base + 8) as *const i32);
                                                        let l23 = *((base + 12) as *const i32);
                                                        let base25 = l22;
                                                        let len25 = l23;
                                                        let mut result25 =
                                                            Vec::with_capacity(len25 as usize);
                                                        for i in 0..len25 {
                                                            let base = base25 + i * 1;
                                                            let e25 = {
                                                                let l24 = i32::from(
                                                                    *((base + 0) as *const u8),
                                                                );

                                                                wit_bindgen::rt::bool_lift(
                                                                    l24 as u8,
                                                                )
                                                            };
                                                            result25.push(e25);
                                                        }
                                                        wit_bindgen::rt::dealloc(
                                                            base25,
                                                            (len25 as usize) * 1,
                                                            1,
                                                        );

                                                        result25
                                                    };
                                                    WitNode::FlagsValue(e54)
                                                }
                                                4 => {
                                                    let e54 = {
                                                        let l26 = *((base + 8) as *const i32);
                                                        let l27 = *((base + 12) as *const i32);
                                                        let len28 = l27 as usize;

                                                        Vec::from_raw_parts(
                                                            l26 as *mut _,
                                                            len28,
                                                            len28,
                                                        )
                                                    };
                                                    WitNode::TupleValue(e54)
                                                }
                                                5 => {
                                                    let e54 = {
                                                        let l29 = *((base + 8) as *const i32);
                                                        let l30 = *((base + 12) as *const i32);
                                                        let len31 = l30 as usize;

                                                        Vec::from_raw_parts(
                                                            l29 as *mut _,
                                                            len31,
                                                            len31,
                                                        )
                                                    };
                                                    WitNode::ListValue(e54)
                                                }
                                                6 => {
                                                    let e54 = {
                                                        let l32 =
                                                            i32::from(*((base + 8) as *const u8));

                                                        match l32 {
                                        0 => None,
                                        1 => {
                                          let e = {
                                            let l33 = *((base + 12) as *const i32);
                                            
                                            l33
                                          };
                                          Some(e)
                                        }
                                        _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                      }
                                                    };
                                                    WitNode::OptionValue(e54)
                                                }
                                                7 => {
                                                    let e54 = {
                                                        let l34 =
                                                            i32::from(*((base + 8) as *const u8));

                                                        match l34 {
                                        0 => {
                                          let e = {
                                            let l35 = i32::from(*((base + 12) as *const u8));
                                            
                                            match l35 {
                                              0 => None,
                                              1 => {
                                                let e = {
                                                  let l36 = *((base + 16) as *const i32);
                                                  
                                                  l36
                                                };
                                                Some(e)
                                              }
                                              _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                            }
                                          };
                                          Ok(e)
                                        }
                                        1 => {
                                          let e = {
                                            let l37 = i32::from(*((base + 12) as *const u8));
                                            
                                            match l37 {
                                              0 => None,
                                              1 => {
                                                let e = {
                                                  let l38 = *((base + 16) as *const i32);
                                                  
                                                  l38
                                                };
                                                Some(e)
                                              }
                                              _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                            }
                                          };
                                          Err(e)
                                        }
                                        _ => wit_bindgen::rt::invalid_enum_discriminant(),
                                      }
                                                    };
                                                    WitNode::ResultValue(e54)
                                                }
                                                8 => {
                                                    let e54 = {
                                                        let l39 =
                                                            i32::from(*((base + 8) as *const u8));

                                                        l39 as u8
                                                    };
                                                    WitNode::PrimU8(e54)
                                                }
                                                9 => {
                                                    let e54 = {
                                                        let l40 =
                                                            i32::from(*((base + 8) as *const u16));

                                                        l40 as u16
                                                    };
                                                    WitNode::PrimU16(e54)
                                                }
                                                10 => {
                                                    let e54 = {
                                                        let l41 = *((base + 8) as *const i32);

                                                        l41 as u32
                                                    };
                                                    WitNode::PrimU32(e54)
                                                }
                                                11 => {
                                                    let e54 = {
                                                        let l42 = *((base + 8) as *const i64);

                                                        l42 as u64
                                                    };
                                                    WitNode::PrimU64(e54)
                                                }
                                                12 => {
                                                    let e54 = {
                                                        let l43 =
                                                            i32::from(*((base + 8) as *const i8));

                                                        l43 as i8
                                                    };
                                                    WitNode::PrimS8(e54)
                                                }
                                                13 => {
                                                    let e54 = {
                                                        let l44 =
                                                            i32::from(*((base + 8) as *const i16));

                                                        l44 as i16
                                                    };
                                                    WitNode::PrimS16(e54)
                                                }
                                                14 => {
                                                    let e54 = {
                                                        let l45 = *((base + 8) as *const i32);

                                                        l45
                                                    };
                                                    WitNode::PrimS32(e54)
                                                }
                                                15 => {
                                                    let e54 = {
                                                        let l46 = *((base + 8) as *const i64);

                                                        l46
                                                    };
                                                    WitNode::PrimS64(e54)
                                                }
                                                16 => {
                                                    let e54 = {
                                                        let l47 = *((base + 8) as *const f32);

                                                        l47
                                                    };
                                                    WitNode::PrimFloat32(e54)
                                                }
                                                17 => {
                                                    let e54 = {
                                                        let l48 = *((base + 8) as *const f64);

                                                        l48
                                                    };
                                                    WitNode::PrimFloat64(e54)
                                                }
                                                18 => {
                                                    let e54 = {
                                                        let l49 = *((base + 8) as *const i32);

                                                        wit_bindgen::rt::char_lift(l49 as u32)
                                                    };
                                                    WitNode::PrimChar(e54)
                                                }
                                                19 => {
                                                    let e54 = {
                                                        let l50 =
                                                            i32::from(*((base + 8) as *const u8));

                                                        wit_bindgen::rt::bool_lift(l50 as u8)
                                                    };
                                                    WitNode::PrimBool(e54)
                                                }
                                                n => {
                                                    debug_assert_eq!(
                                                        n, 20,
                                                        "invalid enum discriminant"
                                                    );
                                                    let e54 = {
                                                        let l51 = *((base + 8) as *const i32);
                                                        let l52 = *((base + 12) as *const i32);
                                                        let len53 = l52 as usize;
                                                        let bytes53 = Vec::from_raw_parts(
                                                            l51 as *mut _,
                                                            len53,
                                                            len53,
                                                        );

                                                        wit_bindgen::rt::string_lift(bytes53)
                                                    };
                                                    WitNode::PrimString(e54)
                                                }
                                            };

                                            v54
                                        };
                                        result55.push(e55);
                                    }
                                    wit_bindgen::rt::dealloc(base55, (len55 as usize) * 24, 8);

                                    WitValue { nodes: result55 }
                                };
                                Ok(e)
                            }
                            1 => {
                                let e = {
                                    let l56 = i32::from(*((ptr10 + 4) as *const u8));
                                    let v69 = match l56 {
                                        0 => {
                                            let e69 = {
                                                let l57 = *((ptr10 + 8) as *const i32);
                                                let l58 = *((ptr10 + 12) as *const i32);
                                                let len59 = l58 as usize;
                                                let bytes59 = Vec::from_raw_parts(
                                                    l57 as *mut _,
                                                    len59,
                                                    len59,
                                                );

                                                wit_bindgen::rt::string_lift(bytes59)
                                            };
                                            RpcError::ProtocolError(e69)
                                        }
                                        1 => {
                                            let e69 = {
                                                let l60 = *((ptr10 + 8) as *const i32);
                                                let l61 = *((ptr10 + 12) as *const i32);
                                                let len62 = l61 as usize;
                                                let bytes62 = Vec::from_raw_parts(
                                                    l60 as *mut _,
                                                    len62,
                                                    len62,
                                                );

                                                wit_bindgen::rt::string_lift(bytes62)
                                            };
                                            RpcError::Denied(e69)
                                        }
                                        2 => {
                                            let e69 = {
                                                let l63 = *((ptr10 + 8) as *const i32);
                                                let l64 = *((ptr10 + 12) as *const i32);
                                                let len65 = l64 as usize;
                                                let bytes65 = Vec::from_raw_parts(
                                                    l63 as *mut _,
                                                    len65,
                                                    len65,
                                                );

                                                wit_bindgen::rt::string_lift(bytes65)
                                            };
                                            RpcError::NotFound(e69)
                                        }
                                        n => {
                                            debug_assert_eq!(n, 3, "invalid enum discriminant");
                                            let e69 = {
                                                let l66 = *((ptr10 + 8) as *const i32);
                                                let l67 = *((ptr10 + 12) as *const i32);
                                                let len68 = l67 as usize;
                                                let bytes68 = Vec::from_raw_parts(
                                                    l66 as *mut _,
                                                    len68,
                                                    len68,
                                                );

                                                wit_bindgen::rt::string_lift(bytes68)
                                            };
                                            RpcError::RemoteInternalError(e69)
                                        }
                                    };

                                    v69
                                };
                                Err(e)
                            }
                            _ => wit_bindgen::rt::invalid_enum_discriminant(),
                        }
                    }
                }
            }
        }
    }
}
pub mod wasi {
    pub mod clocks {

        #[allow(clippy::all)]
        pub mod monotonic_clock {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
            pub type Pollable = super::super::super::wasi::io::poll::Pollable;
            /// An instant in time, in nanoseconds. An instant is relative to an
            /// unspecified initial value, and can only be compared to instances from
            /// the same monotonic-clock.
            pub type Instant = u64;
            /// A duration of time, in nanoseconds.
            pub type Duration = u64;
            #[allow(unused_unsafe, clippy::all)]
            /// Read the current value of the clock.
            ///
            /// The clock is monotonic, therefore calling this function repeatedly will
            /// produce a sequence of non-decreasing values.
            pub fn now() -> Instant {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.0")]
                    extern "C" {
                        #[link_name = "now"]
                        fn wit_import() -> i64;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i64 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Query the resolution of the clock. Returns the duration of time
            /// corresponding to a clock tick.
            pub fn resolution() -> Duration {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.0")]
                    extern "C" {
                        #[link_name = "resolution"]
                        fn wit_import() -> i64;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i64 {
                        unreachable!()
                    }
                    let ret = wit_import();
                    ret as u64
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Create a `pollable` which will resolve once the specified instant
            /// occured.
            pub fn subscribe_instant(when: Instant) -> Pollable {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.0")]
                    extern "C" {
                        #[link_name = "subscribe-instant"]
                        fn wit_import(_: i64) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(wit_bindgen::rt::as_i64(when));
                    super::super::super::wasi::io::poll::Pollable::from_handle(ret as u32)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Create a `pollable` which will resolve once the given duration has
            /// elapsed, starting at the time at which this function was called.
            /// occured.
            pub fn subscribe_duration(when: Duration) -> Pollable {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.2.0")]
                    extern "C" {
                        #[link_name = "subscribe-duration"]
                        fn wit_import(_: i64) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i64) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(wit_bindgen::rt::as_i64(when));
                    super::super::super::wasi::io::poll::Pollable::from_handle(ret as u32)
                }
            }
        }
    }
    pub mod io {

        #[allow(clippy::all)]
        pub mod poll {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
            /// `pollable` epresents a single I/O event which may be ready, or not.

            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Pollable {
                handle: wit_bindgen::rt::Resource<Pollable>,
            }

            impl Pollable {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: wit_bindgen::rt::Resource::from_handle(handle),
                    }
                }

                #[doc(hidden)]
                pub fn into_handle(self) -> u32 {
                    wit_bindgen::rt::Resource::into_handle(self.handle)
                }

                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    wit_bindgen::rt::Resource::handle(&self.handle)
                }
            }

            unsafe impl wit_bindgen::rt::WasmResource for Pollable {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();

                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
                        extern "C" {
                            #[link_name = "[resource-drop]pollable"]
                            fn drop(_: u32);
                        }

                        drop(_handle);
                    }
                }
            }

            impl Pollable {
                #[allow(unused_unsafe, clippy::all)]
                /// Return the readiness of a pollable. This function never blocks.
                ///
                /// Returns `true` when the pollable is ready, and `false` otherwise.
                pub fn ready(&self) -> bool {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
                        extern "C" {
                            #[link_name = "[method]pollable.ready"]
                            fn wit_import(_: i32) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import((self).handle() as i32);
                        wit_bindgen::rt::bool_lift(ret as u8)
                    }
                }
            }
            impl Pollable {
                #[allow(unused_unsafe, clippy::all)]
                /// `block` returns immediately if the pollable is ready, and otherwise
                /// blocks until ready.
                ///
                /// This function is equivalent to calling `poll.poll` on a list
                /// containing only this pollable.
                pub fn block(&self) {
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
                        extern "C" {
                            #[link_name = "[method]pollable.block"]
                            fn wit_import(_: i32);
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32) {
                            unreachable!()
                        }
                        wit_import((self).handle() as i32);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Poll for completion on a set of pollables.
            ///
            /// This function takes a list of pollables, which identify I/O sources of
            /// interest, and waits until one or more of the events is ready for I/O.
            ///
            /// The result `list<u32>` contains one or more indices of handles in the
            /// argument list that is ready for I/O.
            ///
            /// If the list contains more elements than can be indexed with a `u32`
            /// value, this function traps.
            ///
            /// A timeout can be implemented by adding a pollable from the
            /// wasi-clocks API to the list.
            ///
            /// This function does not return a `result`; polling in itself does not
            /// do any I/O so it doesn't fail. If any of the I/O sources identified by
            /// the pollables has an error, it is indicated by marking the source as
            /// being reaedy for I/O.
            pub fn poll(in_: &[&Pollable]) -> wit_bindgen::rt::vec::Vec<u32> {
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, string::String, vec::Vec};
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([u8; 8]);
                    let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                    let vec0 = in_;
                    let len0 = vec0.len() as i32;
                    let layout0 = alloc::Layout::from_size_align_unchecked(vec0.len() * 4, 4);
                    let result0 = if layout0.size() != 0 {
                        let ptr = alloc::alloc(layout0);
                        if ptr.is_null() {
                            alloc::handle_alloc_error(layout0);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec0.into_iter().enumerate() {
                        let base = result0 as i32 + (i as i32) * 4;
                        {
                            *((base + 0) as *mut i32) = (e).handle() as i32;
                        }
                    }
                    let ptr1 = ret_area.as_mut_ptr() as i32;
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasi:io/poll@0.2.0")]
                    extern "C" {
                        #[link_name = "poll"]
                        fn wit_import(_: i32, _: i32, _: i32);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: i32, _: i32) {
                        unreachable!()
                    }
                    wit_import(result0 as i32, len0, ptr1);
                    let l2 = *((ptr1 + 0) as *const i32);
                    let l3 = *((ptr1 + 4) as *const i32);
                    let len4 = l3 as usize;
                    if layout0.size() != 0 {
                        alloc::dealloc(result0, layout0);
                    }
                    Vec::from_raw_parts(l2 as *mut _, len4, len4)
                }
            }
        }
    }
}

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:golem-rust"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 3055] = [
    3, 0, 10, 103, 111, 108, 101, 109, 45, 114, 117, 115, 116, 0, 97, 115, 109, 13, 0, 1, 0, 7,
    235, 22, 1, 65, 2, 1, 65, 11, 1, 66, 25, 1, 122, 4, 0, 10, 110, 111, 100, 101, 45, 105, 110,
    100, 101, 120, 3, 0, 0, 1, 112, 1, 1, 107, 1, 1, 111, 2, 121, 3, 1, 112, 127, 1, 106, 1, 3, 1,
    3, 1, 113, 21, 12, 114, 101, 99, 111, 114, 100, 45, 118, 97, 108, 117, 101, 1, 2, 0, 13, 118,
    97, 114, 105, 97, 110, 116, 45, 118, 97, 108, 117, 101, 1, 4, 0, 10, 101, 110, 117, 109, 45,
    118, 97, 108, 117, 101, 1, 121, 0, 11, 102, 108, 97, 103, 115, 45, 118, 97, 108, 117, 101, 1,
    5, 0, 11, 116, 117, 112, 108, 101, 45, 118, 97, 108, 117, 101, 1, 2, 0, 10, 108, 105, 115, 116,
    45, 118, 97, 108, 117, 101, 1, 2, 0, 12, 111, 112, 116, 105, 111, 110, 45, 118, 97, 108, 117,
    101, 1, 3, 0, 12, 114, 101, 115, 117, 108, 116, 45, 118, 97, 108, 117, 101, 1, 6, 0, 7, 112,
    114, 105, 109, 45, 117, 56, 1, 125, 0, 8, 112, 114, 105, 109, 45, 117, 49, 54, 1, 123, 0, 8,
    112, 114, 105, 109, 45, 117, 51, 50, 1, 121, 0, 8, 112, 114, 105, 109, 45, 117, 54, 52, 1, 119,
    0, 7, 112, 114, 105, 109, 45, 115, 56, 1, 126, 0, 8, 112, 114, 105, 109, 45, 115, 49, 54, 1,
    124, 0, 8, 112, 114, 105, 109, 45, 115, 51, 50, 1, 122, 0, 8, 112, 114, 105, 109, 45, 115, 54,
    52, 1, 120, 0, 12, 112, 114, 105, 109, 45, 102, 108, 111, 97, 116, 51, 50, 1, 118, 0, 12, 112,
    114, 105, 109, 45, 102, 108, 111, 97, 116, 54, 52, 1, 117, 0, 9, 112, 114, 105, 109, 45, 99,
    104, 97, 114, 1, 116, 0, 9, 112, 114, 105, 109, 45, 98, 111, 111, 108, 1, 127, 0, 11, 112, 114,
    105, 109, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 4, 0, 8, 119, 105, 116, 45, 110, 111,
    100, 101, 3, 0, 7, 1, 112, 8, 1, 114, 1, 5, 110, 111, 100, 101, 115, 9, 4, 0, 9, 119, 105, 116,
    45, 118, 97, 108, 117, 101, 3, 0, 10, 1, 114, 1, 5, 118, 97, 108, 117, 101, 115, 4, 0, 3, 117,
    114, 105, 3, 0, 12, 1, 113, 4, 14, 112, 114, 111, 116, 111, 99, 111, 108, 45, 101, 114, 114,
    111, 114, 1, 115, 0, 6, 100, 101, 110, 105, 101, 100, 1, 115, 0, 9, 110, 111, 116, 45, 102,
    111, 117, 110, 100, 1, 115, 0, 21, 114, 101, 109, 111, 116, 101, 45, 105, 110, 116, 101, 114,
    110, 97, 108, 45, 101, 114, 114, 111, 114, 1, 115, 0, 4, 0, 9, 114, 112, 99, 45, 101, 114, 114,
    111, 114, 3, 0, 14, 4, 0, 8, 119, 97, 115, 109, 45, 114, 112, 99, 3, 1, 1, 105, 16, 1, 64, 1,
    8, 108, 111, 99, 97, 116, 105, 111, 110, 13, 0, 17, 4, 0, 21, 91, 99, 111, 110, 115, 116, 114,
    117, 99, 116, 111, 114, 93, 119, 97, 115, 109, 45, 114, 112, 99, 1, 18, 1, 104, 16, 1, 112, 11,
    1, 106, 1, 11, 1, 15, 1, 64, 3, 4, 115, 101, 108, 102, 19, 13, 102, 117, 110, 99, 116, 105,
    111, 110, 45, 110, 97, 109, 101, 115, 15, 102, 117, 110, 99, 116, 105, 111, 110, 45, 112, 97,
    114, 97, 109, 115, 20, 0, 21, 4, 0, 33, 91, 109, 101, 116, 104, 111, 100, 93, 119, 97, 115,
    109, 45, 114, 112, 99, 46, 105, 110, 118, 111, 107, 101, 45, 97, 110, 100, 45, 97, 119, 97,
    105, 116, 1, 22, 3, 1, 21, 103, 111, 108, 101, 109, 58, 114, 112, 99, 47, 116, 121, 112, 101,
    115, 64, 48, 46, 49, 46, 48, 5, 0, 1, 66, 10, 4, 0, 8, 112, 111, 108, 108, 97, 98, 108, 101, 3,
    1, 1, 104, 0, 1, 64, 1, 4, 115, 101, 108, 102, 1, 0, 127, 4, 0, 22, 91, 109, 101, 116, 104,
    111, 100, 93, 112, 111, 108, 108, 97, 98, 108, 101, 46, 114, 101, 97, 100, 121, 1, 2, 1, 64, 1,
    4, 115, 101, 108, 102, 1, 1, 0, 4, 0, 22, 91, 109, 101, 116, 104, 111, 100, 93, 112, 111, 108,
    108, 97, 98, 108, 101, 46, 98, 108, 111, 99, 107, 1, 3, 1, 112, 1, 1, 112, 121, 1, 64, 1, 2,
    105, 110, 4, 0, 5, 4, 0, 4, 112, 111, 108, 108, 1, 6, 3, 1, 18, 119, 97, 115, 105, 58, 105,
    111, 47, 112, 111, 108, 108, 64, 48, 46, 50, 46, 48, 5, 1, 2, 3, 0, 1, 8, 112, 111, 108, 108,
    97, 98, 108, 101, 1, 66, 15, 2, 3, 2, 1, 2, 4, 0, 8, 112, 111, 108, 108, 97, 98, 108, 101, 3,
    0, 0, 1, 119, 4, 0, 7, 105, 110, 115, 116, 97, 110, 116, 3, 0, 2, 1, 119, 4, 0, 8, 100, 117,
    114, 97, 116, 105, 111, 110, 3, 0, 4, 1, 64, 0, 0, 3, 4, 0, 3, 110, 111, 119, 1, 6, 1, 64, 0,
    0, 5, 4, 0, 10, 114, 101, 115, 111, 108, 117, 116, 105, 111, 110, 1, 7, 1, 105, 1, 1, 64, 1, 4,
    119, 104, 101, 110, 3, 0, 8, 4, 0, 17, 115, 117, 98, 115, 99, 114, 105, 98, 101, 45, 105, 110,
    115, 116, 97, 110, 116, 1, 9, 1, 64, 1, 4, 119, 104, 101, 110, 5, 0, 8, 4, 0, 18, 115, 117, 98,
    115, 99, 114, 105, 98, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 10, 3, 1, 33, 119,
    97, 115, 105, 58, 99, 108, 111, 99, 107, 115, 47, 109, 111, 110, 111, 116, 111, 110, 105, 99,
    45, 99, 108, 111, 99, 107, 64, 48, 46, 50, 46, 48, 5, 3, 2, 3, 0, 0, 3, 117, 114, 105, 2, 3, 0,
    2, 8, 100, 117, 114, 97, 116, 105, 111, 110, 1, 66, 91, 2, 3, 2, 1, 4, 4, 0, 3, 117, 114, 105,
    3, 0, 0, 2, 3, 2, 1, 5, 4, 0, 8, 100, 117, 114, 97, 116, 105, 111, 110, 3, 0, 2, 1, 119, 4, 0,
    11, 111, 112, 108, 111, 103, 45, 105, 110, 100, 101, 120, 3, 0, 4, 1, 114, 2, 9, 104, 105, 103,
    104, 45, 98, 105, 116, 115, 119, 8, 108, 111, 119, 45, 98, 105, 116, 115, 119, 4, 0, 4, 117,
    117, 105, 100, 3, 0, 6, 1, 114, 1, 4, 117, 117, 105, 100, 7, 4, 0, 11, 116, 101, 109, 112, 108,
    97, 116, 101, 45, 105, 100, 3, 0, 8, 1, 114, 2, 11, 116, 101, 109, 112, 108, 97, 116, 101, 45,
    105, 100, 9, 11, 119, 111, 114, 107, 101, 114, 45, 110, 97, 109, 101, 115, 4, 0, 9, 119, 111,
    114, 107, 101, 114, 45, 105, 100, 3, 0, 10, 1, 114, 2, 9, 119, 111, 114, 107, 101, 114, 45,
    105, 100, 11, 9, 111, 112, 108, 111, 103, 45, 105, 100, 120, 5, 4, 0, 10, 112, 114, 111, 109,
    105, 115, 101, 45, 105, 100, 3, 0, 12, 1, 114, 4, 12, 109, 97, 120, 45, 97, 116, 116, 101, 109,
    112, 116, 115, 121, 9, 109, 105, 110, 45, 100, 101, 108, 97, 121, 3, 9, 109, 97, 120, 45, 100,
    101, 108, 97, 121, 3, 10, 109, 117, 108, 116, 105, 112, 108, 105, 101, 114, 121, 4, 0, 12, 114,
    101, 116, 114, 121, 45, 112, 111, 108, 105, 99, 121, 3, 0, 14, 1, 113, 3, 15, 112, 101, 114,
    115, 105, 115, 116, 45, 110, 111, 116, 104, 105, 110, 103, 0, 0, 27, 112, 101, 114, 115, 105,
    115, 116, 45, 114, 101, 109, 111, 116, 101, 45, 115, 105, 100, 101, 45, 101, 102, 102, 101, 99,
    116, 115, 0, 0, 5, 115, 109, 97, 114, 116, 0, 0, 4, 0, 17, 112, 101, 114, 115, 105, 115, 116,
    101, 110, 99, 101, 45, 108, 101, 118, 101, 108, 3, 0, 16, 1, 109, 6, 5, 101, 113, 117, 97, 108,
    9, 110, 111, 116, 45, 101, 113, 117, 97, 108, 13, 103, 114, 101, 97, 116, 101, 114, 45, 101,
    113, 117, 97, 108, 7, 103, 114, 101, 97, 116, 101, 114, 10, 108, 101, 115, 115, 45, 101, 113,
    117, 97, 108, 4, 108, 101, 115, 115, 4, 0, 17, 102, 105, 108, 116, 101, 114, 45, 99, 111, 109,
    112, 97, 114, 97, 116, 111, 114, 3, 0, 18, 1, 109, 4, 5, 101, 113, 117, 97, 108, 9, 110, 111,
    116, 45, 101, 113, 117, 97, 108, 4, 108, 105, 107, 101, 8, 110, 111, 116, 45, 108, 105, 107,
    101, 4, 0, 24, 115, 116, 114, 105, 110, 103, 45, 102, 105, 108, 116, 101, 114, 45, 99, 111,
    109, 112, 97, 114, 97, 116, 111, 114, 3, 0, 20, 1, 109, 7, 7, 114, 117, 110, 110, 105, 110,
    103, 4, 105, 100, 108, 101, 9, 115, 117, 115, 112, 101, 110, 100, 101, 100, 11, 105, 110, 116,
    101, 114, 114, 117, 112, 116, 101, 100, 8, 114, 101, 116, 114, 121, 105, 110, 103, 6, 102, 97,
    105, 108, 101, 100, 6, 101, 120, 105, 116, 101, 100, 4, 0, 13, 119, 111, 114, 107, 101, 114,
    45, 115, 116, 97, 116, 117, 115, 3, 0, 22, 1, 114, 2, 10, 99, 111, 109, 112, 97, 114, 97, 116,
    111, 114, 21, 5, 118, 97, 108, 117, 101, 115, 4, 0, 18, 119, 111, 114, 107, 101, 114, 45, 110,
    97, 109, 101, 45, 102, 105, 108, 116, 101, 114, 3, 0, 24, 1, 114, 2, 10, 99, 111, 109, 112, 97,
    114, 97, 116, 111, 114, 19, 5, 118, 97, 108, 117, 101, 23, 4, 0, 20, 119, 111, 114, 107, 101,
    114, 45, 115, 116, 97, 116, 117, 115, 45, 102, 105, 108, 116, 101, 114, 3, 0, 26, 1, 114, 2,
    10, 99, 111, 109, 112, 97, 114, 97, 116, 111, 114, 19, 5, 118, 97, 108, 117, 101, 119, 4, 0,
    21, 119, 111, 114, 107, 101, 114, 45, 118, 101, 114, 115, 105, 111, 110, 45, 102, 105, 108,
    116, 101, 114, 3, 0, 28, 1, 114, 2, 10, 99, 111, 109, 112, 97, 114, 97, 116, 111, 114, 19, 5,
    118, 97, 108, 117, 101, 119, 4, 0, 24, 119, 111, 114, 107, 101, 114, 45, 99, 114, 101, 97, 116,
    101, 100, 45, 97, 116, 45, 102, 105, 108, 116, 101, 114, 3, 0, 30, 1, 114, 3, 4, 110, 97, 109,
    101, 115, 10, 99, 111, 109, 112, 97, 114, 97, 116, 111, 114, 21, 5, 118, 97, 108, 117, 101,
    115, 4, 0, 17, 119, 111, 114, 107, 101, 114, 45, 101, 110, 118, 45, 102, 105, 108, 116, 101,
    114, 3, 0, 32, 1, 113, 5, 4, 110, 97, 109, 101, 1, 25, 0, 6, 115, 116, 97, 116, 117, 115, 1,
    27, 0, 7, 118, 101, 114, 115, 105, 111, 110, 1, 29, 0, 10, 99, 114, 101, 97, 116, 101, 100, 45,
    97, 116, 1, 31, 0, 3, 101, 110, 118, 1, 33, 0, 4, 0, 22, 119, 111, 114, 107, 101, 114, 45, 112,
    114, 111, 112, 101, 114, 116, 121, 45, 102, 105, 108, 116, 101, 114, 3, 0, 34, 1, 112, 35, 1,
    114, 1, 7, 102, 105, 108, 116, 101, 114, 115, 36, 4, 0, 17, 119, 111, 114, 107, 101, 114, 45,
    97, 108, 108, 45, 102, 105, 108, 116, 101, 114, 3, 0, 37, 1, 112, 38, 1, 114, 1, 7, 102, 105,
    108, 116, 101, 114, 115, 39, 4, 0, 17, 119, 111, 114, 107, 101, 114, 45, 97, 110, 121, 45, 102,
    105, 108, 116, 101, 114, 3, 0, 40, 1, 112, 115, 1, 111, 2, 115, 115, 1, 112, 43, 1, 114, 6, 9,
    119, 111, 114, 107, 101, 114, 45, 105, 100, 11, 4, 97, 114, 103, 115, 42, 3, 101, 110, 118, 44,
    6, 115, 116, 97, 116, 117, 115, 23, 16, 116, 101, 109, 112, 108, 97, 116, 101, 45, 118, 101,
    114, 115, 105, 111, 110, 119, 11, 114, 101, 116, 114, 121, 45, 99, 111, 117, 110, 116, 119, 4,
    0, 15, 119, 111, 114, 107, 101, 114, 45, 109, 101, 116, 97, 100, 97, 116, 97, 3, 0, 45, 4, 0,
    11, 103, 101, 116, 45, 119, 111, 114, 107, 101, 114, 115, 3, 1, 1, 107, 41, 1, 105, 47, 1, 64,
    3, 11, 116, 101, 109, 112, 108, 97, 116, 101, 45, 105, 100, 9, 6, 102, 105, 108, 116, 101, 114,
    48, 7, 112, 114, 101, 99, 105, 115, 101, 127, 0, 49, 4, 0, 24, 91, 99, 111, 110, 115, 116, 114,
    117, 99, 116, 111, 114, 93, 103, 101, 116, 45, 119, 111, 114, 107, 101, 114, 115, 1, 50, 1,
    104, 47, 1, 112, 46, 1, 107, 52, 1, 64, 1, 4, 115, 101, 108, 102, 51, 0, 53, 4, 0, 28, 91, 109,
    101, 116, 104, 111, 100, 93, 103, 101, 116, 45, 119, 111, 114, 107, 101, 114, 115, 46, 103,
    101, 116, 45, 110, 101, 120, 116, 1, 54, 1, 64, 0, 0, 13, 4, 0, 20, 103, 111, 108, 101, 109,
    45, 99, 114, 101, 97, 116, 101, 45, 112, 114, 111, 109, 105, 115, 101, 1, 55, 1, 112, 125, 1,
    64, 1, 10, 112, 114, 111, 109, 105, 115, 101, 45, 105, 100, 13, 0, 56, 4, 0, 19, 103, 111, 108,
    101, 109, 45, 97, 119, 97, 105, 116, 45, 112, 114, 111, 109, 105, 115, 101, 1, 57, 1, 64, 2,
    10, 112, 114, 111, 109, 105, 115, 101, 45, 105, 100, 13, 4, 100, 97, 116, 97, 56, 0, 127, 4, 0,
    22, 103, 111, 108, 101, 109, 45, 99, 111, 109, 112, 108, 101, 116, 101, 45, 112, 114, 111, 109,
    105, 115, 101, 1, 58, 1, 64, 1, 10, 112, 114, 111, 109, 105, 115, 101, 45, 105, 100, 13, 1, 0,
    4, 0, 20, 103, 111, 108, 101, 109, 45, 100, 101, 108, 101, 116, 101, 45, 112, 114, 111, 109,
    105, 115, 101, 1, 59, 1, 64, 1, 13, 102, 117, 110, 99, 116, 105, 111, 110, 45, 110, 97, 109,
    101, 115, 0, 1, 4, 0, 12, 103, 101, 116, 45, 115, 101, 108, 102, 45, 117, 114, 105, 1, 60, 1,
    64, 0, 0, 5, 4, 0, 15, 103, 101, 116, 45, 111, 112, 108, 111, 103, 45, 105, 110, 100, 101, 120,
    1, 61, 1, 64, 1, 9, 111, 112, 108, 111, 103, 45, 105, 100, 120, 5, 1, 0, 4, 0, 15, 115, 101,
    116, 45, 111, 112, 108, 111, 103, 45, 105, 110, 100, 101, 120, 1, 62, 1, 64, 1, 8, 114, 101,
    112, 108, 105, 99, 97, 115, 125, 1, 0, 4, 0, 12, 111, 112, 108, 111, 103, 45, 99, 111, 109,
    109, 105, 116, 1, 63, 4, 0, 20, 109, 97, 114, 107, 45, 98, 101, 103, 105, 110, 45, 111, 112,
    101, 114, 97, 116, 105, 111, 110, 1, 61, 1, 64, 1, 5, 98, 101, 103, 105, 110, 5, 1, 0, 4, 0,
    18, 109, 97, 114, 107, 45, 101, 110, 100, 45, 111, 112, 101, 114, 97, 116, 105, 111, 110, 1,
    64, 1, 64, 0, 0, 15, 4, 0, 16, 103, 101, 116, 45, 114, 101, 116, 114, 121, 45, 112, 111, 108,
    105, 99, 121, 1, 65, 1, 64, 1, 16, 110, 101, 119, 45, 114, 101, 116, 114, 121, 45, 112, 111,
    108, 105, 99, 121, 15, 1, 0, 4, 0, 16, 115, 101, 116, 45, 114, 101, 116, 114, 121, 45, 112,
    111, 108, 105, 99, 121, 1, 66, 1, 64, 0, 0, 17, 4, 0, 27, 103, 101, 116, 45, 111, 112, 108,
    111, 103, 45, 112, 101, 114, 115, 105, 115, 116, 101, 110, 99, 101, 45, 108, 101, 118, 101,
    108, 1, 67, 1, 64, 1, 21, 110, 101, 119, 45, 112, 101, 114, 115, 105, 115, 116, 101, 110, 99,
    101, 45, 108, 101, 118, 101, 108, 17, 1, 0, 4, 0, 27, 115, 101, 116, 45, 111, 112, 108, 111,
    103, 45, 112, 101, 114, 115, 105, 115, 116, 101, 110, 99, 101, 45, 108, 101, 118, 101, 108, 1,
    68, 1, 64, 0, 0, 127, 4, 0, 20, 103, 101, 116, 45, 105, 100, 101, 109, 112, 111, 116, 101, 110,
    99, 101, 45, 109, 111, 100, 101, 1, 69, 1, 64, 1, 10, 105, 100, 101, 109, 112, 111, 116, 101,
    110, 116, 127, 1, 0, 4, 0, 20, 115, 101, 116, 45, 105, 100, 101, 109, 112, 111, 116, 101, 110,
    99, 101, 45, 109, 111, 100, 101, 1, 70, 1, 64, 0, 0, 7, 4, 0, 24, 103, 101, 110, 101, 114, 97,
    116, 101, 45, 105, 100, 101, 109, 112, 111, 116, 101, 110, 99, 121, 45, 107, 101, 121, 1, 71,
    3, 1, 20, 103, 111, 108, 101, 109, 58, 97, 112, 105, 47, 104, 111, 115, 116, 64, 48, 46, 50,
    46, 48, 5, 6, 4, 1, 21, 103, 111, 108, 101, 109, 58, 114, 117, 115, 116, 47, 103, 111, 108,
    101, 109, 45, 114, 117, 115, 116, 4, 0, 11, 16, 1, 0, 10, 103, 111, 108, 101, 109, 45, 114,
    117, 115, 116, 3, 0, 0, 0, 16, 12, 112, 97, 99, 107, 97, 103, 101, 45, 100, 111, 99, 115, 0,
    123, 125, 0, 70, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101,
    115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101,
    110, 116, 6, 48, 46, 49, 56, 46, 50, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110,
    45, 114, 117, 115, 116, 6, 48, 46, 49, 54, 46, 48,
];

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_section() {}
